---
title: 'Functional Go: HAMT 简介'
date: 2016-11-06 15:36:17
tags: [Golang, go, functional programming, fp, persist datastructure, immutable, essay, hamt]
category: 'Functional Go'
---

在之前的一个系列的文章里，我们从基本原理开始，一步步实现了基于 Vector Trie 的持久化 List 数据结构。
接下来将要研究的是使用 HAMT 这一数据结构实现持久化 Hash Table。

<!-- more -->

[持久化数据结构简介](https://io-meter.com/2016/09/03/Functional-Go-persist-datastructure-intro/) 这篇文章里，
我们对比各种可以用来实现持久化数据结构的方案，详细介绍了 Vector Trie 这种数据结构，说明了用它实现 List 优势。
HAMT 的全称是 Hash Array Mapped Trie，它和 Vector Trie 一样，都利用了前缀树(Trie)这种数据结构作为底层数据结构，
但是由于 Map 本身和 List 之间性质的差别，HAMT 在很多方面进行了特别的处理。接下来我们先从原始 Hash Table 数据结构谈起，
逐步引出 HAMT 的设计原理。

## Hash Table

Hash Table 是利用对象的 Hash 值对所储存的键进行散列从而实现快速的插入、删除和访问的数据结构。
在 Go 语言中的 `map`、Java 中的 `HashTable` 和 `HashMap` 和 Python 当中的 `dict` 都是 HashTable 的一种。
其基本原理是通过某一 Hash 函数将对象映射在某一虚拟空间上的一个点，并以此为依据将对象保存在内存上的固定位置上。
这样当需要访问这一对象时，依然使用统一 Hash 函数先计算出对象可能存在的位置，并尝试取出。

关于 [Hash](https://en.wikipedia.org/wiki/Hash_function) 和 [Hash Table](https://en.wikipedia.org/wiki/Hash_table)
的概念不再赘述，在这里我们主要需要着眼的是设计实现 Hash Table 所需要处理的几个关键问题:

1. Hash 碰撞问题: 由于 Hash 函数是通过将对象映射到某一数值的方式获得对对象的一个快速的描摹，
因此尽管我们可以断言 Hash 值不同的的对象一定不同，但是并不能保证具有相同 Hash 值的对象一定相同。
因此，在实际应用中遇到 Hash 碰撞的问题，就需要进行处理。
2. 时间效率问题: 对于所有数据结构来说，时间效率都是非常重要的考量因素。Hash Table 从理论上来说的均摊时间复杂度很好，
但是仍然需要考虑在某些极端条件下面的执行性能，保证在各种情况下算法的时间效率不会退化。
3. 空间效率问题: 一般来说，我们不能将 Hash 函数值域整个在内存中一次分配出来。一来这样做在存入元素很少的情况下非常浪费，
二来我们构造的 Hash 函数值域范围很大，一般无法直接分配。因此需要一种方法将空间使用压缩到合理的范围，
同时保持一定的空间效率。
4. 并发同步问题: 和 List 一样，在现代多核盛行的计算环境内，Hash Table 实现的并发安全性也是一个重要的考虑因素。
Hash Table 的插入、访问和删除操作往往包含好连续的几步，如果不能保证这些步骤在一起原子的完成就可能会产生无法预计的结果。

以上四点在实现 Hash Table 的过程当中是互相联系的。比如说 Hash 碰撞问题就与时间效率和空间效率两个方面紧密相连。
一般来说，Hash 碰撞越多，Hash Table 的时间效率越差。根据碰撞处理策略的不同，还有可能影响空间效率。
反过来，如果空间分配的比较多，尽管空间效率下降，但是往往可以缓解 Hash 碰撞的概率，因此改善时间效率。
并发同步问题也与上述问题紧密相连，譬如说有的 Hash Table 实现在空间不足时需要重新分配空间，
这一操作既耗时，又包含很多的指令，对于并发安全提出了很高的要求。

HAMT 在以上四个方面都给出了自己的极佳的解决方案，很多学者将其称为理想(Ideal)的 Hash Table 实现。
在接下来介绍 HAMT 的原理之前，我们先给出在本文中对 Hash 函数的一些假定:

1. Hash 函数的值是 `int32` 类型
2. Hash 函数的值域 `int32` 类型的范围
3. 对于两个不同的对象，总可以找到一个 Hash 函数使二者 Hash 值不同

## HAMT 原理简介

之前介绍了 Vector Trie 实现的持久化 List，如果将这种 List 作为基础，直接套用传统 Hash Table 的实现方法，
其实就可以实现持久化的 HashMap 了。但是这种解决方案在时间效率、空间效率上都比较差。Hash Table 和 List
的一个区别在于 Hash Table 当中保存的元素是散列和稀疏的，不像 List 那样从下标 `0` 一直排列到 `n`。

然而只要把 List 当中下标必须连续的限制条件去掉，Vector Trie 本身就变成了一种相对传统 Array 更好的容器。
下图表示的 Vector Trie 说明了这一点:

![Variant of Vector Trie](/img/posts/variant-of-vector-trie.png)

由上图可见，在 Vector Trie 表示的 Hash Table 中，每个元素的 Hash 值的范围是 0 (`00 00 00 00`) 到 255 (`11 11 11 11`)。
此时 Hash Table 当中只有两个元素，其中一个 hash 值是 0，另一个为 256。在传统 Array 实现的 Hash Table 当中，
在不考虑空间压缩的情况下我们需要分配一个长度 256 的数组来保存。而使用 Trie 只需要 7 个节点，共计 28 个单位的空间。
其它位置因为没有元素存在，因此那些节点可以直接在树中节省掉。

这说明应用 Trie 树可以在节约空间效率方面具有很好的表现。事实上依靠 Trie 树我们可以直接把 0 到 $2^{32} - 1$ (既`int32`)
范围的空间表示出来而不用直接分配全部内存——只有保存了元素的分支会被按需地分配出来。事实上，Trie
树是线性空间上稀疏数组的一种很好的表示形式。

在引入 Trie 树作为数组的稀疏表示之后，我们已经大幅地提高空间效率并得到了不错的时间效率。尽管查询 Trie
树比直接访问数组更慢一些，但是由于我们表示的 Hash 空间足够宽广，在实际应用中遇见碰撞的概率极低，
因此在时间效率上还是很有竞争力的。

至此，在 Vector Trie 的基础上我们得到了通往 HAMT 的第一步：将元素的 Hash 值按位分割成固定宽度的序列，在 Trie
树上以这些序列按顺序查找元素应该存放的位置。然而 HAMT 并不止步于此，从图中容易看出，
我们还有两种优化方案可以达到更好的空间时间效率:

1. 节约单个节点当中空间的浪费: 许多 Trie 节点中仍然有非常多的空位，设法将这些空位清除可以节省很多空间。
2. 削减 Trie 树的高度: 保存在树中的两个元素的 Hash 值从第一位开始就不相同，理论上只需要检查最前面的几位就可以区分。
但是我们仍然构造了全部深度的树，在不产生混淆的情况下避免构造完全深度的树，尽量只利用 Hash 
值当中较高的比特位既可以节约空间，又可以提高时间效率。

在这两个方向，HAMT 都提出了不错的优化方案。
