---
title: 分布式调度器设计模式总结
date: 2018-02-09 15:45:35
tags: [Scheduler, Distributed System, Designing Data-Intensive Applications, Summary, Designing Paradigm] 
---

在之前的文章《[AWS 下 Kylin 调度系统的设计](/2017/10/13/kylin-aws-scheduler-system/)》里我介绍了自己利用 Actor
模型和一些函数式编程思想设计实现 Kylin 调度系统的方法。在这个过程中也阅读了大量文章和论文，
对目前常见的一些调度器的设计方法有了更全面的认识。这篇文章主要是对相关知识的总结。

<!-- more -->

# 调度器的定义

相比而言，我之前文章当中介绍的调度器系统只能算实现了一般范畴上调度器功能的一部分。事实上，
无论是在单机系统还是分布式系统当中，调度器都是非常核心和普遍存在的组件，其内涵也较为宽广和模糊。
一般来说，下面提到的几种类型的模块都可以认为是调度器：

1. 早期计算机系统当中的批处理调度系统
2. 现代计算机系统当中的抢占式进程调度系统和内存分配系统
3. 某些系统或程序提供或实现的，定时激发某些类型操作的工具(如 crontab、[Quartz](http://www.quartz-scheduler.org/) 等)
3. 某些编程语言的 Runtime 提供的线程/纤程/协程调度器(如 Golang 内置的 Goroutine 调度器)
3. 分布式系统当中的任务关系管理和调度执行系统，(如 Hadoop YARN, [Airflow](https://airflow.apache.org/) 等)
4. 分布式系统当中的资源管理和调度系统(如 Mesos、Borg、Kubernetes 的调度器等)

可以看到上述可以被称为调度器的工具涵盖的范围非常广，他们有的提供定时激发任务的能力，有的提供资源管理的能力，
有的负责维护任务的依赖关系和执行顺序。甚至有的系统还集成了任务监控和各种指标度量的工具。

在这篇文章中，我们主要着眼具备任务调度执行和资源分配的调度器模型设计，
不涉及实现定时激发任务以及资源分配的具体算法。

# 调度器设计概述

在系统设计领域研究比较多的朋友可以容易地得出一个结论，那就是我们的系统设计——无论是小到一个嵌入式的系统，
还是大到好几百个机器的集群，在设计抽象上都是在不同的层次上在不断的重复自己。比如说，如果我们着眼于一个 CPU，
他包括计算单元和一系列的用来加速数据访问的缓存 L1、L2、L3 等，每种缓存具有不同的访问速度。
当我们的视野扩大到整个机器，CPU 可以被当成一个单元，我们又有内存和硬盘两个层次的储存系统用于加速数据载入。
而在分布式系统中，如果我们把 HDFS 或 S3 看作硬盘，也存在像 [Alluxio](https://www.alluxio.org/) 
这样发挥着类似内存作用的系统。

既然系统在设计上的基本原则都是类似的，那为什么大规模分布式系统的设计那么困难呢？
这是因为当问题的规模变化了，原先不显著或者容易解决的问题可能会变的难以解决。举例来说，
当我们谈论起进程间通信或者同一个 CPU 不同内核之间的通信时，我们往往不考虑通讯不稳定所带来的问题:
在单机多线程程序的编写当中，我们无法想象如果一个 CPU 内核离线而其他内核上的线程无法知晓这种状况。
然而这种状况在通过网络通讯的多机机群当中是无法回避的问题，这就是我们设计出 Paxos、Raft、Zab
等算法的原因。

在这样的思路的指导下，我们先从单机操作系统调度器的发展历史当中来提取调度器设计的一般思想。

众所周知，早期的计算机系统都是批处理方式执行任务的，只有前一个任务执行完了之后，才可以继续执行下一个任务。
之后人们发现，一个任务的执行可能会利用到不同的资源，比如一个任务可能在一段时间内只需要计算资源，
另一段时间内需要 IO 资源，那么如果将多个任务这样穿插执行，是不是就可以更好的利用资源和更快地执行任务了呢？
这样的思想在现有的分布式 Batch 任务执行系统当中仍然得到了应用。在这个语境下，
调度器实现的功能主要是任务的编排和资源的分配。

在某些应用场景下需要操作系统快速响应外部的信号，并在一定的时间上限内做出计算和反应，
这样的操作系统被称为实时操作系统。实时操作系统对系统处理数据的实时性要求很高，
这和现阶段流行的分布式 Streaming 处理系统非常类似。Streaming 系统往往会预先准备较多的资源用以对应随时出现的外部请求。

如果看一下现阶段普遍流行的单机操作系统，比如 Windows、Linux 和 macOS 等。可以发现它们既不是传统意义上的批处理系统，
也不是真正的实时操作系统。这样的系统的调度器可以看作混合类型的调度器设计，
实现了这样类型调度器的操作系统也被称为通用操作系统。这类操作系统基本上以批处理的方式调度进程，
但是又允许使用中断等机制，使得 CPU 在不同的进程之间切换从而达到一定的实时性。
通用操作系统有时候允许进程本身在自己模型的框架下自行实现调度算法(比如像 Golang 这样语言实现的协程调度),
从而获得更高的灵活性。对灵活性的需求在分布式系统当中也得到了体现。像 Borg 或 Kubernetes 这样的系统，
既有可能运行长时间执行的服务，也有可能用于批量或瞬时的计算服务。而这两种服务往往需要不同的调度策略。

综上所述，调度器设计的三个最基本的需求:

1. 资源的有效利用
2. 任务的实时反馈
3. 任务的灵活调度

这三个需求在某种程度上来说是相互矛盾的，因此需要在设计时做一些取舍。

在上述三个需求的基础上，分布式的调度器设计还需要克服很多其他的困难。这些困难往往在单机系统当中并不显著。
比如说：

1. 状态的同步问题。在单机系统中，我们一般使用常规的同步方法，如共享内存和锁机制，就可以很好地保证任务的协调运行了。
这是因为在单机系统上的状态同步比较稳定和容易。然而在分布式系统中，因为网络通讯的不确定性，
使得机群的各个机器对于周围的状态达成一致是非常困难的任务。实际上，
在分布式系统中甚至无法通过网络精确同步所有机器的时间！
2. 容错性问题。由于单机系统的处理能力有限，我们运行任务的规模和同时运行任务的数量都比较有限。
因此一般的进程错误不由调度器来处理。但是在分布式系统中，由于任务规模变大、任务依赖关系变得更加复杂，
出错的概率大大增加。这时往往无法通过程序自身的保护来解决问题，需要调度器快速地识别错误和重试任务。
3. 描述任务结构的问题。在单机操作系统中，调度器往往不需要了解进程内部的任务组织和执行关系，
而是通过提供一些通用的 API，使得进程可以在给定的模型下自行实现任务管理。在分布式系统当中，
由于任务的规模较大和调度的成本较高，调度器往往需要对任务的模型有所了解，
以便于在任务局部失败的时候快速恢复任务执行或重新分配资源

# 调度系统的模型

# 总结

这篇文章介绍了多种调度器结构设计的模型并讨论了在相关模型下进行任务调度的一些特点。
在最后通过这些模型的对比，我想提出自己对调度系统设计的几点看法：

1. 在小规模的应用和需要自己设计调度器的场景，我们应该尽量采取中心化的调度模型。这是因为这种模型设计和使用都比较简单，
调度器容易对整个系统的状态有全面的把握，状态同步的困难也不高
2. 在机群和应用规模继续扩大或者对调度算法有特殊要求的情况下，推荐使用双层调度器设计，
这种设计兼顾了灵活性和简洁性，适用于绝大部分场景
3. 在更极端或者更大规模的调度需求下，可以考虑采用本文介绍的其他高级调度模型。这些模型虽然能提供更具潜力的调度功能，
却往往更难理解和维护，只适合工程能力非常强的团队

最后，通过学习和亲自设计一套调度系统，我深刻的领会到一些个人在编程的时候非常重要的经验：

1. Keep things simple 。在实现任何程序的时候，简单的设计往往比复杂的设计更好。
比如说尽量减少系统中相互独立的各种模块，尽量统一编程语言，尽量减少相互隔离的系统状态。
这样的设计可以减少 Bug 出现的概率，降低维护状态同步的难度
2. Move fast。在设计复杂系统的时候很容易陷入对细节的不必要追究上，从而导致需要管理的细节越来越多，
增加了很多心智压力。最后系统完成的进度也是难上加难。更好的办法是先从宏观上进行大概的设计，
在进行实现的时候忽略具体的细节(比如代码如何组织、函数如何相互调用、代码如何写得好看等)，
快速迭代并实现功能。当然，在这个过程中也仍然要把握好功能和质量的平衡

# 展望

在本文中，并没有特别涉及到任务调度的具体算法，比如如何准确地定时激发任务，如何更高效地分配资源等等。
调度算法所要解决的问题本质上只有两个：

1. 全面掌握当前系统的状态
2. 准确预测未来的任务需求

很多调度器模型在设计上已经对这两方面有所考量，但调度器算法本身可以说又是一个巨大的主题，
笔者本身对其了解也非常有限，因此不敢在这篇文章中继续展开。从直觉上讲，上述需求二可能是一个和 AI
技术相结合很好的切入点，在未来可能会有很多研究。

在前文还提到了很多调度器也会附带管理本地文件资源的分发，比如像 Kubernetes 启动任务的时候需要将 Docker
镜像分发到各个宿主机上。作为其原型，Borg 在这一过程中甚至利用了 P2P 技术加快分发速度和充分利用带宽。
在开源世界中似乎还没有类似的解决方案。当然，这一需求也只有在机群规模非常大的时候才有价值，
但未来仍可能成为一个不错的发展方向。


