---
title: 'Functional Go: 持久化数据结构简介'
date: 2016-09-03 17:16:15
tags: [Golang, go, functional programming, fp, persist datastructure, immutable, essay]
category: 'Functional Go'
---

函数式编程模型因其天生对并发具备良好的支持而近些年来也越来越瘦到重视。从这篇文章开始，
我将以一个系列的博客来记录函数式编程的一个重要组件：持久化数据结构在 Go 语言下的实现。

<!-- more -->

函数式编程不是新概念，像 Haskell、Clojure、Scala 等函数式／类函数式编程语言也已经出现和存在了很长时间，
很多函数式编程的概念现今已经被应用在很多其他领域，比如 Facebook 在 [React](https://facebook.github.io/react/)
的基础上提出的 [Flux](https://facebook.github.io/flux/) 应用结构抽象就强调了引入持久化数据结构的好处。
事实上，Facebook 还开源了自己的 JavaScript 持久化数据结构实现 [ImmutableJS](https://facebook.github.io/immutable-js/)。
尽管之前已经有 [Elm](http://elm-lang.org/) 这样更纯粹的函数式实现，Facebook 的 React + Flux + ImmutableJS
还是为在一般的前端开发提供了第一个被大规模应用的案例和流行的契机。

尽管很早之前就对函数式编程感兴趣，但是引起我对持久化数据结构兴趣的还是 ImmutableJS，
通过在 React 应用里使用它，我体会到持久化数据结构在很多方面的应用潜力。为了将持久化数据结构应用于 Go
语言编写的后端程序，也为了更好理解这类数据结构的实现，我决定亲自动手用编写这样一套程序。

作为系列博客的第一篇，这篇博客将会先给出一些持久化数据结构的简介并以最简单的 List （列表）数据结构为例，
介绍一些常见的持久化数据结构实现方法。这一个系列的文章都主要参考了
[Understanding Persistent Vector](http://hypirion.com/musings/understanding-persistent-vector-pt-1)
这篇非常经典的文章，其中一些章节甚至可以看作是对它内容的翻译。建议有兴趣的读者浏览原文作为参考。

## 持久化数据结构简介

持久化(Persistent)数据结构又叫不可(Immutable)变数据结构，顾名思义，这类数据结构的内容是不可变的。
也就是说，对于这类数据结构的修改操作，都会返回一个新的副本，而原来的数据结构保存的内容不会有任何改变。
这样的数据结构是有意义的，比方说我们现在所编写的所有程序，都可以看作是一个状态机，
也就是说在程序运行的过程的每一个时刻，程序本身可以被看作存在一个状态(State)，我们的语句不断地作用在这一状态上，
从而不断地产生出进一步的状态，由此循环往复。如果按照这样的模型，那么就存在两个可能的问题需要解决：

1. 我们的有些行为可以看作一系列对状态的修改，比如说通过一个函数内的一系列操作来实现一个功能，
先读出数据库里的内容来进行修改等。这时，我们希望我们的一连串操作是原子的。也就是说整个过程要么全部成功，
要么全部失败。这样的要求在数据库里是通过事务(Transaction)来实现的，某些编程语言(如Haskell)也提供了类似的方案，
而持久化数据结构也是解决这一问题的一种方法——将原来的状态保存在不可变的数据结构中，
只有当整个操作成功完成再将生成的新状态替换回去，这样因为中途错误导致的中间状态就不会污染主状态。
2. 在并发程序中，一个状态的一连串改变可能是并行的，因此一个函数的执行可能会带有副作用——同样的输入和函数，
得到的返回结果却可能不一样。比方说，将一个数组传递进一个函数进行遍历处理，在函数执行的过程中，
另一个线程修改了数组的内容，这样就产生的线程同步等复杂的问题，增加了程序出现问题的可能性，也增加了 Debug 的难度。
由于持久化数据结构本身不会被修改，因此将它传入一个函数是安全的，任何对他的修改都表现在一个新的对象上，
因此你传入函数的方法并不会被改变。

事实上，持久化数据结构天生是一种无锁的数据结构。有些数据结构的实现为了在并发条件下安全运行，
比如使用一些方法为数据结构加锁，这一行为实际上会增加数据结构实现的难度和运行性能，
持久化数据结构不会改变原来的状态，自然也就不会有加锁的必要。

当然，持久化数据结构也有一些缺陷，主要体现在以下几个方面：

1. 由于持久化数据结构在修改时需要生成新的对象，因此往往会比普通数据结构更加耗费内存空间。因此，
任何持久化数据结构在设计上都要考虑如何节省空间这一问题
2. 持久化数据结构往往是在原始数据结构上的包装，通过一些操作来保证原始数据结构的数据的不变性，
因此需要更复杂的操作，这不但体现在修改操作上，也体现在读取操作上。
这导致持久化数据结构的读写速度往往会慢于普通数据结构
3. 为了节省空间以及实现持久化，持久化数据结构的实现往往比较复杂，因此实现起来比较容易出错
4. 持久化数据结构脱胎于函数式编程，与一般的过程式编程语言在思维模式上差别比较大，
操作起来也有很大不同，因此对于习惯了传统过程式编程语言的学习者来说接受起来有一定的困难

尽管如此，持久化数据结构仍然有很大的应用空间，下面给出它们的一些应用场景。

## 持久化数据结构的应用

可以看到，持久化数据结构在很多情况下是有优势的，比如在上述第一种情况，由于大部分数据库帮我们实现了事务模型，
我们可以安全放心的使用它。然而在大多数其他软件系统中并没有现成的事务工具供我们使用，
事务模型依赖于对数据操作的记录，如果运行失败需要对状态进行 Rollback，这不但是一个很难实现的功能，
Rollback 过程也需要花费不少时间。因此持久化数据结构就成了一种不错的选择。
除去 Clojure、Scala 等这种自带了持久化数据结构的编程语言，绝大部分编程语言都有成熟可靠的开源库提供了此类数据结构。

在 React + Flux 模型中，不可变数据结构还被用来加速状态改变的对比，因为 React 
依赖于对比前后两个状态之间的改变来发现需要对 Virtual DOM 进行的最小改变，因此必须要保留每一次修改之后的状态。
所有的操作都必须通过`setState`方法进行，很难保证之前的状态没有被其他地方意外的修改，而对比本身也是耗时的。
但是在引入`ImmutableJS`后，每个 View 的状态就可以很安全的保存起来了。由于在 React 里，`state`
改变总是从一个最初的状态衍生而来的一系列状态，在对前后两个状态进行递归的比较时，如果两个对象的引用是一样的，
那么它们一定是一个不可变的对象，如果两个对象的引用不一致，那么一定经过了修改。因此通过这样的优化可以加速比较的过程。

持久化数据结构的另一个应用是实现文件系统的 Copy on Write 功能，很多文件系统以及虚拟机(VirtualBox)和容器(Docker)
都提供 Snapshot 的功能，也就是说你可以保存文件系统在某一时刻的完整状态并在未来某个时间方便地恢复到当前状态。
这在部署服务的时候非常有用——如果新上线的系统出现问题，我们可以快速简单地回复到原来正常的状态。
传统的 CoW 实现是在某一文件修改的过程时候再复制它，这种实现在遇到比较大的文件时是比较浪费空间的。
然而很多持久化数据结构的实现本身就考虑到了节省空间的问题，因此可以很大程度上缓解这一问题。也就是说，
对于一个文件，我们可以只在写入的时候复制其中一小部分来实现块级别的 CoW。
在接下来的文章中我们可以看到，Vector trie 这种数据结构就很适合实现这一功能。

持久化数据结构的最广泛的应用还是在并发编程当中，结合函数式编程的模型和特点，实现高性能的并发和安全易于预测的代码编写。
在一些多人联机系统(协作工具、联机游戏)当中，多个用户并发地对某一个中心的状态进行修改，而这个中心状态还需要定期的保存。
使用普通的数据结构很难做到安全完善的实现，比方说，用户的一个操作表现在服务端可能是一连串操作，我们希望这些操作是原子的，
在非数据库的环境下就很困难。另一个问题是定期保存的问题，因为跟文件系统或者数据库之间进行的 IO 操作是比较耗时的，
我们往往是定时而不是在每次修改后都执行这一操作。使用传统的数据结构，在保存的时候必须对状态进行加锁，
因为我们不希望在保存的过程当中状态又发生了改变，这对于持久化数据结构保存的状态就不是问题：
我们可以安全的在一个新的线程上执行保存操作，每一个被传入的状态都是当时状态的不可变的快照。这提高了我们程序的并发性。

## 持久化数据结构的实现

在介绍了很多持久化数据结构的特点和应用之后，我们以最简单的顺序储存结构 List
(列表)为例，从简入繁介绍几种实现不可变数据结构的方法和思路。

首先，我们把 List 定义为一种顺序储存结构，它所保存的元素从 0 开始编号，依次向后储存。
这一储存结构包含如下几种基础的操作：

1. `New` 新建一个 List
2. `Get(index)` 获得指定 Index 的元素
3. `Set(index, value)` 修改指定 Index 的元素
4. `PushBack(value)` 在 List 末尾添加一个元素
5. `RemoveBack(value)` 从 List 末尾去除一个元素

此外，这个 List 可能还可以支持如下的一些操作，它们都可以用上面方法来实现(尽管有些数据结构支持更直接的方法)：

1. `Insert(index, value)` 在指定位置插入一个元素
2. `Remove(index, value)` 在指定位置删除一个元素
3. `Slice(i, j)` 获得 List 当中 `i` 到 `j` 之间元素的一个切片
4. `Splice(i, j, List)` 将 List 当中 `i` 到 `j` 之间的元素替换为传入的 List 当中的元素

在实现持久化数据结构的过程中，我们主要考虑的问题是每一种操作的时间消耗和数据结构的空间效率。
我们的目标自然是寻找一种在空间和时间上都比较有效的解决方案，然而也需要注意到各种不同的思路都有比较适合的使用场景，
并不存在在各种情况下都最佳的实现。
