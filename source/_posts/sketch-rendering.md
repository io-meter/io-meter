title: 使用 WebGL 实现素描效果的渲染
date: 2014-12-31 15:48:27
tags: webGL, sketch, rendering, GLSL, shader
---

这次来介绍一下我最近刚完成的一个小玩意儿：通过 WebGL 在网页上显示一个素描风格的场景。

<!-- more -->

开始之前先说点题外话，在过去的两个月里，我开发了一个用来管理矢量图标并生成图标字体的工具：
[MyIcons](http://io-meter.com/myicons)。这是一个 Web-based 的工具，很方便部署到 Heroku，有需要的朋友欢迎围观和体验！
我也会在之后的博文中逐步给出这个工具有关问题的解说。

下面开始这次的主题。

# 一点点综述

这次的素描渲染 Demo 是基于 Three.js 的，跟之前的文章 [Let Rocket Fly](http://io-meter.com/2014/04/05/let-rocket-fly/)
不同，这次要涉及到 Shader 的编写，因此复杂度也要比原来高很多。

实现一个这样的渲染效果，主要的步骤包括：

1. 准备模型和场景
2. 通过 WebGL (Three.js) 导入场景
3. 实现 Shader 以表现接近素描的效果

在最重要的第3步中，我们要实现的主要有两个效果：

1. 模型边缘的描边(不同于单纯的线框)
2. 模型表面类似于素描的线条效果

为了实现这样的效果，我们实际并不能直接在单一的 3D 的空间上完成的，而需要另外准备了一个二维场景用于合成。
总体的渲染与合成流程如下：

![Pipeline](/img/posts/sketch-rendering-pipeline.png)

其中的 3D 场景，就是我们想要处理成素描效果的场景。这里使用了一个小技巧，
那就是我们并非直接将 3D 场景中的渲染效果输出到屏幕，而是先将三种不同类型的渲染结果输出到位于显存中的 Buffer
(Three.js 中的`WebGLRenderTarget`)里。再在 2D 场景中合成这些输出结果。

这个 2D 场景非常简单，里面只有一个恰好和视口大小一样的矩形平面和一个非透视类型的 Camera，
将我们从 3D 场景得到的不同类型的渲染图作为矩形平面的贴图，这样我们就可以编写 Shader
来高效地处理合成效果了。最终输出的结果其实是 2D 场景的渲染结果，但是观看的人不会感觉到任何差异。

使用这样一个简单的 2D 场景进行后期合成可以说是一个非常常用的技巧，因为这样可以通过 OpenGL 充分利用显卡的渲染性能。
