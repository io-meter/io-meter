---
title: 从 Immutable 到 Log-Structured Merge Tree
date: 2017-08-06 12:49:25
tags: [Immutable, Log-Structured Merge Tree, Algorithm, Data structure]
---

说起 Immutable Data Structure，浮现在人们脑海里的可能是 Scala 和 Clojure 或者 ImmutableJS
等语言和库所提供的数据结构。不过，今天这篇文章则是想要通过介绍实现不可变数据结构的一些思路，
带领大家了解另一种具有巨大应用价值的数据结构：Log-Structured Merge Tree。

<!-- more -->

## Immutable Data Structure

在很多编程语言当中，都包含一些数据结构，比如 Python 里的字符串和元组类型等。
这些不可变数据类型都不能进行修改操作。或者说，每次修改这类对象，都会得到一个新的对象，
而原来的对象不会被改变。这样的数据结构我们称为不可变数据结构(Immutable Data Structure)。

不可变数据结构在很多方面都拥有重要的应用价值，比如说：

1. 实现撤销功能。由于不可变数据结构每次操作都产生新的对象，那么一个简单的想法就是我们可以将多个修改产生的对象组织起来，
在实现撤销时直接通过调出之前的对象来恢复原来的状态
2. 在函数式编程的范畴里，因为每个函数对它的操作都会产生新的对象，对不可变数据结构的操作不会产生副作用，
这样的特性既满足了函数式编程的要求，也降低了程序因副作用产生难以调试的 Bug 的可能性
3. 在并发编程中，得益于不可变数据结构的稳定性，避免了共享访问时的互斥访问问题，在很大程度上可以降低并行程序设计的难度。
稍后我们还会看到，不可变数据结构还是无锁数据结构实现的一种重要思路
4. 不可变数据结构因其不可变的特性，在进行树形比较的时候可以简化比较操作的次数，提高比较的性能。
适用于 React 应用的 ImmutableJS 就利用了这一点

Python 中的字符串和元组类型在每次修改时都会复制自身从而产生新的对象。
这种实现方法虽然比较简单，但是在时间和内存空间的消耗上都比较大。像 Scala 和 Clojure
这样的编程语言实现了更为复杂的数据结构(如 Vector Trie 或 HAMT)，从而使得修改之后的对象可以节约很多内存空间，
在性能上也不会有太大的损失。

在这里我们不讨论 Immutable 数据结构具体的实现细节，而是通过两个简单的例子来介绍这类数据结构实现的简单思路。
稍后我们还会看到，版本控制工具 Git 的内部实现中，就恰好应用了这两个技巧。

### Immutable Stack

首先来看第一个例子。我们知道 Stack (栈)是一种先进后出的容器，它支持两种基本操作:

1. 在栈顶插入一个元素
2. 从栈顶取出一个元素

在这个基础上，我们想要实现另外两个功能，从而使得我们的栈具有实现撤销功能，或者说快速查询之前版本的能力。
具体来说就是：

1. 每一次插入和删除操作之后，可以为当前栈中元素的内容制定一个 History ID
2. 指定之前的某一个 History ID，可以快速的恢复栈中元素在那一时刻的快照

这一问题看似不好下手，其实在采用链表来实现栈的情况下，有很优雅的解决方案。
下图展示了一个由链表表示的空栈:

![Empty Stack](/img/immutable/immutable-stack-head-0.jpg)

接下来我们向栈中压入几个元素，得到的栈的状态如下:

![Push](/img/immutable/immutable-stack-head-1.jpg)

那么出栈操作怎么实现呢？我们把指向栈顶的头向后移动几个元素就可以了:

![Pop](/img/immutable/immutable-stack-head-2.jpg)

从新的位置开始插入其它的元素呢？其实只是在栈中开启一个新的分支:

![Push](/img/immutable/immutable-stack-head-3.jpg)

可以看到，我们的 Immutable Stack 相比传统链栈的实现，唯一的区别就是每次改变 HEAD 指针的时候，
我们都用构造一个新的指针来代替，这样通过原来的 HEAD 指针，我们访问到的总是栈在原来时刻的状态，
而从新的指针开始，得到的就是新的状态了。

这一实现方案可以说是相当优雅的。为了实现纪录历史的功能，我们每次操作只多消耗一个 HEAD 指针的空间。
我们把这些 HEAD 指针保存在某一容器中，未来就可以通过其与 History ID 的对应关系来查找它们，
而恢复一个 History ID 所指代的状态快照，只需要从对应的 HEAD 指针开始访问就好了，是一个非常省时且简单的操作。

### Immutable Tree

接下来研究第二个例子。树结构可以说是计算机程序当中非常常用的一种数据结构，文件系统、数据层级等等的表示都依赖于树的实现。
下图展示了一棵用于表示文件系统的树。

![Tree Structure](/img/immutable/tree-structure.jpg)

为简便起见，我们假定树的基本操作是如下的三种：

1. 在树的某个位置添加一个新的节点
2. 删除树的某个叶子节点
3. 修改树的某个节点

在很多应用中，除了上面的三种操作，撤销功能也是非常重要的。也就是说，我们有时候想要容易地将树的状态恢复到之前的一个纪录。
如前文所述，由于不可变数据结构每次都会产生新的对象，它的一大应用就是实现撤销的功能。但是对于一棵树来说，
如果每次都把每个节点复制并保存下来，在时间和空间花费上都非常不经济。这个问题就是我们的 Immutable Tree
数据结构要解决的问题。

下图展示了解决空间消耗问题的一种思路:

![Immutable Tree](/img/immutable/immutable-tree.jpg)

可以看到，当左边树的一个叶子节点被修改之后，我们既不全盘复制所有的节点，也不在原来的节点上进行修改，
而是仅仅将被修改位置一直到根节点的一条路径复制出来再进行修改。在右边虚线圈中的几个节点就是新生成的节点，
这些节点仍然会有指向原来节点的指针，只有被修改路径上的指针是指向新的节点。

使用这种技巧，每次我们只会复制一条路径上的几个节点，比复制全部节点已经有很大提高了。
可以看到，新产生的对象和原来的对象共享了绝大部分内部节点，而每次修改一定会产生一个新的根节点。
使用不同的根节点作为开始，我们访问到的就是树在不同时刻的状态。

这种利用树形结构的特点来共享内部节点是绝大部分不可变数据结构实现的的基本原理，譬如 Scala、Clojure 和
ImmutableJS 实现的 Vector Trie 和 HAMT 本质上就是树形结构。在接下来的文章中，我们还会看到 Git
恰好就使用这两种算法来实现版本控制的功能。

### 案例研究: Git 的对象模型

在看完上面的文章之后，对 Git 比较熟悉的朋友可能已经发现了这两个数据结构和 Git 的相似指出。
诚然，Git 这样的版本控制系统恰巧需要实现的就是文件系统历史状态的纪录和恢复。

打开任意一个 Git 仓库，我们会发现仓库下有一个名为 `.git` 目录，这个目录的简单结构如下:

```bash
.git
├── HEAD
├── objects
│   ├── 0c
│   ├── 0d
│   ├── info
│   └── pack
├── refs
│   ├── heads
│   └── tags
```

其中的`objects`目录就是 Git 储存自己的内部数据对象的位置。无论是被 Commit 过的文件、一个 Commit
对象还是对目录结构的结构都存放在这个地方。在执行 Git 的版本切换和查询操作的时候，Git
就是从这个目录当中读取文件重建历史上某个时候代码仓库的状态的。

如果直接读取这个目录下面文件的内容，会发现它们都是二进制文件，这是因为 Git 对这些内容进行了压缩。
我们可以使用下面的命令快速地获取某个 Hash 值所代表的对象的内容:

```bash
git cat-file -p 5b67fd90081
```

接下来我们来看一个非常简单的 Git 仓库，它的提交历史如下图所示:

![Git Repo History](/img/immutable/git-repo-history.png)

可以看到，在第一个 Commit 里我们添加了一个文件`hello.txt`和一个文件夹`foo`，
文件夹`foo`下面还有两个文件`bar`和`lorem`。在第二个 Commit 当中，我们修改了文件`foo/lorem`。

接下来如果我们使用`git cat-file -p 29fa657b6dd65a6`命令来查看最新的 Commit，将会得到如下的内容:

```bash
tree b0b36b9811c2bd5a208a263236518628972ed32a
parent 3a90366280491ada2d1d56f46e9120ae63c2d945
author chase <i@chasezhang.me> 1502006619 +0800
committer chase <i@chasezhang.me> 1502006619 +0800

Fill lorem
```

在这里我们可以看到一个 Commit 除了纪录作者和 Commit Message 之外还有两个重要的字段，
`tree`和`parent`。其中`parent`字段给出的 Hash 值恰好和这个 Commit 前一个Commit 的值相同，
它就是每个 Commit 指向上一个 Commit 的指针。那么`tree`字段的作用是什么呢？
我们使用`git cat-file -p b0b36b9811c2`来查看一下他的内容:

```bash
040000 tree 91288d89327ac71ad84fa4eb08586b2b78d8cafb    foo
100644 blob 980a0d5f19a64b4b30a87d4206aade58726b60e3    hello.txt
```

可以看出这个对象给出了当前文件目录的一个描述，其中子目录`foo`仍然是一棵树，而`hello.txt`是一个文件。
前面提到，第一个 Commit 和第二个 Commit 只有`foo/lorem`这个文件修改了，那么 Git 是如何纪录这个修改的呢？
我们来看第一个 Commit 的 tree 字段的内容:

```bash
040000 tree 2c90d818605361f15a66019953e13fdf86aacf6c    foo
100644 blob 980a0d5f19a64b4b30a87d4206aade58726b60e3    hello.txt
```

可以看到，两相对比，没有改动的`hello.txt`在两个 Commit 对应的 Tree 里指向的都是同一个对象，
而`foo`文件夹则指向了新的对象因而 Hash 值并不相同。如果近一步查看`foo`目录，也会观察到类似的现象。
也就是说，Git 的内部对象的组织，就是利用了前面介绍的两个简单的算法。Git 的 Commits 就对应于 Immutable Stack，
而 Git 的文件系统就是使用 Immutable Tree 来纪录的。

![Git Object Model](/img/immutable/git-object-model.jpg)
