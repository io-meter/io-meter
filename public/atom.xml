<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[IO-meter]]></title>
  <subtitle><![CDATA[Programic Creativity]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://io-meter.com/"/>
  <updated>2015-01-01T15:45:59.252Z</updated>
  <id>http://io-meter.com/</id>
  
  <author>
    <name><![CDATA[Chase Zhang]]></name>
    <email><![CDATA[yun.er.run@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用 WebGL 实现素描效果的渲染]]></title>
    <link href="http://io-meter.com/2014/12/31/sketch-rendering/"/>
    <id>http://io-meter.com/2014/12/31/sketch-rendering/</id>
    <published>2014-12-31T07:48:27.000Z</published>
    <updated>2015-01-01T15:45:56.000Z</updated>
    <content type="html"><![CDATA[<p>这次来介绍一下我最近刚完成的一个小玩意儿：通过 WebGL 在网页上显示一个素描风格的场景。</p>
<a id="more"></a>

<p>欢迎先使用支持 WebGL 的浏览器浏览一下本文对应的 <a href="http://chasezhang.me/sketch-rendering/" target="_blank">Live Demo</a>。
本文的代码以及场景文件也以 BSD 的协议在 Github 上发布了 (<a href="https://github.com/shanzi/sketch-rendering" target="_blank">这里</a>)。</p>
<p>开始之前先说点题外话，在过去的两个月里，我还开发了一个用来管理矢量图标并生成图标字体的工具：
<a href="http://io-meter.com/myicons">MyIcons</a>。这是一个 Web-based 的工具，很方便部署到 Heroku，有需要的朋友欢迎围观和体验！
我也会在之后的博文中逐步给出这个工具有关问题的解说。</p>
<h2>一点点综述</h2>
<p>这次的素描渲染 Demo 是基于 Three.js 的，跟之前的文章 <a href="http://io-meter.com/2014/04/05/let-rocket-fly/">Let Rocket Fly</a>
不同，这次要涉及到 Shader 的编写，因此复杂度也要比原来高很多。</p>
<p>实现一个这样的渲染效果，主要的步骤包括：</p>
<ol>
<li>准备模型和场景</li>
<li>通过 WebGL (Three.js) 导入场景</li>
<li>实现 Shader 以表现接近素描的效果</li>
</ol>
<p>在最重要的第 3 步中，我们要实现的主要有两个效果：</p>
<ol>
<li>模型边缘的描边 (不同于单纯的线框)</li>
<li>模型表面类似于素描的线条效果</li>
</ol>
<p>为了实现这样的效果，我们实际并不能直接在单一的 3D 的空间上完成的，而需要另外准备一个二维场景用于合成。
总体的渲染与合成流程如下：</p>
<p><img src="/img/posts/sketch-rendering-pipeline.png" alt="Pipeline"></p>
<p>其中的 3D 场景，就是我们想要处理成素描效果的场景。这里使用了一个小技巧，
那就是我们并非直接将 3D 场景中的渲染效果输出到屏幕，而是先将三种不同类型的渲染结果输出到位于显存中的 Buffer
(Three.js 中的<code>WebGLRenderTarget</code>) 里。再在 2D 场景中合成这些输出结果。</p>
<p>这个 2D 场景非常简单，里面只有一个恰好和视口大小一样的矩形平面和一个非透视类型的 Camera，
将我们从 3D 场景得到的不同类型的渲染图作为矩形平面的贴图，这样我们就可以编写 Shader
来高效地处理合成效果了。最终输出的结果其实是 2D 场景的渲染结果，但是观看的人不会感觉到任何差异。</p>
<p>使用这样一个简单的 2D 场景进行后期合成可以说是一个非常常用的技巧，因为这样可以通过 OpenGL 充分利用显卡的渲染性能。</p>
<h2>准备场景</h2>
<p>首先要做的工作是准备用来渲染的场景，选用的建模软件当然是我最喜欢的 <a href="http://blender.org" target="_blank">Blender</a>。我参考
BlenderNation 上刊登的一副<a href="http://www.blendernation.com/2014/08/06/image-entropy/" target="_blank">室内场景作品</a>进行了仿制。
我仿制的场景渲染结果如下:</p>
<p><img src="/img/posts/room-output.png" alt="Scene"></p>
<p>选用这个场景的主要原因是场景的主体结构都非常简单，大多数物体都可以通过简单的立方体变换和修改而成。
大量的平面也方便表现素描的效果。</p>
<p>建模的细节不再赘述。在这一阶段还有一个主要的工序需要完成，那就是 UV 展开和阴影明暗的烘焙 (Bake)。</p>
<p>模型的 UV 展开实质上就是确定模型的贴图坐标与模型坐标的映射关系。一个好的 UV 映射决定了模型渲染时贴图的显示效果。
因为模型表面的素描效果实际是通过贴图实现的，因此如果没有一个好的 UV 映射，显示出来的笔触可能会出现扭曲、变形、
粗细不一等各种问题。UV 展开可以说是一个非常繁琐耗时的工序。最后为了减少工作量，我不得不删除了一些比较复杂的模型。</p>
<p>我将场景中的所有模型合并为一个物体，并完成 UV 展开后的结果如下：</p>
<p><img src="/img/posts/room-uv-mapping.png" alt="UV Mapping"></p>
<p>完成 UV 展开之后将会进行烘焙。所谓的烘焙 (Bake) 就是将模型在场景环境下的明暗变化、阴影等事先渲染并映射到模型的贴图上。
这个技术常用于静态场景中。在这种静态场景里，灯光的位置和角度不会变化，只有摄像机的方向会改变。
因此实际上物体的明暗阴影都是固定的，将其固定在贴图中之后，使用 OpenGL 渲染时不再进行明暗处理和阴影生成。
这样可以节约大量的计算时间。而且使用 CPU 渲染的阴影往往可以使用更为复杂的算法以获得真实的效果。</p>
<p>Blender 的烘焙选项在 Render 选项卡的最下方，这里选择 Full Render 来将一切光源产生的明暗阴影都固定下来。</p>
<p><img src="/img/posts/bake-panel.png" alt="Bake Panel"></p>
<p>对照之前的 UV 展开，我烘焙出来的光影贴图如下：</p>
<p><img src="/img/posts/room-baked.png" alt="Room Baked"></p>
<p>最后，使用 Three.js 提供的<a href="https://github.com/mrdoob/three.js/tree/master/utils/exporters/blender" target="_blank">输出插件</a>，将我们的场景输出成 Three.js 可以识别的<code>.json</code>文件。
我输出的模型文件和相关贴图都已经上传到 GitHub 的<a href="https://github.com/shanzi/sketch-rendering" target="_blank">仓库</a>里。</p>
<p>这里再为有兴趣的同学推荐一个来自台湾同胞的 Blender 基础教程 (<a href="https://www.youtube.com/playlist?list=PLE885296A496C3D38" target="_blank">YouTube</a>)。
个人感觉是 Blender 的中文视频教程中比较好的一个，虽然时间录制早了些，但是讲解很清晰。
而且本文制作时使用的建模、UV 展开、贴图和烘焙技巧都有介绍。</p>
<h2>编写 Shader</h2>
<p>终于到了这篇文章的重中之重了，Shader 是通过 GPU 实现图形渲染的核心，通过 OpenGL
实现的任何 2D 或 3D 效果都离不开它。</p>
<h3>一点点基础知识</h3>
<p>众所周知， WebGL 使用的 Shader 语言其实是 OpenGL 的一个嵌入式版本
OpenGL ES 所定义的，这一 Shader 语言使用了类似 C 语言的语法，但是有下面几个区别：</p>
<ol>
<li>Shader 语言没有动态分配内存的机制，所有内存 (变量) 的空间都是静态分配的</li>
<li>Shader 语言是强类型的，不同类型的数不能隐式转换 (比如整形不能隐式转换为浮点型)</li>
<li>Shader 语言提供的一些数据结构，如向量类型<code>vec2</code>、<code>vec3</code>、<code>vec4</code>
和矩阵类型<code>mat2</code>、<code>mat2</code>、<code>mat4</code>是直接可以使用加减乘除运算符进行操作的。</li>
</ol>
<p>在 WebGL 中，我们可以自己编写的 Shader 有两种类型</p>
<ol>
<li>Vertex Shader: 模型的每个顶点上调用</li>
<li>Fragment Shader: 模型三个顶点组成的面上显示出来的每个像素上执行</li>
</ol>
<p>在渲染时，GPU 会先在每个顶点上执行 Vertex Shader，再在每个像素上执行 Fragment Shader。
Vertex Shader 主要用来计算每个定点投影在视平面上的位置，但是也可以用来进行一些颜色的计算并将结果传送给 Fragment Shader。
Fragment Shader 则决定了最终显示出来的每个像素的颜色。</p>
<p>接下来介绍 Shader 的变量修饰词。Shader 的变量修饰词可以分为 5 种:</p>
<ol>
<li>(无): 默认的变量修饰符，作用域只限本地</li>
<li><code>const</code>: 只读常量</li>
<li><code>attribute</code>: 用来将每个节点的数据和 Vertex Shader 联系起来的变量，简单来说就是在某一个顶点上执行
Vertex Shader 时，变量的值就是这个顶点对应的值。这种对应关系是在初始化 WebGL 的程序时手动指定的。
不过幸好 Three.js 已经为我们完成这一任务了。</li>
<li><code>uniform</code>: 这种类型的变量也是运行在 CPU 的主程序向 Shader 传递数据的一个途径，主要用于与所处理的 Vertex 和 Fragment
无关的值，比如摄像机的位置、灯光光源的位置方向等，这些参数在每一帧的渲染时都不变，因此使用<code>uniform</code>传递进来。</li>
<li><code>varying</code>: 用来从 Vertex Shader 向 Fragment Shader 传递数据的变量。在 Vertex Shader 和 Fragment Shader
上定义相同变量名的<code>varying</code>变量，在运行时 Fragment Shader 中变量的值将会是组成这个面的三个顶点所提供的值的线性插值。</li>
</ol>
<p>Three.js 已经为我们预设了必要的<code>attribute</code>和<code>uniform</code>，
预设变量列表可以参见<a href="http://threejs.org/docs/#Reference/Renderers.WebGL/WebGLProgram" target="_blank">文档</a>。</p>
<p>两种 Shader 都有一个<code>main</code>函数，不过执行的参数并非通过<code>main</code>函数的参数传入程序，
输出结果也不是通过<code>main</code>函数的返回值返回的。实际上，OpenGL 已经固定了每种 Shader 的默认输入变量和输出变量的名称与类型，
程序可以直接访问和设置这些变量。当然，外部程序也可以通过<code>attribute</code>和<code>uniform</code>机制来指定额外的输入。</p>
<p>一个典型的 Vertex Shader 如下面的代码所示：</p>
<figure class="highlight lang-glsl"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">void</span> main(<span class="keyword">void</span>) {
  <span class="built_in">gl_Position</span> = projectionMatrix * modelViewMatrix * <span class="keyword">vec4</span>(position, <span class="number">1.0</span>);
}
</pre></td></tr></table></figure>

<p>其中，<code>position</code>、<code>projectionMatrix</code>、<code>modelViewMatrix</code> 这些变量都是 Three.js 默认设置好并传递进 Shader 的。
<code>position</code>是<code>attribute</code>类型，它代表了每个 Vertex 在 3D 空间中的坐标，另外两个变量是<code>uniform</code>，是 Three.js
根据场景的属性而设定的。<code>gl_Position</code> 就是 OpenGL 指定的 Vertex Shader 的输出值。</p>
<p>一个典型的 Vertex Shader 是通过给出的顶点<code>position</code>，以及相关的一些变换投影矩阵，
计算出这个顶点做透视投影后显示在屏幕中的 2D 坐标。因此在这里也可以实现各种透视效果，
如常见的投影透视 (近大远小)、平视透视 (远近一样大)，甚至超现实的反投影透视 (近小远大) 等。</p>
<p>Fragment Shader 的主要用处是确定某个像素的颜色，其已经指定的输出值为<code>gl_FragColor</code>，这是一个<code>vec4</code>类型的变量，
代表了 RGBA 类型的颜色表示，为每一个表面输出白色的 Fragment Shader 如下:</p>
<figure class="highlight lang-glsl"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">void</span> main(<span class="keyword">void</span>) {
  <span class="built_in">gl_FragColor</span> = <span class="keyword">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);
}
</pre></td></tr></table></figure>

<p>除了直接计算颜色，还可以通过贴图 (texture) 来确定某个 Fragment 的颜色。在 WebGL 中，贴图是通过<code>uniform</code>的方式传递进
Shader 里的，其类型是<code>sample2D</code>。随后，我们可以使用<code>texture2D(texture, uv)</code>函数获得某一个像素的颜色，这里的<code>uv</code>
是一个二维向量，可以通过 Vertex Shader 获得。</p>
<p>在 Three.js 实现访问贴图的一个简单的例子是：</p>
<figure class="highlight lang-glsl"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">// Vertex Shader</span>
<span class="keyword">varying</span> vUv;

<span class="keyword">void</span> main(<span class="keyword">void</span>) {
  <span class="built_in">gl_Position</span> = projectionMatrix * modelViewMatrix * <span class="keyword">vec4</span>(position, <span class="number">1.0</span>);
  vUv = uv;
}

<span class="comment">// Fragment Shader</span>
<span class="keyword">uniform</span> sample2D aTexture;
<span class="keyword">varying</span> vUv;

<span class="keyword">void</span> main(<span class="keyword">void</span>) {
  <span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(aTexture, vUv);
}
</pre></td></tr></table></figure>

<p>在 Vertex Shader 中使用的<code>uv</code>变量，也是 Three.js 中已经提供好的<code>attribute</code>。接下来就是在 Three.js 中使用 Shader 的方法了。</p>
<h3>在 Three.js 中使用 Shader</h3>
<p>Three.js 提供了<code>ShaderMaterial</code>用于实现自定义 Shader 的
Material。下面是一个来自其<a href="http://threejs.org/docs/#Reference/Materials/ShaderMaterial" target="_blank">官方文档</a>的例子。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.ShaderMaterial( {
  uniforms: {
    time: { type: <span class="string">"f"</span>, value: <span class="number">1.0</span> },
    resolution: { type: <span class="string">"v2"</span>, value: <span class="keyword">new</span> THREE.Vector2() }
  },
  attributes: {
    vertexOpacity: { type: <span class="string">'f'</span>, value: [] }
  },
  vertexShader: document.getElementById( <span class="string">'vertexShader'</span> ).textContent,
  fragmentShader: document.getElementById( <span class="string">'fragmentShader'</span> ).textContent
});
</pre></td></tr></table></figure>

<p>你可以通过设置<code>uniforms</code>和<code>attributes</code>等参数向 Shader 传递数据，传递的格式文档中都有介绍。
我们也是在这里将 Shader 需要用到的 Texture 通过<code>uniforms</code>传递进去的。Texture 写在 unifroms 里的<code>type</code>是<code>t</code>，
<code>value</code>可以是一个 Three.js 的<code>Texture</code>对象，也可以是<code>WebGLRenderTarget</code>。</p>
<p>这里只是将值传递了进去，你还是要在 Shader 源码里自己声明这些变量才能访问他们，
在 Shader 里定义的名称应该与你在 JavaScript 中给出的键名相同。</p>
<h2>显示模型的 Outline</h2>
<p>模型的 Outline 就是在卡通风格的图画中围绕在物体边缘的线，因为卡通风格中物体的总体色调都比较平面化，
所以需要这样的线来强调物体与物体之间的区分。</p>
<p>实现这种 Outline 有两种简单直观的方法：</p>
<ol>
<li>使用深度作为特征，将深度变化大的地方标记出来</li>
<li>使用表面法线的方向作为特征，将发现变化大的地方标记出来</li>
</ol>
<p>这两种方法都各自有自己的缺点。比如深度特征时，很容易将一个与观察方向夹角比较小的面全部标记为黑色；
而法线特征时，又无法将前后两个法线相近但是距离较远的表面区分开。这里参考另一篇相关内容的英文博客
<a href="http://floored.com/blog/2014/sketch-rendering.html" target="_blank">Sketch Rendering</a> 的方法来实现。</p>
<p>这种方法结合了深度和法线，假设有两个点 A 和 B，通过计算 A 的空间位置到 B 的法线所构成的平面的距离作为衡量，
判断是否应该标记为 Outline。A 和 B 的空间位置则需要通过 A 和 B 的深度来计算出来。
因此，我们需要先将我们的 3D 场景的深度和法线渲染图输出出来。</p>
<p>Three.js 已经提供了<code>MeshDepthMaterial</code>和<code>MeshNormalMaterial</code>分别用来输出深度和法线渲染图。
我们直接使用这两个类就好了。假设我们已经初始化了一个<code>depthMaterial</code>和一个<code>normalMaterial</code>，
那么将整个场景里的物体都用某一个 Material 进行渲染的话，我们可以使用</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>objectScene.overrideMaterial = depthMaterial; <span class="comment">// 或 normalMaterial</span>
</pre></td></tr></table></figure>

<p>这样的方法实现。</p>
<p>此外，我们不希望渲染结果直接输出到屏幕，因此我们需要先新建一个 <code>WebGLRenderTarget</code> 作为一个 FrameBuffer 来存放结果。
此后这个<code>WebGLRenderTarget</code>可以直接作为贴图传入用于合成的 2D 场景。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> pars = {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.LinearFilter,
  format: THREE.RGBFormat,
  stencilBuffer: <span class="literal">false</span>
}

<span class="keyword">var</span> depthTexture = <span class="keyword">new</span> THREE.WebGLRenderTarget(width, height, pars)
<span class="keyword">var</span> normalTexture = <span class="keyword">new</span> THREE.WebGLRenderTarget(width, height, pars)
</pre></td></tr></table></figure>

<p>使用下面的代码，将渲染结果输出到 FrameBuffer 里:</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// render depth</span>
objectScene.overrideMaterial = depthMaterial;
renderer.setClearColor(<span class="string">'#000000'</span>);
renderer.clearTarget(depthTexture, <span class="literal">true</span>, <span class="literal">true</span>);
renderer.render(objectScene, objectCamera, depthTexture);

<span class="comment">// render normal</span>
objectScene.overrideMaterial = normalMaterial;
renderer.setClearColor(<span class="string">'#000000'</span>);
renderer.clearTarget(normalTexture, <span class="literal">true</span>, <span class="literal">true</span>);
renderer.render(objectScene, objectCamera, normalTexture);
</pre></td></tr></table></figure>

<p>在输出之前，别忘记使用<code>renderer</code>的<code>clearTarget</code>函数将 Buffer 清空。
如果将我们在这一步生成的贴图显示出来的话，大概是下面的样子：</p>
<p><img src="/img/posts/sketch-depth-and-normal.png" alt="Depth &amp; Normal Texture"></p>
<h2>生成素描笔触</h2>
<p>接下来就是在物体的表面生成绘制的素描线条效果了。这个方面其实比想象中更简单一点，
我们的素描效果是使用的是如下一系列贴图组成的:</p>
<p><img src="/img/posts/hatch-maps.png" alt="Hatching Maps"></p>
<p>接下来的问题就是找一种方法将这种不同密度的贴图融合在一起，这种问题被称为 Hatching。
这里使用的 Hatching 方法是 MicroSoft Research
在 2001 年发表的一篇<a href="http://research.microsoft.com/en-us/um/people/hoppe/proj/hatching/" target="_blank">论文</a>中给出的。</p>
<p>不同于原文中使用 6 张贴图合成的方法，这里采用了使用 3 张贴图合成，然后将贴图旋转 90 度再合成一次，
从而获得交叉的笔划。</p>
<figure class="highlight lang-glsl"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">void</span> main() {
  <span class="keyword">vec2</span> uv = vUv * <span class="number">15.0</span>;
  <span class="keyword">vec2</span> uv2 = vUv.yx * <span class="number">10.0</span>;
  <span class="keyword">float</span> shading = <span class="built_in">texture2D</span>(bakedshadow, vUv).r + <span class="number">0.1</span>;
  <span class="keyword">float</span> crossedShading = shade(shading, uv) * shade(shading, uv2) * <span class="number">0.6</span> + <span class="number">0.4</span>;
  <span class="built_in">gl_FragColor</span> = <span class="keyword">vec4</span>(<span class="keyword">vec3</span>(crossedShading), <span class="number">1.0</span>);
}
</pre></td></tr></table></figure>

<p><code>shade</code>函数就是用合成多个贴图的函数，具体代码可以参见 GitHub
上的<a href="https://github.com/shanzi/sketch-rendering/blob/master/coffee/hatch_material.coffee" target="_blank">这个文件</a>。
可以注意到，我其实使用了之前 bake 出来的明暗来作为素描线条深浅的参考因素，
这样就可以表现出明暗和阴影了。</p>
<h2>最后的合成</h2>
<p>最后就是要在我们的二维场景里进行最后的合成了。构造这样一个二维场景的代码很简单:</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> composeCamera = <span class="keyword">new</span> THREE.OrthographicCamera(-width / <span class="number">2</span>, width / <span class="number">2</span>, height / <span class="number">2</span>, -height / <span class="number">2</span>, -<span class="number">10</span>, <span class="number">10</span>);
<span class="keyword">var</span> composePlaneGeometry = <span class="keyword">new</span> THREE.PlaneBufferGeometry(width, height);
composePlaneMesh = <span class="keyword">new</span> THREE.Mesh(composePlaneGeometry, composeMaterial);
composeScene.add(composePlaneMesh);
</pre></td></tr></table></figure>

<p>场景的主要构造就是一个和视口一样大小的矩形几何体，摄像机则是一个<code>OrthographicCamera</code>，这种摄像机没有透视效果，
正合适用于我们这种合成的需求。</p>
<p>将前几步输出到 FrameBuffer (也就是<code>WebGLRenderTarget</code>) 的结果作为这个矩形表面的贴图，
然后我们编写一个 Shader 来进行合成。</p>
<p>这一次，我们不再需要输出到 Buffer 上，而是直接输出到屏幕。而 Outline 的生成也是在这一步完成的。
用来计算 Outline 的函数是:</p>
<figure class="highlight lang-glsl"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">float</span> planeDistance(<span class="keyword">const</span> <span class="keyword">in</span> <span class="keyword">vec3</span> positionA, <span class="keyword">const</span> <span class="keyword">in</span> <span class="keyword">vec3</span> normalA, 
                    <span class="keyword">const</span> <span class="keyword">in</span> <span class="keyword">vec3</span> positionB, <span class="keyword">const</span> <span class="keyword">in</span> <span class="keyword">vec3</span> normalB) {
  <span class="keyword">vec3</span> positionDelta = positionB-positionA;
  <span class="keyword">float</span> planeDistanceDelta = <span class="built_in">max</span>(<span class="built_in">abs</span>(<span class="built_in">dot</span>(positionDelta, normalA)), <span class="built_in">abs</span>(<span class="built_in">dot</span>(positionDelta, normalB)));
  <span class="keyword">return</span> planeDistanceDelta;
}
</pre></td></tr></table></figure>

<p>在当前坐标周围取一个十字形的采样，对于上下和左右取出的点分别执行上面的函数，
最后使用<code>smoothstep</code>来获得 Outline 的颜色:</p>
<figure class="highlight lang-glsl"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">vec2</span> planeDist = <span class="keyword">vec2</span>(
    planeDistance(leftpos, leftnor, rightpos, rightnor),
    planeDistance(uppos, upnor, downpos, downnor));
<span class="keyword">float</span> planeEdge = <span class="number">2.5</span> * <span class="built_in">length</span>(planeDist);
planeEdge = <span class="number">1.0</span> - <span class="number">0.5</span> * <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, depthCenter, planeEdge);
</pre></td></tr></table></figure>

<p>在最后实现的版本里，我还尝试了再混入法线方式生成的边缘线的效果。最终生成的 Outline 效果如下:</p>
<p><img src="/img/posts/sketch-outline.png" alt="Outline"></p>
<p>最后，将 Hatching 过程输出的结果混合进来:</p>
<figure class="highlight lang-glsl"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">vec4</span> hatch = <span class="built_in">texture2D</span>(hatchtexture, vUv);
<span class="built_in">gl_FragColor</span> = <span class="keyword">vec4</span>(<span class="keyword">vec3</span>(hatch * edge), <span class="number">1.0</span>);
</pre></td></tr></table></figure>

<p>完整的实现可以参见我放在 GitHub
上的<a href="https://github.com/shanzi/sketch-rendering/blob/master/coffee/compose_material.coffee" target="_blank">源码</a>。</p>
<p>大功告成！最后的合成效果如图:</p>
<p><img src="/img/posts/sketch-result.png" alt="Final Result"></p>
<p>各位可以访问我使用简单添加了一点交互之后得到的 <a href="http://chasezhang.me/sketch-rendering/" target="_blank">Live Demo</a>
(请使用支持 WebGL 的现代浏览器进行访问，加载模型和全部贴图可能需要一小会，请耐心等待)。</p>
<p>我实现的所有代码以及模型都已经以 BSD 协议发布到 GitHub
上了 (<a href="https://github.com/shanzi/sketch-rendering" target="_blank">这里</a>)。</p>
<h2>总结一下</h2>
<p>虽然是作为我在学校一门课程的 Final Project 的一部分完成的项目，
但是在这个过程中我总算是对于 Shader 的编写方面有所入门。此外，这次进行 Blender
进行建模也感觉比以前顺利了许多。</p>
<p>虽然对 Blender 和 WebGL 的爱好现在看起来还没有什么现实价值，但是能够自己完成一个有趣的 Project
还是很有成就感的！</p>
]]></content>
    <summary type="html"><![CDATA[<p>这次来介绍一下我最近刚完成的一个小玩意儿：通过 WebGL 在网页上显示一个素描风格的场景。</p>
]]></summary>
    
      <category term="webGL" scheme="http://io-meter.com/tags/webGL/"/>
    
      <category term="sketch" scheme="http://io-meter.com/tags/sketch/"/>
    
      <category term="rendering" scheme="http://io-meter.com/tags/rendering/"/>
    
      <category term="GLSL" scheme="http://io-meter.com/tags/GLSL/"/>
    
      <category term="shader" scheme="http://io-meter.com/tags/shader/"/>
    
      <category term="blender" scheme="http://io-meter.com/tags/blender/"/>
    
      <category term="web" scheme="http://io-meter.com/tags/web/"/>
    
      <category term="web" scheme="http://io-meter.com/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Develop for Yosemite: 几个小技巧]]></title>
    <link href="http://io-meter.com/2014/10/24/develop-for-yosemite-some-tips/"/>
    <id>http://io-meter.com/2014/10/24/develop-for-yosemite-some-tips/</id>
    <published>2014-10-24T07:02:02.000Z</published>
    <updated>2014-10-24T12:07:02.000Z</updated>
    <content type="html"><![CDATA[<p>Apple 终于发布了 Xcode 6.1，带来了 Swift for OSX 等多个更新，
这几天我简单研究了下在 Yosemite 下实现一些新的小需求的方法，
这里使用 Swift 语言描述总结一下。</p>
<a id="more"></a>

<h1>Unified Toolbar</h1>
<p>在 Yosemite 中，包括 Safari、系统偏好设置等多个应用都采取了 Unified Toolbar
设计。Toolbar 和左上角控制窗口关闭、最小化和全屏的三个按钮在同一行。如下所示</p>
<p><img src="/img/posts/unified-toolbar.png" alt="Unified Toolbar"></p>
<p>实现这样的功能很简单，只要把 Window 的 Title 隐藏掉就好了。在 Window 对应的 WindowController
中复写<code>windowDidLoad</code>函数，将<code>titleVisibility</code>设置为<code>.Hidden</code>即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>override func windowDidLoad() {
  <span class="keyword">super</span><span class="variable">.windowDidLoad</span>()
  <span class="keyword">self</span><span class="variable">.window</span>?<span class="variable">.titleVisibility</span> = <span class="variable">.Hidden</span> <span class="comment">// NSWindowTitleHidden in ObjC</span>
}
</pre></td></tr></table></figure>

<h1>Translucent View</h1>
<p>Yosemite 视觉设计上的一大特点就是引入了大量模糊透明的效果，
特别是工具栏、菜单和侧边栏的模糊效果非常明显。这些模糊效果都是<code>NSVisualEffectView</code>提供的。
这里演示一下将整个窗口的 ContentView 都加上透明效果的方法。</p>
<p>首先在 Interface Builder 中选中窗口的 ContentView，并将其 Class 类型设置为 <code>NSVisualEffectView</code>。</p>
<p><img src="/img/posts/content-view-class.png" alt="ContentView Class"></p>
<p>此后，为此 View 添加一个 ViewController，并在其<code>viewDidLoad</code>函数中，设置 view 的<code>blendingMode</code>属性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>override func viewDidLoad() {
  <span class="keyword">super</span><span class="variable">.viewDidLoad</span>()
  <span class="keyword">if</span> let view = <span class="keyword">self</span><span class="variable">.view</span> as? NSVisualEffectView {
      <span class="comment">// Make view translucent</span>
      view<span class="variable">.blendingMode</span> = <span class="variable">.BehindWindow</span>
  }
}
</pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="/img/posts/translucent-view.png" alt="Translucent View"></p>
<p>这里的<code>blendingMode</code>有两种选择。<code>.BehindWindow</code>是将窗口后面的内容模糊显示，
此外还有一个<code>.WithinWindow</code>选项，用来实现同一窗口不同 View 下，类似于 Toolbar 那样的模糊效果。</p>
<h1>检查 Dark Mode</h1>
<p>Yosemite 新增的 Dark Mode 是我的最爱，检查 Dark Mode 的状态也有很多应用。
一个最直接的应用就是在右上角显示的状态栏图标，需要使这些图标能根据黑白模式的不同而改变配色。</p>
<p>直接获得系统 Dark Mode 属性的方法我们稍后介绍，这里先介绍一下 Yosemite 为解决图标颜色问题给出的官方解决方案。</p>
<p>Yosemite 推荐的方法是使用<code>NSImage</code>新增的<code>setTemplate</code>方法。简单来说，<code>setTemplate</code>
就是将其代表透明度的<code>alpha</code>通道拿出来作为其形状，这样系统就可以自动地根据黑白的 Mode 来将其填充为黑色或者白色。</p>
<p>为了演示这一特性，我实现选择了两个图片作为图标。因为 Template 下需要用到图片的透明度，因此 PNG 格式是很好的选择。
如下图所示，这两个图标分别用在状态栏的图标选中和未选中的模式中。</p>
<p><img src="/img/posts/statusitem-icons.png" alt="StatusItem Icons"></p>
<p>我在主窗口的<code>WindowController</code>下使用下面的代码来设置 StatusItem，注意其中两行<code>NSImage</code>对象<code>setTemplate</code>方法的调用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="id">AppWindowController</span>: <span class="id">NSWindowController</span> {</span>
  
  var statusItem: NSStatusItem!
  var statusItemMenu: NSMenu!
  
  override func windowDidLoad() {
    statusItemMenu = NSMenu()
    statusItemMenu<span class="variable">.addItemWithTitle</span>(<span class="string">"Testing Menu"</span>, action: <span class="literal">nil</span>, keyEquivalent: <span class="string">""</span>)
    
    let statusBar = NSStatusBar<span class="variable">.systemStatusBar</span>()
    <span class="keyword">self</span><span class="variable">.statusItem</span> = statusBar<span class="variable">.statusItemWithLength</span>(statusBar<span class="variable">.thickness</span>)
    
    statusItem<span class="variable">.image</span> = NSImage(named: <span class="string">"light-bubble"</span>)
    statusItem<span class="variable">.alternateImage</span> = NSImage(named: <span class="string">"dark-bubble"</span>)
    
    statusItem<span class="variable">.image</span>?<span class="variable">.setTemplate</span>(<span class="literal">true</span>) <span class="comment">// set image to template</span>
    statusItem<span class="variable">.alternateImage</span>?<span class="variable">.setTemplate</span>(<span class="literal">true</span>) <span class="comment">// set image to template</span>

    statusItem<span class="variable">.menu</span> = statusItemMenu
  }
</pre></td></tr></table></figure>

<p>最后，在 Dark Mode 下看到的图标效果为：</p>
<p><img src="/img/posts/darkmode-images.png" alt="Dark Mode Icons"></p>
<p>值得注意的是，在 Dark 模式下被标记为<code>Template</code>的图标，其本身的颜色会被忽略，但是在普通模式下，其颜色还是会生效，
因此对于<code>StatusItem</code>的<code>alternateImage</code>，直接使用白色图标是一个很好的选择 (这样在普通模式下显示为蓝底白图标)。</p>
<p>上面给出了一般地使用<code>NSImage</code>的<code>setTemplate</code>函数让系统自动为图标改变颜色的方法。
但是有些时候我们仍不得不切实地检查系统是不是真的在 Dark Mode 下。比如说</p>
<ol>
<li>你的 StatusItem 是使用 View 显示，而非直接使用图片</li>
<li>你希望根据系统是否在 Dark Mode，而调整你整个 App 的 UI 色调</li>
</ol>
<p>这时就必须使用一些侧面的方法来实现了。目前提出来的比较有效的方法是直接读取系统偏好设置。写成函数如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>func isDarkMode() -&gt; Bool {
  <span class="keyword">let</span> systemUserDefaults:Dictionary = NSUserDefaults.standardUserDefaults().persistentDomainForName(NSGlobalDomain)!
  <span class="keyword">let</span> style:AnyObject? = systemUserDefaults[<span class="string">"AppleInterfaceStyle"</span>]?
  <span class="keyword">if</span> <span class="keyword">let</span> styleString = style <span class="keyword">as</span>? String {
    <span class="keyword">return</span> styleString.lowercaseString == <span class="string">"dark"</span>
  }
  <span class="keyword">return</span> <span class="keyword">false</span>
}
</pre></td></tr></table></figure>

<p>监听 Dark Mode 的改变，则通过监听<code>AppleInterfaceThemeChangedNotification</code>这个系统 Notification 来实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="class">NSDistributedNotificationCenter</span>.defaultCenter().addObserver(
      <span class="keyword">self</span>, <span class="method">selector:</span> <span class="comment">"darkModeChanged:"</span>, <span class="method">name:</span> <span class="comment">"AppleInterfaceThemeChangedNotification"</span>, <span class="method">object:</span> <span class="keyword">nil</span>)
</pre></td></tr></table></figure>

<p>需要注意的是，这些方法对于运行在沙盒中的 OSX 应用可能不可用。</p>
<h1>Storyboard</h1>
<p>在 Xcode 6.1 中新增的一个大特性就是为 OSX 应用开发提供了 Storyboard 支持。</p>
<p>iOS 开发者对 Storyboard 应该很熟悉了，那么 OSX 的 Storyboard 的使用起来如何呢？
首先就是 TabView 使用起来比原来方便多了，而弹出 Sheet 和 Popover 也可以直接在 Interface Builder
中完成，不需要再写一些冗余的代码。</p>
<p>这里稍微介绍一下在 Storyboard 里弹出 Popover 的方法，其基本思路和 iOS 上很相似。</p>
<p>如下图，首先在主 View 中添加一个 Pushup Button 和一个新的 ViewController (右边)。</p>
<p><img src="/img/posts/add-button-and-view.png" alt="Add Button and View"></p>
<p>然后将 Button 的 Action 拖到新的 View 上，并选择 Popover 连接起来。如图</p>
<p><img src="/img/posts/binding-popover.png" alt="Binding Popover"></p>
<p>OK，Popover 就完成了，效果如下图。这种方法可以说比原来方便很多。</p>
<p><img src="/img/posts/popover.png" alt="Popover"></p>
<p>此时从我们的主 View 会有一条线连接到我们 Popover 的 View 上，
这个就是新生成的 Segue，选中它还可以进一步设置 Popover 的效果，也可以选择其他的弹出方式。</p>
<p><img src="/img/posts/segue-osx.png" alt="Segue"></p>
<h1>总结</h1>
<p>OK，这几天使用 Swift 编写 OSX 应用时探索出来东西大概就是这么多了。</p>
<p>作为一个曾经的 Objective-C 非专业写者，我算是满心欢喜地投入了 Swift 的怀抱，
而同时 Apple 在这次 Yosemite 当中为 OSX 提供的新特性也没有让人失望。</p>
<p>当然 Xcode 6 和 Yosemite 提供的新玩意还有很多，也还要继续慢慢挖掘才好！</p>
]]></content>
    <summary type="html"><![CDATA[<p>Apple 终于发布了 Xcode 6.1，带来了 Swift for OSX 等多个更新，
这几天我简单研究了下在 Yosemite 下实现一些新的小需求的方法，
这里使用 Swift 语言描述总结一下。</p>
]]></summary>
    
      <category term="OSX" scheme="http://io-meter.com/tags/OSX/"/>
    
      <category term="mac" scheme="http://io-meter.com/tags/mac/"/>
    
      <category term="cocoa" scheme="http://io-meter.com/tags/cocoa/"/>
    
      <category term="swift" scheme="http://io-meter.com/tags/swift/"/>
    
      <category term="develop" scheme="http://io-meter.com/tags/develop/"/>
    
      <category term="desktop" scheme="http://io-meter.com/tags/desktop/"/>
    
      <category term="osx" scheme="http://io-meter.com/categories/osx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[When WebGL Meets Device Motion]]></title>
    <link href="http://io-meter.com/2014/10/03/when-webgl-meets-device-motion/"/>
    <id>http://io-meter.com/2014/10/03/when-webgl-meets-device-motion/</id>
    <published>2014-10-03T06:33:38.000Z</published>
    <updated>2014-10-03T08:03:33.000Z</updated>
    <content type="html"><![CDATA[<p>众所周知，iOS 8 中的一大亮点功能就是为 Safari 添加了 WebGL 的支持并默认开启，
这可以说是 WebGL 的发展历程中的一个重要的里程碑。而我们也终于可以在 iOS 上使用加速度感应器来控制
Web 页面上的 3D 元素的交互。 作为一个小实验，我为之前写的一个 WebGL 小页面添加了重力感应的控制的交互。</p>
<a id="more"></a>

<p>升级了 iOS 8 的 iOS 设备可以访问 <a href="http://sjtug.org" target="_blank">sjtug.org</a> 浏览完成后的页面效果。
关于这个页面 WebGL 方面的实现，之前已经在 <a href="http://io-meter.com/2014/04/05/let-rocket-fly/">Let Rocket Fly</a>
里详细介绍了，这里就不再赘述。本文就主要来讨论一下 Device Motion 相关的内容</p>
<h1>配置 Mobile Debug 环境</h1>
<p>首先，我们要想办法方便地调试页面。因为需要利用加速度感应器，因此最好还是使用真实设备进行调试，
需要先想办法将 iOS 设备上的 Safari 和 OSX 上 Safari 的调试器连接起来。这一功能在 iOS6、
和 OSX 10.8 的时候就已经得到了支持。</p>
<p>首先，在 iOS 8 的 Safari 偏好设置中 Advanced 子菜单里将 Web Inspector 子选项设为开启状态，如下图所示。</p>
<p><img src="/img/posts/enable-web-inspector.png" alt="Enable Web Inspector"></p>
<p>此后，将你的 iOS 设备使用 USB 连接到 Mac 上，再开启桌面版 Safari，就可以在 Developer 菜单下找到对应的设备了。
有时需要重启 Safari 才能看到菜单项。如果找不到 Safari 的 Developer 菜单，你需要首先在偏好设置里激活它。</p>
<p><img src="/img/posts/devices-menu.png" alt="Devices Menu"></p>
<p>OK，现在我们就可以在桌面版的 Safari 上使用调试器调试 iOS 设备上打开的网页了。不光可以捕捉到网页中 Console 输出的
log，甚至还可以完成查看元素、控制页面刷新等等任务，使用上和调试桌面网页没有什么区别。</p>
<p><img src="/img/posts/debug-panel.png" alt="Debug Panel"></p>
<h1>添加 Device Motion 支持</h1>
<p>为了给页面中的小火箭添加 Device Motion 交互支持，我们首先需要判断浏览器是否支持这一特性，
最简单的方法就是使用下面的代码检测<code>DeviceMotionEvent</code>是否存在。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> (window.DeviceMotionEvent) {
  <span class="comment">// the browser support device motion</span>
}
</pre></td></tr></table></figure>

<p>可以设定<code>window.ondevicemotion</code>或使用<code>addEventListener</code>的方法侦听加速度的变化。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>window.addEventListener(<span class="string">'devicemotion'</span>, <span class="keyword">function</span>(e) {
  <span class="comment">// do someting</span>
});
</pre></td></tr></table></figure>

<p>这里得到的<code>Event</code>对象是<code>DeviceMotionEvent</code>对象，可以获取的主要参数为：</p>
<ol>
<li><code>acceleration</code>: 过滤掉重力之后的加速度，有<code>x</code>、<code>y</code>、<code>z</code>三个分量</li>
<li><code>accelerationIncludingGravity</code>: 带有重力的加速度，有<code>x</code>、<code>y</code>、<code>z</code>三个分量</li>
<li><code>rotationRate</code>: 设备在三个方向旋转的角速度，有<code>alpha</code>、<code>beta</code>、<code>gamma</code>三个分量</li>
</ol>
<p>有了这三个属性，我们就可以方便的设计基于设备运动的页面交互了。在本文中，只使用了<code>accelerationIncludingGravity</code>这个属性。
需要注意的是，<code>DeviceMotionEvent</code>所提供的运动参量的坐标系不会随着屏幕窗口方向的改变而改变，也就是说，上述<code>x</code>、<code>y</code>、<code>z</code>
等分量，总是相对于设备本身而言的。具体来说，<code>x</code>方向为垂直于设备的竖直方向，<code>y</code>为平行于设备的竖直方向，<code>z</code>垂直于屏幕向外。</p>
<p>由于这个特性，我们还需要通过检测屏幕的不同 Orientation 方向，来保证我们交互效果的一致性，
不能因横屏或竖屏浏览网页而产生不一样的交互。获取屏幕的 Orientation 可以使用
<code>window.orientation</code>属性。</p>
<p>在 Safari 中，<code>window.orientation</code>是使用数字表示方向的。值和屏幕方向的对应关系为</p>
<ol>
<li>值为 0，屏幕竖直向上</li>
<li>值为 -90，屏幕顺时针旋转 90 度</li>
<li>值为 90，屏幕逆时针旋转 90 度</li>
<li>值为 180，屏幕旋转 180 度</li>
</ol>
<p>了解了上述基础知识后，为我们的小火箭添加运动控制就非常简单了。代码如下:</p>
<figure class="highlight lang-javascript"><figcaption><span>main.js</span><a href="https://github.com/sjtug/sjtug.github.io/blob/master/js/main.js#L57" target="_blank">view on Github</a></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>      <span class="keyword">if</span> (window.DeviceMotionEvent) {
        window.ondevicemotion = <span class="keyword">function</span>(e) {
          <span class="keyword">var</span> ax = event.accelerationIncludingGravity.x;
          <span class="keyword">var</span> ay = event.accelerationIncludingGravity.y;
          <span class="keyword">var</span> orient = window.orientation;
          <span class="keyword">if</span> (orient==<span class="number">0</span>) {
            mx = -ax * <span class="number">80</span>;
            my = -ay * <span class="number">80</span>;
          }
          <span class="keyword">else</span> <span class="keyword">if</span> (orient==<span class="number">90</span>) {
            mx = ay * <span class="number">80</span>;
            my = -ax * <span class="number">80</span>;
          }
          <span class="keyword">else</span> <span class="keyword">if</span> (orient==-<span class="number">90</span>) {
            mx = -ay * <span class="number">80</span>;
            my = -ax * <span class="number">80</span>;
          }
          <span class="keyword">else</span> <span class="keyword">if</span> (orient==<span class="number">180</span>) {
            mx = -ax * <span class="number">80</span>;
            my = ay * <span class="number">80</span>;
          }
        }
      }
</pre></td></tr></table></figure>

<h1>The End</h1>
<p>iOS 8 支持 WebGL 是一件令人振奋的事情。自此，我们不但可以在 iOS 这一主流移动平台上使用 WebGL 进行开发，
也可以利用移动设备特有的一些 API 实现更为有趣的交互。这也许意味着 WebGL 将迎来一次大普及。</p>
<p>尽管在移动设备上运行复杂的 WebGL 页面并不现实，但是像本文这样通过添加简单的 3D 图形，
使原来朴素的页面变得有趣起来，也不啻为一种很好的应用。</p>
]]></content>
    <summary type="html"><![CDATA[<p>众所周知，iOS 8 中的一大亮点功能就是为 Safari 添加了 WebGL 的支持并默认开启，
这可以说是 WebGL 的发展历程中的一个重要的里程碑。而我们也终于可以在 iOS 上使用加速度感应器来控制
Web 页面上的 3D 元素的交互。 作为一个小实验，我为之前写的一个 WebGL 小页面添加了重力感应的控制的交互。</p>
]]></summary>
    
      <category term="webgl" scheme="http://io-meter.com/tags/webgl/"/>
    
      <category term="web" scheme="http://io-meter.com/tags/web/"/>
    
      <category term="accelerate meter" scheme="http://io-meter.com/tags/accelerate%20meter/"/>
    
      <category term="mobile" scheme="http://io-meter.com/tags/mobile/"/>
    
      <category term="iPad" scheme="http://io-meter.com/tags/iPad/"/>
    
      <category term="iOS" scheme="http://io-meter.com/tags/iOS/"/>
    
      <category term="iOS 8" scheme="http://io-meter.com/tags/iOS%208/"/>
    
      <category term="device motion" scheme="http://io-meter.com/tags/device%20motion/"/>
    
      <category term="web" scheme="http://io-meter.com/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在线文本编辑器的基本实现原理]]></title>
    <link href="http://io-meter.com/2014/09/01/contenteditable-and-selection/"/>
    <id>http://io-meter.com/2014/09/01/contenteditable-and-selection/</id>
    <published>2014-09-01T11:56:26.000Z</published>
    <updated>2014-09-01T14:09:54.000Z</updated>
    <content type="html"><![CDATA[<p>最近研究了一下在浏览器中实现的 WYSIWYG 文本编辑器的原理，
在了解基本原理并浏览了 <a href="http://zenpen.io" target="_blank">zenpen</a> 这个相对简单的在线编辑器的源码后，
在这方面有种豁然开朗的感觉。</p>
<a id="more"></a>

<p>说来让人惊讶，最初在浏览器中使之变为可能的浏览器是 IE5。在那个时代，
IE 的确也算是非常先进的浏览器了，现在广为使用的 AJAX 技术，不也是 IE5 最早提供的么？
不过这里就不再讨论当初 IE 那套陈旧的 API 了，而主要来讨论 HTML5 之后被各个浏览器广泛支持的一些技术方法。</p>
<p>进行 WYSIWYG 的文本编辑，需要的几个基础是</p>
<ol>
<li>使得某一部分 DOM 可以被编辑</li>
<li>可以获取和操作用户选中的区域</li>
<li>可以在编辑的同时对所编辑的部分 DOM 进行修改，实现如添加样式等功能</li>
</ol>
<p>这些功能都非常方便实现。</p>
<h2>使 DOM 可编辑</h2>
<p>使一部分 HTML 的 DOM 作为容器进入编辑状态，只需要为这个 DOM 添加一个 <code>contentEditable</code> 属性。
一般来讲，是使用<code>div</code>或者<code>article</code>元素作为这样的容器。</p>
<p>被添加 <code>contentEditable</code> 属性的容器元素的子元素都就可以由用户修改了，
如果想在这个容器下面嵌套一个不可修改的子元素，需要显式地在这个子元素中添加
<code>contentEditable=&#39;false&#39;</code>这样的声明。</p>
<h2>获取和操作用户选择</h2>
<p>操作和获取用户选择是一个非常有用的功能，它不但可以用来实现这里提出的编辑器的功能，
还可以用来实现在光标位置显示提示选单等多种功能，在后面对所编辑部分进行样式修改的时候也常用到。</p>
<p>想要获取一个 Selection 对象非常简单:</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> selection = window.getSelection();
</pre></td></tr></table></figure>

<p>Selection 对象有<code>anchorNode</code>和<code>focusNode</code>两个属性，可以用来获得选中部分的开始和结束元素，
不过实用不多 (一般实用 Range 代替)。此外还有一个<code>isCollapsed</code>
属性值得注意，当其为<code>true</code>时，代表选择区域开始和结束在相同的点，也就是没有选中内容时光标闪烁的模式。</p>
<p>selection 对象还有诸多方法可以用来修改选择范围，主要就是对 Range 对象的编辑。</p>
<p>首先可以通过</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> range = selection.getRangeAt(<span class="number">0</span>);
</pre></td></tr></table></figure>

<p>来获取被选中的第一个区块，以此类推还可以获得第二个、第三个。简单起见我们只讨论选中一个区块的情况。
获得了 Range 对象，我们就可以方便地进行获得选中区域内容了。
Range 对象有一对属性分别用来获得选择区域的开始和结束点。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>range.startContainer <span class="comment">// 开始点所在的容器 (元素)</span>
range.endOffset <span class="comment">// 开始点在其容器内的偏移</span>
range.endContainer <span class="comment">// 结束点所在的容器 (元素)</span>
range.endOffset <span class="comment">// 结束点在其容器内的偏移</span>
</pre></td></tr></table></figure>

<p>除了这两对属性，还有一个非常有用的属性，那就是</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>range.commonAncestorContainer <span class="comment">// 选择范围的共同父元素</span>
</pre></td></tr></table></figure>

<p>上面这个属性常用于检测选择范围的类型 / 样式，比如检测到选中范围的公共父元素是一个 <code>h1</code> 元素，
那么可以在工具栏中将代表 <code>h1</code> 元素的按钮设为激活状态。</p>
<p>需要注意的是，返回的 Range 对象是一类可变对象。简单来说，如果用户的选区改变了，
那么 Range 对象的内容也会改变。因此要记录某一时刻的 Range ，就要记录上面提到了的两对属性。
此外，Range 对象的属性都是只读的，需要通过对应的函数方法来修改。</p>
<p>Range 还定义了各种获取内容和修改内容的函数，详细参数和方法可以参见<a href="https://developer.mozilla.org/en-US/docs/Web/API/range" target="_blank">文档</a>，
这里对几个常见的 Use Case 说明一下。</p>
<h3>获得选取的坐标范围</h3>
<p>我们可以获得光标在网页上的精确位置，对于选区还能得到其矩形边框的几何表示，
这为我们显示提示菜单提供了方便。获得光标的位置或者选区的矩形边框可以使用</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> rect = range.getBoundingClientRect();
</pre></td></tr></table></figure>

<p><code>rect</code>对象包括的属性包括矩形的<code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>坐标。
如果选取是<code>collapsed</code>的话，这四个属性就可以用来计算光标的位置了。</p>
<h3>保存选区并恢复</h3>
<p>如果对选择区域内的元素进行了修改，比如添加新元素、改变元素类型等等，
那么原来的选区会失效。因此一个比较有用的技巧就是在修改元素之前，先保存选区 Range，
待修改完成后再恢复。</p>
<p>一个完整的例子如下：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> selection = window.getSelection();
<span class="keyword">var</span> range = selection.getRangeAt(<span class="number">0</span>);

<span class="comment">// 保存所有 Range 的属性</span>
<span class="keyword">var</span> startContainer = range.startContainer;
<span class="keyword">var</span> startOffset = range.startOffset;
<span class="keyword">var</span> endContainer = range.endContainer;
<span class="keyword">var</span> endOffset = range.endOffset;

<span class="comment">// 进行元素修改操作</span>
<span class="comment">// ......</span>

<span class="comment">// 构造新的 Range</span>
<span class="keyword">var</span> newRange = document.createRange(); <span class="comment">// 注意，此处必须创建一个新的选区，在原来的 range 上修改无效</span>
newRange.setStart(startContainer, startOffset);
newRange.setEnd(endContainer, endOffset);

<span class="comment">// 恢复选区</span>
selection.removeAllRanges();
selection.addRange(newRange);
</pre></td></tr></table></figure>

<p>需要注意的是，有些操作可能会自动修改选区，那么使用上面方法就不能达到恢复选区的目的了。
一个常用的技巧是为恢复选区添加一个延迟，也就是在上面将<code>addRange</code>调用放入<code>setTimeout</code>当中。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>setTimeout(<span class="keyword">function</span>(){
  selection.addRange(newRange);
}, <span class="number">50</span>);
</pre></td></tr></table></figure>

<h2>编辑 DOM，修改样式</h2>
<p>文本编辑器的一个很重要的功能就是修改内容的样式，比如将文字加粗、倾斜、加下划线等。
还包括将段落修改为标题、块引用等。一个比较直观的方法是按照上述介绍的保存和恢复选区的方法，
按照需求修改元素添加样式即可。但是这种方法其实细想起来比较复杂，尤其是段落中，
存在混杂多种样式，以至于存在样式可以嵌套的情况 (比如一段即是加粗又是倾斜的文字)，
维护节点关系和清理空白节点会很繁琐。</p>
<p>好在浏览器为我们提供了一个方便的接口来实现这样的功能。那就是<code>document.execCommand</code>，
这个接口将各种操作抽象成命令的形式。下面展示了实现一些基本功能的方法。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>document.execCommand(<span class="string">'bold'</span>); <span class="comment">// 加粗所选</span>
document.execCommand(<span class="string">'italic'</span>); <span class="comment">// 倾斜所选</span>
document.execCommand(<span class="string">'underline'</span>); <span class="comment">// 下划线所选</span>

document.execCommand(<span class="string">'createLink'</span>, <span class="literal">true</span>, <span class="string">'http://io-meter.com'</span>); <span class="comment">// 为所选文字加链接</span>
document.execCommand(<span class="string">'unlink'</span>); <span class="comment">// 取消链接</span>

document.execCommand(<span class="string">'formatBlock'</span>, <span class="literal">true</span>, <span class="string">'h1'</span>); <span class="comment">// 将光标所在段落修改为一级标题</span>
document.execCommand(<span class="string">'formatBlock'</span>, <span class="literal">true</span>, <span class="string">'p'</span>); <span class="comment">// 将光标所在块修改为段落</span>
</pre></td></tr></table></figure>

<p>除此之外，浏览器还提供了一些编辑命令，如<code>copy</code>、<code>cut</code>和<code>paste</code>等。
完整的命令列表可以参见<a href="https://developer.mozilla.org/en-US/docs/Web/API/document.execCommand" target="_blank">这个文档</a></p>
<p>需要注意的是，各种浏览器对这些命令的支持也有些不同，因此需要格外注意。
了解了这些命令，就具备实现编辑器中修改样式等功能的基本知识了。</p>
<h2>侦听修改</h2>
<p>在此还需要说一点题外话，在以往要侦听用户对文本的修改，一般是绑定<code>keydown</code>事件，
此外考虑到用户还可能选取并拖拽来改变内容，可能还要添加<code>mouseup</code>事件，
这种方法是低效且繁琐的，还对元素样式的修改无能为力。</p>
<p>还好，现代浏览器提供了一种新的机制用来检测内容的修改，那就是 Mutation Observer
机制。关于这方面，有一篇很好的文章值得阅读：
<a href="http://addyosmani.com/blog/mutation-observers/" target="_blank">Detect, Undo And Redo DOM Changes With Mutation Observers</a>。</p>
<h2>总结</h2>
<p>OK，了解了这些知识，实现一个简单的 Web 文本编辑器是不是也显得不那么难了呢？
虽然在这些 API 上不同浏览器还有些差异，但是已经被广泛应用在实现在线文本编辑功能了。</p>
<p>其实如果只专注于现代浏览器，那么实现如同 Medium 那样漂亮又实用的编辑和写作工具也不是非常困难的事！</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近研究了一下在浏览器中实现的 WYSIWYG 文本编辑器的原理，
在了解基本原理并浏览了 <a href="http://zenpen.io" target="_blank">zenpen</a> 这个相对简单的在线编辑器的源码后，
在这方面有种豁然开朗的感觉。</p>
]]></summary>
    
      <category term="contenteditable" scheme="http://io-meter.com/tags/contenteditable/"/>
    
      <category term="selection" scheme="http://io-meter.com/tags/selection/"/>
    
      <category term="html5" scheme="http://io-meter.com/tags/html5/"/>
    
      <category term="editor" scheme="http://io-meter.com/tags/editor/"/>
    
      <category term="online editor" scheme="http://io-meter.com/tags/online%20editor/"/>
    
      <category term="completion" scheme="http://io-meter.com/tags/completion/"/>
    
      <category term="web" scheme="http://io-meter.com/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 语言的包依赖管理]]></title>
    <link href="http://io-meter.com/2014/07/30/go's-package-management/"/>
    <id>http://io-meter.com/2014/07/30/go's-package-management/</id>
    <published>2014-07-30T08:11:44.000Z</published>
    <updated>2014-07-30T12:54:20.000Z</updated>
    <content type="html"><![CDATA[<p>对于从 Ruby、Python 或者 Node 等编程语言转向 Go 语言的开发者，可能会有一个疑问：
Go 语言中的包依赖关系是怎么管理的？有没有什么方便使用的工具呢？
我最近研究了一下这个问题，以下是我的研究报告。</p>
<a id="more"></a>

<p><img src="/img/posts/go-package.jpg" alt="(图片来源：nathany.com)"></p>
<h2>Go 语言本身提供的包管理机制</h2>
<p>在 Go 语言中，我们可以使用<code>go get</code>命令安装远程仓库中托管的代码，不同于 Ruby Gem、pypi 等集中式的包管理机制，
Go 语言的包管理系统是去中心化的。简单来讲，<code>go get</code>命令支持任何一个位置托管的 Git 或 Mercurial
的仓库，无论是 Github 还是 Google Code 上的包，都可以通过这个命令安装。</p>
<p>我们知道，在 Go 语言中的<code>import</code>语句对于已经使用<code>go get</code>安装到本地的包，依然要使用其去绝对路径引入。
比如对于从 Github 上安装的 <a href="https://goji.io/" target="_blank">goji</a>，其在 Github 上的路径 URL 是
<code>https://github.com/zenazn/goji</code>，因此在<code>import</code>它的时候需要使用下面的代码：</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">import</span> <span class="string">"github.com/zenazn/goji"</span>
</pre></td></tr></table></figure>

<p>正因为如此，Go 语言可以通过直接分析代码中的<code>import</code>语句来查询依赖关系。
<code>go get</code>命令在执行时，就会自动解析<code>import</code>来安装所有的依赖。</p>
<p>除了<code>go get</code>，Go 语言还提供了一个 Workspace 的机制，这个机制也是很容易让人困惑的设计。简单来说就是通过设定
<code>GOPATH</code>环境变量，指定除了<code>GOROOT</code>所指定的目录之外，Go 代码所在的位置 (也就是 Workspace 的位置)。
一般来说，<code>GOPATH</code>目录下会包含<code>pkg</code>、<code>src</code>和<code>bin</code>三个子目录，这三个目录各有用处。</p>
<ul>
<li><code>bin</code> 目录用来放置编译好的可执行文件，为了使得这里的可执行文件可以方便的运行，
在 shell 中设置<code>PATH</code>变量。</li>
<li><code>src</code> 目录用来放置代码源文件，在进行<code>import</code>时，是使用这个位置作为根目录的。自己编写的代码也应该放在这下面。</li>
<li><code>pkg</code> 用来放置安装的包的链接对象 (Object) 的。这个概念有点类似于链接库，Go 会将编译出的可连接库放在这里，
方便编译时链接。不同的系统和处理器架构的对象会在<code>pkg</code>存放在不同的文件夹中。</li>
</ul>
<p>我的<code>GOPATH</code>目录树如下所示：</p>
<figure class="highlight lang-plain"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>├── bin
├── pkg
│   └── darwin_amd64
│       └── github.com
│           └── zenazn
│               └── goji
└── src
    ├── code.google.com
    │   └── p
    │       └── go.crypto
    └── github.com
        └── zenazn
            └── goji
</pre></td></tr></table></figure>

<p>一般来说，你自己的代码不应该直接放置在<code>src</code>目录下，而应该为其建立对应的项目文件夹。
<code>go get</code>也会把第三方包的源代码放到这个目录下，因此一般推荐设置两个<code>GOPATH</code>，比如：</p>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>export GOPATH=<span class="string">"/usr/local/share/go:<span class="variable">$HOME</span>/codes/go"</span>
</pre></td></tr></table></figure>

<p>这样第三方包就会默认放置在第一个路径中，而你可以在第二个路径下编写自己的代码。
虽然 Go 语言本身已经提供了相当强大的包管理方式了，但是仍然有一些不足：</p>
<ol>
<li>不能很方便地隔离不同项目的环境</li>
<li>不能很方便地控制某个依赖包的版本</li>
<li>不能管理 Go 本身的版本</li>
</ol>
<p>因此我们还需要一些第三方的工具来弥补这些缺陷。</p>
<h2>第三方的管理工具</h2>
<h3>GOPATH 管理和包管理</h3>
<p>由于存在<code>GOPATH</code>的机制，我们可以使用多个<code>GOPATH</code>来实现项目隔离的方法。
譬如，对于每个项目，都分配一个不同的路径作为<code>GOPATH</code>。
可以实现这样的目的的工具有<a href="https://github.com/pote/gvp" target="_blank">gvp</a>等。</p>
<p>对于 gvp 来说，想要针对当前目录建立一个<code>GOPATH</code>，只需要执行<code>gvp init</code>即可。
gvp 会在当前项目的目录下新建一个隐藏的文件夹作为<code>GOPATH</code>指向的位置。
切换环境时使用下面两个命令来修改环境变量。这种做法跟 Python
中的<a href="https://pypi.python.org/pypi/virtualenv" target="_blank">virtualenv</a>比较类似。</p>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>source gvp <span class="keyword">in</span>   <span class="comment"># 进入当前目录对应的 GOPATH 环境</span>
source gvp out  <span class="comment"># 登出当前目录对应的 GOPATH 环境</span>
</pre></td></tr></table></figure>

<p>至于对依赖包更版本更细致的管理，可以配合的工具还有 <a href="https://github.com/pote/gpm" target="_blank">gpm</a>。
<code>gpm</code>有点类似于 Python 中的<a href="http://pip.readthedocs.org/en/latest/" target="_blank">pip</a>工具。他可以生成一个名为 <code>Godeps</code> 的文件，
其中记录了每个依赖包的 URL 以及使用的版本 (hash tag)。
之前的<a href="http://dev.af83.com/2013/09/14/a-journey-in-golang-package-manager.html" target="_blank">一篇文章</a>提到
<code>gpm</code>只能管理来自 Github 的依赖，不过当前的版本已经支持了非 Git 方式托管的依赖包了。</p>
<p>基于同样原理管理依赖包版本的工具还有<a href="https://github.com/tools/godep" target="_blank">Godep</a>。
这个工具在 Github 上具有相当高的关注度。它所生成的<code>Godeps</code>文件采用 JSON 格式储存，
是一个跟 Node.js 中 <a href="https://www.npmjs.org://www.npmjs.org/" target="_blank">NPM</a> 相仿的工具。</p>
<p>总体来说以上几个工具已经可以解决隔离项目环境和控制依赖包版本的问题了。但是使用上还不算方便，
为了能在我们 cd 到某个目录时自动的切换环境变量，我们可能还需要在 shell
做一些配置使其在<code>cd</code>到项目目录下时自动切换环境变量。</p>
<p>这方面做的比较好的一个选择是 <a href="https://github.com/mattn/gom" target="_blank">Go Manager(gom)</a>，
它生成的<code>Gomfile</code>格式上几乎跟 Ruby Gem 一样。gom 可能是这些工具当中使用最方便的一个，
只要使用<code>gom build</code>命令代替原来的<code>go build</code>命令进行编译，你基本不需要配置 Shell 或者和环境变量打交道。</p>
<h3>Go 语言版本管理</h3>
<p>对于 Go 语言，一般来说并没有使多个语言版本并存的需求。Go 语言现在还没有经历过类似 Python 2.x 到 3.x
或者 Ruby 1.x 到 2.x 这样破坏性的版本升级。旧的代码在新的语言版本当中一般是能够正确运行的。
不过若遇到非要并存多个版本的时候，<a href="https://github.com/moovweb/gvm" target="_blank">gvm</a>就是一个不错的选择。</p>
<p>gvm 的使用跟 <a href="https://rvm.io/" target="_blank">rvm</a> 比较类似。</p>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>gvm install go1 <span class="comment"># 安装 go1 版本</span>
gvm use go1     <span class="comment"># 修改环境变量使用 go1 版本的 Go</span>
</pre></td></tr></table></figure>

<h2>总结</h2>
<p>是否有必要使用多个 Workspace 仍然具有争议，譬如这个 StackOverflow
上的<a href="http://stackoverflow.com/questions/20722502/whats-a-good-best-practice-with-go-workspaces" target="_blank">相关问答</a>中，
就有人提出只使用一个 Workspace 就可以应付大多数情况了。</p>
<p>在研究相关问题的时候，我发现很多 Go 语言的用户都还带着原来编程语言的思维，
这点从上面介绍的多个工具的特点当中就可以很容易看出来：<code>gvp</code>和<code>gpm</code>就是典型的 Python 的包管理模式，
<code>gvp</code>对应着<code>virtualenv</code>，<code>gpm</code>对应着<code>pip</code>；如果你之前是 Node.js 和 NPM 的用户，
那么<code>GoDeps</code>肯定会让你有种熟悉的感觉；更不用说最后介绍的<code>gom</code>了，它从名称到文件格式都在模仿 Ruby Gem。</p>
<p>不同编程背景的开发者来到 Go 语言之后各自带来了自己的依赖包管理方式，而且形成了各自的社区。
这种现象虽然使得各自圈子的开发者免去了选择恐惧症，但是造成的解决方案分裂和互不兼容的情况也需要正视。
这时我们不禁要问，Go 自己的解决方式应该是什么样的？Go 语言为何没有一个官方标准的解决方案呢？</p>
<p>从<a href="http://golang.org/doc/faq#get_version" target="_blank">Go FAQ</a>的一段文字当中我们可以得到部分答案：</p>
<blockquote>
<p>Versioning is a source of significant complexity, especially in large code bases, 
and we are unaware of any approach that works well at scale in a large enough variety
of situations to be appropriate to force on all Go users.
(依赖包的版本管理是一个非常复杂的问题，特别是在代码量比较大的时候。
我们一直没有找到任何一种方式能够在各种情形下都能良好工作，
因此也没有一种方式足够好到应该强迫所有的 Go 用户使用它)</p>
</blockquote>
<p>因此现阶段来看，对于 Go 语言的包管理解决方案，我们也就只能“仁者见仁，智者见智”了。</p>
<p>最后，对于想要了解 Go 语言的包管理以及更多可用的工具的读者，这里再推荐两篇相关的文章：
<a href="http://nathany.com/go-packages/" target="_blank">Go Package Management</a> 和
<a href="http://dev.af83.com/2013/09/14/a-journey-in-golang-package-manager.html" target="_blank">A Journey in Golang Package Manager</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>对于从 Ruby、Python 或者 Node 等编程语言转向 Go 语言的开发者，可能会有一个疑问：
Go 语言中的包依赖关系是怎么管理的？有没有什么方便使用的工具呢？
我最近研究了一下这个问题，以下是我的研究报告。</p>
]]></summary>
    
      <category term="Go" scheme="http://io-meter.com/tags/Go/"/>
    
      <category term="package" scheme="http://io-meter.com/tags/package/"/>
    
      <category term="essay" scheme="http://io-meter.com/categories/essay/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web 设计新趋势: 使用 SVG 代替 Web Icon Font]]></title>
    <link href="http://io-meter.com/2014/07/20/replace-icon-fonts-with-svg/"/>
    <id>http://io-meter.com/2014/07/20/replace-icon-fonts-with-svg/</id>
    <published>2014-07-20T08:20:01.000Z</published>
    <updated>2014-07-20T12:46:41.000Z</updated>
    <content type="html"><![CDATA[<p>如果你还在使用 Icon Font 作为网页中显示图标的实现方案，那么你可能有点 Out 了。
由于使用 Icon Font 显示图标存在一些缺陷，开发者们一直在致力于探索使用 SVG 作为替代的方法。
这篇文章列举了目前 SVG 比较常见的使用方法。</p>
<a id="more"></a>

<p>关于使用 Icon Font 的缺陷，这篇来自 CSS Trick 的 <a href="http://css-tricks.com/icon-fonts-vs-svg/" target="_blank">《Inline SVG vs Icon Font》</a>
可谓是总结的相当全面了。在我看来，Icon Font 的主要缺陷有以下几条：</p>
<ol>
<li>浏览器将其视为文字进行抗锯齿优化，有时得到的效果并没有想象中那么锐利。
尤其是在不同系统下对文字进行抗锯齿的算法不同，可能会导致显示效果不同。</li>
<li>Icon Font 作为一种字体，Icon 显示的大小和位置可能要受到<code>font-size</code>、<code>line-height</code>、<code>word-spacing</code>等等 CSS 属性的影响。
Icon 所在容器的 CSS 样式可能对 Icon 的位置产生影响，调整起来很不方便。</li>
<li>使用上存在不便。首先，加载一个包含数百图标的 Icon Font，却只使用其中几个图标，非常浪费加载时间。
自己制作 Icon Font 以及把多个 Icon Font 中用到的图标整合成一个 Font 也非常不方便。</li>
<li>为了实现最大程度的浏览器支持，可能要提供至少四种不同类型的字体文件。包括<code>TTF</code>、<code>WOFF</code>、<code>EOT</code>
以及一个使用 SVG 格式定义的字体。</li>
</ol>
<p>开发者们想出了多种使用 SVG 的技巧来解决 / 缓解上述问题，下面我们来逐个盘点目前常见的使用方法。</p>
<h1>img/object 标签</h1>
<p>使用 img 和 object 标签直接引用 SVG 是早期常见的使用方法。
这种方法的缺点主要在于要求每个图标都单独保存成一个 SVG 文件，使用时也是单独请求的。
如果在页面中使用的多个图标，每个都是单独请求的话会产生很多请求数，增加服务端的负载和拖慢页面加载速度，
因此现在很少使用了。</p>
<p>不过，在 IE 中可以使用 object 标签实现最后讨论的 SVG Defs/Symbols 的效果。</p>
<h1>Inline SVG</h1>
<p>所谓 Inline SVG，就是直接把 SVG 写入 HTML 中，这种方法简单直接，而且具有最强的可调性。
使用这种方法，你可以使用 CSS 的<code>fill</code>属性和<code>stroke</code>属性来控制填充颜色和边线的颜色，
如果 SVG 图标包含多个部分，你甚至可以设置每个部分的样式。同时，使用 JavaScript 修改 SVG 和生成动画效果都可以实现。</p>
<p>Inline SVG 作为 HTML 文档的一部分，不需要单独请求。临时需要修改某个图标的形状也比较方便。
但是 Inline SVG 使用上比较繁琐，需要在页面中插入一大块 SVG 代码因此不适合手写，图标复用起来也比较麻烦。</p>
<p>好在我们大部分的页面都是由某种模板渲染出来的，无论是使用 PHP、Jinja2 还是 ERuby 模板语言，
都可可以定义一个函数来帮我们 include 这些 SVG。因此在很多情况下是很好的解决方案，
其不适合的主要使用场景就是纯静态页面或者前后端分离客户端页面。</p>
<h1>Data URIs</h1>
<p>Data URIs 是一种不怎么常见的技巧。之前我们在 CSS 里定义元素的背景图片时，常使用像下面这种方式</p>
<figure class="highlight lang-css"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="class">.icon</span> <span class="rules">{
  <span class="rule"><span class="attribute">backgound-image</span>:<span class="value"> <span class="function">url(icons/a.png)</span>
  <span class="comment">/* ... */</span>
}</span></span></span>
</pre></td></tr></table></figure>

<p>而现在，<code>url</code>当中可以放置的可以不仅仅是指向资源的 URL 链接，而可以是数据本身。使用 Data URIs，无论是图片还是 SVG，
你都可以将其编码为 base64 并直接写入 CSS。譬如</p>
<figure class="highlight lang-css"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class">.icon</span><span class="rules">{ 
  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url(data:text/svg+xml;base64,&lt;base64 encoded data&gt;)</span>
}</span></span></span>
</pre></td></tr></table></figure>

<p>关于 base64 编码，请参考<a href="http://zh.wikipedia.org/wiki/Base64" target="_blank">wiki</a>，Data URI 的格式定义如下</p>
<figure class="highlight lang-plain"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data&gt;
</pre></td></tr></table></figure>

<p>使用这种方法，SVG Icon 使用起来和 Icon Font 一样只需要为元素添加 CSS 即可，所有的资源都可以整合在一个 CSS 文件中，
不需要额外引用 SVG 文件。
如果你在使用 <a href="http://gulpjs.com/" target="_blank">Gulp</a> 或者 <a href="http://gruntjs.com/" target="_blank">Grunt</a> 这样的 Build 工具，那么将 SVG 整合到一个 CSS
当中是可以非常方便地自动化完成的。这个任务只有简单的字符串和编码处理，基本不需要依赖非 JavaScript 的库和资源。</p>
<p>使用这种方法的缺点是不能方便地使用 CSS 修改 Icon 的颜色和边线属性。</p>
<h1>SVG Sprite</h1>
<p>目前，一些提供制作 Icon Font 功能的网站 (如<a href="http://icomoon.io" target="_blank">icomoon</a>) 已经提供输出 SVG Sprites 功能了。
SVG Sprites 可以看做上述 Data URIs 方法和之前使用位图的 Sprite 方法的组合。</p>
<p>在 Icon Font 还没普及、图标还主要依靠位图显示的时候，前端工程师都会使用 Sprite 来减少图片请求的次数。
其原理很简单：将所有的图标以一定的间隔排列起来组成一整张大图片，使用时对于某个 Icon，编写如下所示的 CSS。</p>
<figure class="highlight lang-css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="class">.icon-a</span> <span class="rules">{
  <span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">url(/path/to/pic/contains/all/icons.png)</span>;</span></span>
  <span class="rule"><span class="attribute">background-position</span>:<span class="value"> <span class="number">0</span> <span class="number">120</span>px <span class="important">!important</span>;</span></span>
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">24</span>px;</span></span>
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">24</span>px;</span></span>
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>上述 CSS 通过设定<code>background-position</code>调整大图片在背景中的位移，只将某个单个 Icon 暴露出来，其他部分都切掉。
对于所有的 Icon 都写成这样的 CSS 即可使用了。基础的 SVG Sprite 其实只是将原来的位图改成了 SVG。</p>
<p>SVG Sprite 相比于原来的位图 Sprite 的一个优点就是可以通过 CSS 调整 Icon 显示的大小。
使用时还可以 Fallback 到位图的 Sprite，因此有极好的浏览器兼容性。
不过和 Data URIs 方法一样它同样存在不能方便调整颜色样式的问题。</p>
<p>目前辅助生成 SVG Sprites 的工具有 <a href="https://github.com/jkphl/grunt-iconizr" target="_blank">grunt-iconizr</a>、
<a href="https://github.com/shakyShane/gulp-svg-sprites" target="_blank">gulp-svg-sprites</a> 等。
使用这两个工具，只需将用到的 SVG 放到某个文件夹中就可以自动被拼合成 Sprite 并输出对应 CSS。
两个工具都支持生成 PNG 格式的位图作为 Fallback，缺点是生成位图要依赖<a href="http://phantomjs.org/" target="_blank">phantomjs</a>
这个重量级 JS 库。</p>
<h1>SVG Defs/Symbols</h1>
<p>SVG Defs 和 Symbols 的原理类似，这里着重介绍一下 SVG Symbols 的使用，
SVG Defs/Symbols 本质上是对 Sprite 的进一步优化。之前，我们需要使用相对位置来控制哪个图标被显示出来，
但是其实 SVG 本身的定义允许你以某一种方式直接引用 SVG 中的某一部分。</p>
<p>将多个图标整合成一个 SVG 中的多个 Symbols 之后是下面这样的</p>
<figure class="highlight lang-svg"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">svg</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/2000/svg"</span> <span class="attribute">style</span>=<span class="value">"display: none;"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">symbol</span> <span class="attribute">id</span>=<span class="value">"circle-cross"</span> <span class="attribute">viewBox</span>=<span class="value">"0 0 32 32"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">title</span>&gt;</span>circle-cross icon<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
      <span class="tag">&lt;<span class="title">path</span> <span class="attribute">d</span>=<span class="value">"M16 1.333q2.99 0 5.703 1.161t4.677 3.125 3.125 4.677 1.161 5.703-1.161 5.703-3.125 4.677-4.677 3.125-5.703 1.161-5.703-1.161-4.677-3.125-3.125-4.677-1.161-5.703 1.161-5.703 3.125-4.677 4.677-3.125 5.703-1.161zm0 2.667q-2.438 0-4.661.953t-3.828 2.557-2.557 3.828-.953 4.661.953 4.661 2.557 3.828 3.828 2.557 4.661.953 4.661-.953 3.828-2.557 2.557-3.828.953-4.661-.953-4.661-2.557-3.828-3.828-2.557-4.661-.953zm3.771 6.885q.552 0 .948.391t.396.943-.396.948l-2.833 2.833 2.833 2.823q.396.396.396.938 0 .552-.396.943t-.948.391-.938-.385l-2.833-2.823-2.823 2.823q-.385.385-.948.385-.552 0-.943-.385t-.391-.938q0-.563.385-.948l2.833-2.823-2.833-2.833q-.385-.385-.385-.938t.391-.948.943-.396.948.396l2.823 2.833 2.833-2.833q.396-.396.938-.396z"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">symbol</span>&gt;</span>

    <span class="tag">&lt;<span class="title">symbol</span> <span class="attribute">id</span>=<span class="value">"circle-check"</span> <span class="attribute">viewBox</span>=<span class="value">"0 0 32 32"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">title</span>&gt;</span>circle-check icon<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
      <span class="tag">&lt;<span class="title">path</span> <span class="attribute">d</span>=<span class="value">"M16 1.333q2.99 0 5.703 1.161t4.677 3.125 3.125 4.677 1.161 5.703-1.161 5.703-3.125 4.677-4.677 3.125-5.703 1.161-5.703-1.161-4.677-3.125-3.125-4.677-1.161-5.703 1.161-5.703 3.125-4.677 4.677-3.125 5.703-1.161zm0 2.667q-2.438 0-4.661.953t-3.828 2.557-2.557 3.828-.953 4.661.953 4.661 2.557 3.828 3.828 2.557 4.661.953 4.661-.953 3.828-2.557 2.557-3.828.953-4.661-.953-4.661-2.557-3.828-3.828-2.557-4.661-.953zm4.49 7.99q.552 0 .943.391t.391.943-.396.948l-5.656 5.656q-.385.385-.938.385-.563 0-.948-.385l-2.833-2.823q-.385-.385-.385-.948 0-.552.391-.943t.943-.391.948.396l1.885 1.885 4.708-4.719q.396-.396.948-.396z"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">symbol</span>&gt;</span>

    <span class="comment">&lt;!-- .... --&gt;</span>
<span class="tag">&lt;/<span class="title">svg</span>&gt;</span>
</pre></td></tr></table></figure>

<p>每个 Symbol 设置一个 id 作为引用时的名字。使用 id 引用这个 SVG 中的 Icon 有两种方式。</p>
<p>第一种，将上述 SVG 作为 body 的第一个元素插入在 HTML 中 (Chrome 存在一个
<a href="https://code.google.com/p/chromium/issues/detail?id=349175" target="_blank">bug</a> 导致不在这里显示不出图像)，
此后，在需要显示某个 Icon 的地方插入下面的代码即可：</p>
<figure class="highlight lang-svg"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">svg</span> <span class="attribute">class</span>=<span class="value">"icon"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">use</span> <span class="attribute">xlink:href</span>=<span class="value">"#circle-cross"</span>&gt;</span><span class="tag">&lt;/<span class="title">use</span>&gt;</span>
<span class="tag">&lt;/<span class="title">svg</span>&gt;</span>
</pre></td></tr></table></figure>

<p>这里的<code>use</code>标签直接使用<code>#circle-cross</code>这个 id 引用了 SVG 中的图标。这种方式的浏览器兼容性较好。</p>
<p>我更喜欢的是第二种方式，这种方式不需要在 body 开始的地方插入 SVG，而是使用完整路径引用 Icon。
也就是：</p>
<figure class="highlight lang-svg"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">svg</span> <span class="attribute">class</span>=<span class="value">"icon"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">use</span> <span class="attribute">xlink:href</span>=<span class="value">"/img/posts/svg-icons.svg#circle-check"</span>&gt;</span><span class="tag">&lt;/<span class="title">use</span>&gt;</span>
<span class="tag">&lt;/<span class="title">svg</span>&gt;</span>
<span class="tag">&lt;<span class="title">svg</span> <span class="attribute">class</span>=<span class="value">"icon"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">use</span> <span class="attribute">xlink:href</span>=<span class="value">"/img/posts/svg-icons.svg#circle-cross"</span>&gt;</span><span class="tag">&lt;/<span class="title">use</span>&gt;</span>
<span class="tag">&lt;/<span class="title">svg</span>&gt;</span>
</pre></td></tr></table></figure>

<p>显示出来的效果就是下面这个样子 (可以使用浏览器的 Debug 工具来检视下面的代码)。</p>
<div style="border:1px solid #eee;background:#fff;padding:10px">
<svg style="fill:black;width:64px;height:64px" xmlns="http://www.w3.org/2000/svg">
  <use xlink:href="/img/posts/svg-icons.svg#circle-check"></use>
</svg>
<svg style="fill:black;width:64px;height:64px" xmlns="http://www.w3.org/2000/svg">
  <use xlink:href="/img/posts/svg-icons.svg#circle-cross"></use>
</svg>
</div>

<p>这种方式使用上跟<code>img</code>标签没有什么太大的差别了。好处在于所有的图标都在一个文件中，因此只会请求一次。
这种不需要像 Sprite 那样繁琐的设置图片的位移。使用 id 命名图标并使用时直接使用 id 引用既直观又简单。
其灵活性和 Inline SVG 几乎一样——你可以设置颜色、边线样式、大小等等。
视浏览器的不同，有时你需要使用作为 SVG 标签的开始。</p>
<figure class="highlight lang-svg"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">svg</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/2000/svg"</span>&gt;</span>
</pre></td></tr></table></figure>

<p>对于 IE 则需要使用<code>object</code>标签代替<code>&lt;svg&gt;&lt;use&gt;</code>。关于兼容性讨论详见
<a href="http://css-tricks.com/svg-sprites-use-better-icon-fonts/" target="_blank">这篇文章</a>。</p>
<p>除了前面提到过的几个 Gulp 和 Grunt 的插件都已经支持 SVG Defs/Symbols 了之外，这里再推荐一个更轻量的 Gulp 插件
<a href="https://github.com/Hiswe/gulp-svg-symbols" target="_blank">gulp-svg-symbols</a>。如果只使用 SVG Symbols 而无需 Sprite 支持，
那么使用 <a href="https://github.com/Hiswe/gulp-svg-symbols" target="_blank">gulp-svg-symbols</a> 可以免去对 <a href="http://phantomjs.org/" target="_blank">phantomjs</a>
的依赖。</p>
<h1>结语</h1>
<p>SVG Icons 作为一种 Icon Font 的替代，使用上具有灵活性好、显示效果好、可控性强等诸多优点。
尤其是最后介绍的 SVG Defs/Symbols 这种方式，已经让 SVG Icon 变成了一种实用的解决方案。</p>
<p>浏览器兼容性是前端领域永恒的话题，目前来看对 SVG 的支持情况确实没有 Web Font 那么好，
其中，主流移动浏览器 (Safari, Chrome, IE for Windows Phone) 都已经基本兼容 SVG，
但是桌面领域中仍然要面对 IE8 以下的浏览器，此外对 SVG Defs/Symbols 的支持也还存在差异。</p>
<p>现阶段，如果对浏览器兼容性要求比较严苛 (主要是支持 IE6-8)，则可以权衡考虑 Icon Font 和带 Fallback 的 SVG Sprite。
否则的话，推荐使用 SVG Defs/Symbols 的方式代替 Icon Font。</p>
<p>个人认为 SVG Icons 已经具备普及的条件了。</p>
]]></content>
    <summary type="html"><![CDATA[<p>如果你还在使用 Icon Font 作为网页中显示图标的实现方案，那么你可能有点 Out 了。
由于使用 Icon Font 显示图标存在一些缺陷，开发者们一直在致力于探索使用 SVG 作为替代的方法。
这篇文章列举了目前 SVG 比较常见的使用方法。</p>
]]></summary>
    
      <category term="svg" scheme="http://io-meter.com/tags/svg/"/>
    
      <category term="font" scheme="http://io-meter.com/tags/font/"/>
    
      <category term="web" scheme="http://io-meter.com/tags/web/"/>
    
      <category term="html" scheme="http://io-meter.com/tags/html/"/>
    
      <category term="design" scheme="http://io-meter.com/tags/design/"/>
    
      <category term="drawing" scheme="http://io-meter.com/tags/drawing/"/>
    
      <category term="web" scheme="http://io-meter.com/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己动手写 Git HTTP Server]]></title>
    <link href="http://io-meter.com/2014/07/09/simple-git-http-server/"/>
    <id>http://io-meter.com/2014/07/09/simple-git-http-server/</id>
    <published>2014-07-09T13:26:54.000Z</published>
    <updated>2014-07-11T04:16:41.000Z</updated>
    <content type="html"><![CDATA[<p>在 Github 上可以使用 HTTP 协议 fetch 和 push 仓库中的代码，
其实想要写一个简单的 Git HTTP Server 是相当容易的。
这篇文章总结了使用 Go 语言实现这样一个 Server 的过程和相关知识。</p>
<a id="more"></a>

<h1>基本原理</h1>
<p>先介绍一下 Git HTTP Server 的实现原理。本地的 Git 在使用 HTTP 协议访问远程的 Git 仓库时，
会分别发起如下三种类型的请求：</p>
<ol>
<li><code>GET /:working_path/*</code> 直接 Serve 远程仓库的静态文件到客户端，这里就是本地的仓库从上游获得数据的地方</li>
<li><code>GET /:working_path/info/refs</code> 用于访问远程仓库的 refs 数据，比如都有哪些 Branch 和 Tags 等等</li>
<li><code>POST /:working_path/git-&lt;command&gt;</code> 用于在远程仓库执行指令，进行数据交流。Git 的 push
和 fetch 都要依赖这个请求来完成</li>
</ol>
<p>在开始之前，我们首先定义一个 gitRoot 路径，所有的远程仓库在服务端都存放在这下面。譬如：</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> gitRoot = path.Join(os.TempDir(), <span class="string">"git_repo"</span>)
</pre></td></tr></table></figure>

<p>此外，为了方便路由，我选用了一个相当轻量级的 Go Web 库 <a href="http://goji.io/" target="_blank">Goji</a>。
用下面的命令安装这个依赖:</p>
<figure class="highlight lang-shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">go</span> get github.com/zenazn/goji
</pre></td></tr></table></figure>

<p>做完准备工作就要开始实现 Server 了。接下来由从最简单的第一类请求讲起：</p>
<h1>处理静态文件请求</h1>
<p>静态文件请求，也就是前面所说的第一类请求，Git 会直接通过这类请求来访问远程仓库的数据文件，
譬如<code>HEAD</code>、<code>refs</code>等。客户端的 Git 主要通过这种方式来获取一些 Git 自己产生的文件的详细内容，
一般来说并不会直接请求仓库里的代码等文件。类似<code>git clone</code>和<code>git fetch</code>这样的操作会交给第二类请求。</p>
<p>在 Go 中使用<code>http</code>库实现处理静态文件请求是非常方便的。我们定义一个名为<code>generic</code>的函数用来处理相关请求：</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">func</span> generic(c web.C, w http.ResponseWriter, r *http.Request) {
    reponame := c.URLParams[<span class="string">"reponame"</span>]
    repopath := path.Join(gitRoot, reponame)
    filepath := path.Join(gitRoot, r.URL.String())
    <span class="keyword">if</span> strings.HasPrefix(filepath, repopath) {
        http.ServeFile(w, r, filepath)
    } <span class="keyword">else</span> {
        w.WriteHeader<span class="number">(404</span>)
    }
}
</pre></td></tr></table></figure>

<p>这里使用了<code>filepath := path.Join(gitRoot, r.URL.String())</code>这行代码来计算远程仓库在文件系统上的真实位置，
这行代码也可以改写成任何其他策略产生的路径。只要这个路径指向的位置是一个通过<code>git init --bare</code>方式创建的仓库。
在<code>main</code>函数中用下列方法绑定路由并开启服务器。</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">func</span> main() {
    <span class="comment">// access file contents</span>
    goji.Get(<span class="string">"/:reponame/*"</span>, generic)
    goji.Head(<span class="string">"/:reponame/*"</span>, generic)

    <span class="comment">// start serving</span>
    goji.Serve()
}
</pre></td></tr></table></figure>

<p>这样，对于所有指向<code>/:reponame/</code>下任意路径的请求都会用<code>generic</code>函数处理，这里允许请求方法为<code>GET</code>和<code>HEAD</code>。
返回静态文件则使用<code>http</code>包中的<code>ServeFile</code>函数直接完成。</p>
<p>这样，第一类请求就可以被轻松处理了。</p>
<h1>info/refs</h1>
<p>接下来是稍微复杂一点的<code>info/refs</code>请求。本地的 Git 一般会在<code>git fetch</code>的时候进行这样的请求。
这个请求主要用来返回仓库的 References 数据，包括 Branch、Tags 等。跟上面讲过的第一类请求不同，
这个请求需要服务端将相关数据总结整理成特定的格式返回给客户端，从而节省请求次数。</p>
<p>根据用户操作类型的不同，Git 还会附加一个 URL 参数<code>service</code>。<code>service</code>一般的取值包括
<code>git-upload-pack</code>、<code>git-receive-pack</code>等。分别是客户端<code>fetch</code>和<code>push</code>时的状态。</p>
<p>我们并不需要了解这些请求的细节，只需要按照格式返回数据即可。那么该怎么返回正确的数据呢？
如果是对 Git 非常熟悉的同学可能会知道<code>upload-pack</code>和<code>receive-pack</code>本身就是 Git 可以使用的命令。
这两个命令都可以接受一个<code>--advertise-refs</code>参数。</p>
<p>根据 Git 的<a href="http://git-scm.com/book/en/Git-Internals-Transfer-Protocols" target="_blank">文档</a>
<code>--advertise-refs</code>可以使 Git 列出仓库所拥有的 References 以及那些客户端希望抓取到的 References。
而这些数据就被称为 Advertise Refs。</p>
<p>此外我们还可以使用<code>--stateless-rpc</code>参数。这个参数使强制 Git 使用无状态的
<a href="http://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank">RPC</a>。
简单来说，可以让 Git 返回的 References 列表中，代表每个 Reference 的字段长度恰好和一个数据包的长度相同，
这样每个 Reference 都可以被放在单独一个数据包上传输，不依赖于前面的数据包 (也就是实现了所谓的“无状态”)。
有些时候，在这里获得到了某个 Reference 还需要再去请求更详细的信息，这种方式下提高了并行性。</p>
<p>返回的数据的 MIME type 必须是 <code>application/x-&lt;command&gt;-advertisement</code>
其中<code>&lt;command&gt;</code>就是调用时用的命令。此外在<code>git receive-pack</code>和<code>git upload-pack</code>返回的数据的基础上，
我们还需要给数据添加一个头信息。其格式如下图所示:</p>
<p><img src="/img/posts/git-info-refs-head.png" alt=""></p>
<p>把以上这些写成函数就是下面这样。请重点注意其中有关<code>serverAdvert</code>的操作。
这里还使用了 Go 语言标准库中的<code>exec</code>包。</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="keyword">func</span> inforefs(c web.C, w http.ResponseWriter, r *http.Request) {
    reponame := c.URLParams[<span class="string">"reponame"</span>]
    repopath := path.Join(gitRoot, reponame)
    service := r.FormValue(<span class="string">"service"</span>)
    <span class="keyword">if</span> <span class="built_in">len</span>(service) &gt;<span class="number"> 0</span> {
        w.Header().Add(<span class="string">"Content-type"</span>, fmt.Sprintf(<span class="string">"application/x-%s-advertisement"</span>, service))
        gitLocalCmd := exec.Command(
            <span class="string">"git"</span>,
            <span class="typename">string</span>(service<span class="number">[4</span>:]),
            <span class="string">"--stateless-rpc"</span>,
            <span class="string">"--advertise-refs"</span>,
            repopath)
        out, err := gitLocalCmd.CombinedOutput()
        <span class="keyword">if</span> err != <span class="constant">nil</span> {
            w.WriteHeader<span class="number">(500</span>)
            fmt.Fprintln(w, <span class="string">"Internal Server Error"</span>)
            w.Write(out)
        } <span class="keyword">else</span> {
            serverAdvert := fmt.Sprintf(<span class="string">"# service=%s"</span>, service)
            length := <span class="built_in">len</span>(serverAdvert) +<span class="number"> 4</span>
            fmt.Fprintf(w, <span class="string">"%04x%s0000"</span>, length, serverAdvert)
            w.Write(out)
        }
    } <span class="keyword">else</span> {
        fmt.Fprintln(w, <span class="string">"Invalid request"</span>)
        w.WriteHeader<span class="number">(400</span>)
    }
}
</pre></td></tr></table></figure>

<h1>RPC 远程调用</h1>
<p>第三类请求是数据调用请求。简单来说就是由客户端 Git 指定命令在服务端对应仓库执行，
执行的过程中，客户端 Git 将命令需要的输入当做 HTTP 的 POST 数据发送到服务端，
服务端需要将这些输入转发给本地 Git 命令的标准输入流 (stdin)，反过来还要将命令的标准输出 (stdout)
当做 HTTP 请求的返回数据转发给客户端。</p>
<p>这个流程说起来很绕，但其实还蛮简单的。其通讯的模型可以用下图来表示：
<img src="/img/posts/git-server-rpc-model.png" alt=""></p>
<p>为了在 Go 中完成这样的转发，我们首先要设法从 Request 对象中读出 Body 的内容来。
为了节约传输大量数据时消耗的内存，把所有发送来的数据都读取出来再写入是不能接受的，
因此我们要以串流的方式来从 Body 中读取数据并同时写入 stdin。</p>
<p>为了获取所执行的命令的输入输出流，我们需要调用<code>exec.Command</code>类提供的<code>StdinPipe()</code>和<code>StdoutPipe()</code>方法。
串流转发的功能只需要方便地使用<code>io.Copy</code>方法即可。<code>io.Copy</code>方法默认将会以每次 32KB 的块大小读出数据然后写入到目标文件中。</p>
<p>众所周知，基本的 HTTP 是一种半双工的通讯协议，数据的发送和接收是不能交错进行的。所以我们也只能先把 HTTP 
请求的内容串流给 Git 命令的 stdin，完成后再从 stdout 里读取数据发送回客户端。</p>
<p>最后执行完<code>receive-pack</code>命令，还要执行<code>git update-server-info</code>命令来更新服务端仓库的信息。
Response 的 MIME 是<code>application/x-git-&lt;command&gt;-result</code>。</p>
<p>具体实现如下:</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">func</span> rpc(c web.C, w http.ResponseWriter, r *http.Request) {
    reponame := c.URLParams[<span class="string">"reponame"</span>]
    repopath := path.Join(gitRoot, reponame)
    command := c.URLParams[<span class="string">"command"</span>]
    <span class="keyword">if</span> <span class="built_in">len</span>(command) &gt;<span class="number"> 0</span> {

        w.Header().Add(<span class="string">"Content-type"</span>, fmt.Sprintf(<span class="string">"application/x-git-%s-result"</span>, command))
        w.WriteHeader<span class="number">(200</span>)

        gitCmd := exec.Command(<span class="string">"git"</span>, command, <span class="string">"--stateless-rpc"</span>, repopath)

        cmdIn, _ := gitCmd.StdinPipe()
        cmdOut, _ := gitCmd.StdoutPipe()
        body := r.Body

        gitCmd.Start()

        io.Copy(cmdIn, body)
        io.Copy(w, cmdOut)

        <span class="keyword">if</span> command == <span class="string">"receive-pack"</span> {
            updateCmd := exec.Command(<span class="string">"git"</span>, <span class="string">"--git-dir"</span>, repopath, <span class="string">"update-server-info"</span>)
            updateCmd.Start()
        }
    } <span class="keyword">else</span> {
        w.WriteHeader<span class="number">(400</span>)
        fmt.Fprintln(w, <span class="string">"Invalid Request"</span>)
    }
}
</pre></td></tr></table></figure>

<h1>路由的安排</h1>
<p>为了使路由按照正确的顺序匹配，应该要注意绑定请求时候的顺序。第一类请求虽然最简单，
但是他的匹配模式可以完全包含后两种，因此正确的顺序应该是：</p>
<ol>
<li>优先匹配 info/refs 请求</li>
<li>其次匹配 RPC 请求</li>
<li>以上两个都没有匹配，则匹配静态文件请求</li>
</ol>
<p>实现为:</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="comment">// get repo info/refs</span>
    goji.Get(<span class="string">"/:reponame/info/refs"</span>, inforefs)
    goji.Head(<span class="string">"/:reponame/info/refs"</span>, inforefs)

    <span class="comment">// RPC request on repo</span>
    goji.Post(regexp.MustCompile(<span class="string">"^/(?P&lt;reponame&gt;[^/]+)/git-(?P&lt;command&gt;[^/]+)$"</span>), rpc)

    <span class="comment">// access file contents</span>
    goji.Get(<span class="string">"/:reponame/*"</span>, generic)
    goji.Head(<span class="string">"/:reponame/*"</span>, generic)
</pre></td></tr></table></figure>

<p>值得注意的是，只有 RPC 请求因需要写入文件而允许使用 POST 方法，另外两种请求都是 GET 或 HEAD 方法。</p>
<h1>Security</h1>
<p>为了限制对仓库的访问，我们还可以使用 HTTP 的 <a href="http://en.wikipedia.org/wiki/Basic_access_authentication" target="_blank">Basic Auth</a>
协议对进行用户认证。</p>
<p>首先，对于未认证的请求，需要返回 Code 为 <code>401 Unauthorized</code> 的 HTTP Response，
并在 Response 的 Header 上加上如下格式的字段。</p>
<figure class="highlight lang-plain"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>WWW-Authenticate: Basic realm="[your realm]"
</pre></td></tr></table></figure>

<p>其中<code>realm</code>用来指定服务器的名称或者 UID，Git 会根据 realm 的值的不同，
使用本地缓存的不同用户名 / 密码组合。如果没有对应密码，Git 就会请求用户输入。</p>
<p>如果用户输入了密码，在 HTTP 请求的 Header 中将会出现下面格式的一个字段，其中<code>[username:password]</code>
的内容使用<code>base64</code>编码，需先解码：</p>
<figure class="highlight lang-plain"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Authenticate: Basic [username:password]
</pre></td></tr></table></figure>

<p>可以将上述 Authenticate 的逻辑通过 Goji 提供的 Middleware 机制实现，这样可以使对所有请求都会要求认证。
实现细节不再赘述，可以参见<a href="https://gist.github.com/shanzi/1aa571f8f3b8f4608d60#file-gittp-go-L173" target="_blank">我实现的版本</a>。</p>
<h1>总结</h1>
<p>为了方便使用，我还为 Server 添加了创建和删除远程仓库的代码，具体实现已经全部放在
<a href="https://gist.github.com/shanzi/1aa571f8f3b8f4608d60" target="_blank">Gist</a>上。当服务器开始运行之后，可以简单的使用 curl 
命令在服务器上创建空白仓库以及删除已有仓库。</p>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment"># create remote repo</span>
curl -u username:password -X PUT http://localhost:8000/new_repo
<span class="comment"># delete remote repo</span>
curl -u username:password -X DELETE http://localhost:8000/exists_repo
</pre></td></tr></table></figure>

<p>我们目前实现的版本得益于 Git 本身和 Go 语言的强大，总行数还不超过 250 行，
请<a href="https://gist.github.com/shanzi/1aa571f8f3b8f4608d60" target="_blank">查看完整代码</a>。</p>
<p>不过我们还没有考虑到 Git 对 GZip 的支持。尤其对于第一类对静态文件的请求，
支持 GZip 将能够显著提高传输效率。这个需求使用 Go 语言自带的<code>compass/gzip</code>包可以很方便的实现。</p>
<p>最后来看一下成果吧！</p>
<p><img src="/img/posts/git-simple-server-result.png" alt=""></p>
]]></content>
    <summary type="html"><![CDATA[<p>在 Github 上可以使用 HTTP 协议 fetch 和 push 仓库中的代码，
其实想要写一个简单的 Git HTTP Server 是相当容易的。
这篇文章总结了使用 Go 语言实现这样一个 Server 的过程和相关知识。</p>
]]></summary>
    
      <category term="Git" scheme="http://io-meter.com/tags/Git/"/>
    
      <category term="golang" scheme="http://io-meter.com/tags/golang/"/>
    
      <category term="go" scheme="http://io-meter.com/tags/go/"/>
    
      <category term="web" scheme="http://io-meter.com/tags/web/"/>
    
      <category term="server" scheme="http://io-meter.com/tags/server/"/>
    
      <category term="rpc" scheme="http://io-meter.com/tags/rpc/"/>
    
      <category term="web" scheme="http://io-meter.com/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分布式索引设计实验 in Go]]></title>
    <link href="http://io-meter.com/2014/06/22/distribute-indexing-experimentin-go/"/>
    <id>http://io-meter.com/2014/06/22/distribute-indexing-experimentin-go/</id>
    <published>2014-06-22T08:34:07.000Z</published>
    <updated>2014-06-23T13:31:03.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个 Go 语言门外汉，这段时间刚刚使用 Go 实现了一个分布式索引系统的仿真实验，
这篇文章就来总结一下实现过程和经验。</p>
<a id="more"></a>

<p>分布式储存的索引技术是分布式储存的一个技术重点，为了验证一种索引的设计，
自然要设计一个仿真测试来验证各项性能指标是否令人满意。</p>
<p>在实现系统之前，我对 Go 语言的认知水平还很初级，选择并不熟悉的 Go 语言作为实现语言的原因主要由以下几条：</p>
<ol>
<li>Go 语言有比较方便的包管理方案，譬如使用<code>go get</code>命令和第三方的 <a href="https://github.com/tools/godep" target="_blank">godep</a>
包来实现依赖管理非常方便。在实验中因为要使用第三方的 B+ Tree 实现，因此 Go
语言成为了一个很好的选择</li>
<li>Go 语言有出色的编译和执行速度。作为一种编译执行的语言，既能像脚本语言那样获得这么好的编译速度，
又可以获得较好的执行效率，这对于一个要填充较大数据量的仿真实验来说是一个相当吸引人的特性。</li>
<li>Go 语言的语法相对简洁又不失强大。虽然最初接触时，感觉 Go 语言的语法比较纠结。
但是相比起来要比 C++ 简洁很多，功能反过来又比 C 更为丰富。带有垃圾回收的特性使其最终脱颖而出。</li>
</ol>
<p>下面详细介绍系统的设计。</p>
<h2>Problem Description</h2>
<p>在介绍我设计的系统之前，先介绍一下问题以及对应的需求。同时，在这一步还会尽可能地将问题简化。</p>
<p>假定我们有一个由 $n$ 个储存节点组成的分布式储存系统，每个节点分别储存了总体数据的一部分。
随后有一段连续的查询请求，这些查询请求可能随机访问系统中的任何一个节点。
如果被请求的节点当中不包含这个数据，那么它要负责到对应的节点中去寻找数据并返回给客户端。</p>
<p>一个简单的双层索引的设计是：每个节点都有一个 Local Index 和一个 Global Index。
在接收到查询之后，先在 Local Index 当中查找，查找失败之后，再在 Global Index 中查找可能包含目标数据的节点。
此外我们还希望，如果一个查询多对应的目标数据在整个系统中都不存在，那么应该尽可能早的发现，
从而避免转发查询这个成本较高的操作。所以在双层索引中，我们希望在查找 Global Index 的时候，
就可以尽可能确定查询的目标数据是否存在。</p>
<p>一般用 False Positive 这个指标来衡量上述需求。所谓 False Positive，简单来说可以认为是一个系统中不存在的数据，
在 Global Index 当中查询的时候认为他是存在的。Global Index 最直接的设计就是把每个节点的 Local Index
原封不动地放在一起。这种方法可以保证没有 False Positive，但是却要占用较大的空间，
必须要进行一定的 Trade Off，使得在空间可以接受的范围内实现尽可能低的 False Positive 值。</p>
<p>此外还要求查询 Global Index 的查询成本要远少于 Local Index，
在这种情况下，我们可以把双层的索引模型改为总是先查找 Global Index，决定所在节点之后，再查找 Local Index。</p>
<p>为了简化问题，整个测试的系统中储存的数据看成是静态的。也就是说，实验的步骤是先将所有的测试数据插入系统，
再执行测试查询。测试过程中，也不考虑为数据建立冗余备份等问题。</p>
<h2>Model</h2>
<p>在我设计的系统中，使用的三个重要的模型和数据结构分别是：</p>
<ol>
<li>Fat Tree</li>
<li>B+ Tree</li>
<li>Bloom Filter</li>
</ol>
<p>下面分别介绍这几个模型及其作用。</p>
<h3>Fat Tree</h3>
<p><a href="http://en.wikipedia.org/wiki/Fat_tree" target="_blank">Fat Tree</a> 并不是什么储存数据的数据结构，而是一种常见的网络拓扑模型。
为了计算搜索请求从一个服务器转发到另一个服务器的时间消耗，就可以使用 Fat Tree 这种结构。</p>
<p>将 Fat Tree 称为树其实有点不准确，他其实更像是一种星型的网络。一个三层的 Fat Tree 结构包含核心层、
聚合层和边缘层三个层次，都有路由器构成。设 Fat Tree 中的每个路由有 $k$ 个端口，
我们把边缘层的每个路由的端口一半用来连接主机，一半用来链接聚合层。同时把
$\frac{k}{2}$ 个边缘层的路由与 $\frac{k}{2}$ 个聚合层的节点放在一起，构成一个完全二分图，称之为一个 Pod。
每个聚合层的路由和 $\frac{k}{2}$ 个核心层的节点链接，同一个 Pod 中不同的聚合层路由连接的核心层路由是不重复的。
显而易见，我们需要 $\frac{k^2}{4}$ 个核心层路由，可以连接的主机总数是 $\frac{k^3}{4}$ 。</p>
<p>由以上方式构造出的网络，有一个特点是每个路由的 $k$ 个端口都被利用了。整个网络中，任意两个主机之间通信，
经过的边数只有三种可能：</p>
<ol>
<li>同一个边缘层路由所连接的主机之间需经过 2 条边</li>
<li>同一个 Pod 不同边缘层路由所连接的主机之间需经过 4 条边</li>
<li>不同 Pod 中的主机之间需经过 6 条边</li>
</ol>
<p>一个 $k=4$ 的 Fat Tree 的例子如下图所示：</p>
<p><img src="/img/posts/fattree.png" alt="Fat Tree"></p>
<p>将主机从左到右编号，给定 $k$ 、通信发起节点 a 和目标节点 b，用 Go 编写的计算跳转次数的函数如下。
因在我们的系统中，b 要把查找结果返回给 a，因此所有的路由次数都乘了二。</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">func</span> TransferCost(k, a, b <span class="typename">int</span>) <span class="typename">int</span> {
    hk := k /<span class="number"> 2</span>
    <span class="keyword">switch</span> {
    <span class="keyword">case</span> a/hk == b/hk:
        <span class="keyword">return</span><span class="number"> 4</span>
    <span class="keyword">case</span> a/k == b/k:
        <span class="keyword">return</span><span class="number"> 8</span>
    <span class="keyword">default</span>:
        <span class="keyword">return</span><span class="number"> 12</span>
    }
}
</pre></td></tr></table></figure>

<h3>B+ Tree</h3>
<p>关于 <a href="http://en.wikipedia.org/wiki/B%2B_tree" target="_blank">B+ Tree</a> 的内容不用赘述了，它是一种常见的索引结构。
它用于储存 $n$ 个元素的空间复杂度是 $O(n)$，插入、查找和删除的时间复杂度都是 $O(\log_b n)$，
是一种非常有效率的索引方式。</p>
<p>前面说过，之所以选择 Go 语言来编写这个实验，一个重要的原因就在于 Go 方便的依赖管理机制，
你可以直接使用托管在 Github 等处的代码，只需要使用<code>go get</code>命令将代码抓取过来即可。
在这里，我使用了 <a href="https://github.com/cznic/b/" target="_blank">cznic/b</a> 这个第三方库。</p>
<figure class="highlight lang-shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">go</span> get github.com/cznic/b/
</pre></td></tr></table></figure>

<p>在本文中只使用了一个依赖关系，但是对于有多个依赖的项目，我们可能需要一个类似于 Python 的 pip 或者 ruby 的 gem
这样的工具。更近一步，为了隔离不同项目的环境，一个类似 ruby bundle 的工具将会极大地提高生产力。
<a href="https://github.com/pote/gpm" target="_blank">gpm</a> 和 <a href="https://github.com/pote/gvp" target="_blank">gvp</a> 搭档使用是一个比较好的解决方案。</p>
<p>我使用 B+ Tree 作为实验中每个节点的 Local Index，为了计算查询 B+ Tree 的计算成本，
可以充分利用 Go 语言提供的函数式编程的能力，使用闭包获得上下文环境来统计比较次数。
<code>cznic/b</code>这个 B+ Tree 实现允许传入一个函数作为比较 Key 大小的函数。我使用了下面的结构体定义一个 Node 。</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">type</span> Node <span class="keyword">struct</span> {
    id          <span class="typename">int</span>
    bloomSize   <span class="typename">int</span>
    hashCount   <span class="typename">int</span>
    cmpCount    <span class="typename">int</span> <span class="comment">// a field to count comparing on this node</span>
    bplusTree   *b.Tree
    bloomFilter []<span class="typename">uint64</span>
    itemCount   <span class="typename">int</span>
}
</pre></td></tr></table></figure>

<p>用下面的方法来初始化一个 Node 及其 B+ Tree。</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>n := <span class="built_in">new</span>(Node)
n.bplusTree = b.TreeNew(<span class="keyword">func</span>(a, b <span class="keyword">interface</span>{}) <span class="typename">int</span> {
        na := a.(<span class="typename">uint64</span>)
        nb := b.(<span class="typename">uint64</span>)
        n.cmpCount++ <span class="comment">// count comparing</span>
        <span class="keyword">switch</span> {
        <span class="keyword">case</span> na &gt; nb:
            <span class="keyword">return</span><span class="number"> 1</span>
        <span class="keyword">case</span> na == nb:
            <span class="keyword">return</span><span class="number"> 0</span>
        <span class="keyword">default</span>:
            <span class="keyword">return</span><span class="number"> -1</span>
        }
    })
</pre></td></tr></table></figure>

<p>得益于 Go 支持匿名函数以及闭包，我们能够比较优雅的实现这个功能。</p>
<h3>Bloom Filter</h3>
<p>在 Global Index 这里，我选择了一个非常简单的解决方案：<a href="http://en.wikipedia.org/wiki/Bloom_filter" target="_blank">Bloom Filter</a>。
简单来说， Bloom Filter 就是在插入数据时使用 $k$ 个不同的哈希函数，把一个 Key 映射到一个整型数组上的不同的位置，
并将对应的位置标记为 1。在查询的时候，对请求的键使用相同的哈希函数进行哈希，检查对应的 $k$ 个位置是否都为 1。
如果是的话，键对应的就值很可能存在，否则一定不存在。</p>
<p>为了节省空间，我们以单个二进制位为单位进行标记，设数组中的所有<code>Int</code>元素共有 $m$ 个比特位，储存的数据共有 $n$ 个，
那么理论上对 Bloom Filter 查询的 False Positive 概率的估计公式为：</p>
<p>$$\left(1-e^{-kn/m} \right)^k$$</p>
<p>从上面的公式可以看出，Bloom Filter 虽然有实现简单、占用空间小的优点，但是储存的数据量越大，False Positive 的概率越高，
过滤的效果也越差。同时，Bloom Filter 对于删除元素的操作没有很方便的处理方法，
在删除时维护 Bloom Filter 的复杂度比较高。</p>
<p>在不考虑删除元素的情况下， Bloom Filter 还是很好的一个选择。
而且 Go 语言的标准库中，已经提供了 MD5、SHA1、ADLER32 以及 CRC64 等哈希算法的实现，只需 import 进来即可使用，
非常方便：</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">import</span> (
    <span class="string">"crypto/md5"</span>
    <span class="string">"crypto/sha1"</span>
    <span class="string">"hash/adler32"</span>
    <span class="string">"hash/crc64"</span>
)
</pre></td></tr></table></figure>

<h2>测试数据的生成及文件读取</h2>
<p>为了测试我们设计的系统的性能，需要生成一些特定分布的测试数据以及对应的查询数据。
两种比较常用的分布是均匀分布和 <a href="http://en.wikipedia.org/wiki/Zipf_distribution" target="_blank">Zipf</a> 分布。
特别值得一提的是 Zipf 分布，包括英语中单词的出现频率在内，很多重要的数据都服从这一分布。
因此在搜索引擎使用的关键词索引系统中就应该特别重视这种分布。</p>
<p>为了简化问题，这里采取了事先生成一批两种分布的测试数据，在测试的时候依次读出并插入索引的方案。
测试数据都是整型数字，并且作为键插入到 B+ Tree 中。使用 Python 中的 numpy 库生成特定分布的随机数据的方法如下：</p>
<figure class="highlight lang-python"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">import</span> numpy <span class="keyword">as</span> np

np.random.normal(<span class="number">0</span>, <span class="number">1280000</span>, <span class="number">100000</span>).astype(int) <span class="comment"># 生成 100000 个 0~1280000 之内的均匀分布随机数</span>
np.random.zipf(<span class="number">2</span>, <span class="number">100000</span>) <span class="comment"># 生成参数 a=2 的 100000 个 Zipf 分布的随机数</span>
</pre></td></tr></table></figure>

<p>将生成的数据保存成文本文件，接下来只要在 Go 程序里读取出来就好了。作为一个 Python 重度用户，
在这里我很想使用类似 Generator 那样的语法，让函数每次输出一个文件中的数字。 Go 语言虽然没有<code>yield</code>那样的语法，
但是可以通过 channel 和 goroutine 来实现相近的功能。写出来是像下面这样：</p>
<figure class="highlight lang-go"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">func</span> iterFile(filepath <span class="typename">string</span>) <span class="keyword">chan</span> <span class="typename">uint64</span> {
    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">uint64</span>)
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        fi, err := os.Open(filepath)
        <span class="keyword">if</span> err != <span class="constant">nil</span> {
            <span class="built_in">panic</span>(err)
        }
        <span class="keyword">defer</span> fi.Close()
        <span class="keyword">var</span> i <span class="typename">uint64</span>
        <span class="keyword">for</span> {
            _, err := fmt.Fscanf(fi, <span class="string">"%d"</span>, &i)
            <span class="keyword">if</span> err != <span class="constant">nil</span> {
                <span class="keyword">if</span> err == io.EOF {
                    <span class="keyword">break</span>
                }
                <span class="built_in">panic</span>(err)
            }
            ch &lt;- i
        }
        <span class="built_in">close</span>(ch)
    }()
    <span class="keyword">return</span> ch
}
</pre></td></tr></table></figure>

<p>值得注意的是<code>defer fi.Close()</code>这行，<code>defer</code>关键字生成的指令会在当前 goroutine
结束的时候执行，避免忘记释放文件的问题，是一个很优雅的语法。
更方便是，我们还可以可以使用<code>for</code>循环来不断从 channel 中取数值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">for</span> i := range iterFile(<span class="string">"somefile.txt"</span>) {
    // do somthing <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<p>在研究 channel 的时候，我发现尽管在函数中可以同时返回多个值，但 Go 语言中并没有元组这样的类型。
所以也就不能建立一次传输多个值的 channel （除非使用<code>interface{}</code>），这也算关于 Go 语言的一个小细节吧。</p>
<h2>进行仿真实验</h2>
<p>为了均衡各个服务器储存的数据量，可以先对要插入的键进行哈希处理，
再根据哈希过的值决定存放在哪个节点。这样可以很好地将 Zipf 这样密度分布不平衡的数据均匀的分散开。
接下来就可以进行仿真实验了。</p>
<p>对均匀分布和 Zipf 分布的数据进行 100000 次查询的仿真结果如下：</p>
<figure class="highlight lang-plain"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>* Testing Uniform Distribution Sparse Set

Inserting Keys ...
Keys Inserted:               235195

Testing Point Search ...
Average Comparing:           2.18
Average OK Comparing:        10.02
Average Fail Comparing:      10.90
Average Transfer Cost:       2.50
False Positive Proportion:   3.92%

* Testing Zipf Distribution Sparse Set

Inserting Keys ...
Keys Inserted:               230581

Testing Point Search ...
Average Comparing:           8.06
Average OK Comparing:        9.58
Average Fail Comparing:      10.92
Average Transfer Cost:       9.78
False Positive Proportion:   3.42%
</pre></td></tr></table></figure>

<h2>总结</h2>
<p>这篇文章总结了我最近实现的一个简单的分布式索引仿真测试的程序。
当前的系统设计其实过于简单了，譬如没有考虑到数据的冗余备份等问题。但是总体来看对于两种分布，
系统的表现还是令人满意的。 </p>
<p>在实现程序的过程中，我对 Go 语言的一些方面有了更多的了解。
在我看来， Go 语言是一种很有前景的语言，也许在一些场合下仍然无法取代 C，但是相比起来 C++ 似乎不再有竞争力。
当然，Go 现在还缺乏一些 GUI 库、科学计算库等等，不过我相信随着时间的流逝它会展现出越来越强的生命力。</p>
]]></content>
    <summary type="html"><![CDATA[<p>作为一个 Go 语言门外汉，这段时间刚刚使用 Go 实现了一个分布式索引系统的仿真实验，
这篇文章就来总结一下实现过程和经验。</p>
]]></summary>
    
      <category term="Go" scheme="http://io-meter.com/tags/Go/"/>
    
      <category term="distribute storage" scheme="http://io-meter.com/tags/distribute%20storage/"/>
    
      <category term="indexing" scheme="http://io-meter.com/tags/indexing/"/>
    
      <category term="essay" scheme="http://io-meter.com/categories/essay/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift の 函数式编程]]></title>
    <link href="http://io-meter.com/2014/06/04/swift's-functional-programing/"/>
    <id>http://io-meter.com/2014/06/04/swift's-functional-programing/</id>
    <published>2014-06-04T14:59:16.000Z</published>
    <updated>2014-06-13T13:54:00.000Z</updated>
    <content type="html"><![CDATA[<p>Swift 相比原先的 Objective-C 最重要的优点之一，就是对函数式编程提供了更好的支持。
Swift 提供了更多的语法糖和一些新特性来增强函数式编程的能力，本文就在这方面进行一些讨论。</p>
<a id="more"></a>

<h2>Swift 概览</h2>
<p>对编程语言有了一些经验的程序员，尤其是那些对多种不同类型的编程语言都有经验的开发者，
在学习新的语言的时候更加得心应手。原因在于编程语言本身也是有各种范式的，
把握住这些特点就可以比较容易的上手了。</p>
<p>在入手一门新的语言的时候，一般关注的内容有：</p>
<ol>
<li>原生数据结构</li>
<li>运算符</li>
<li>分支控制</li>
<li>如果是面向对象的编程语言，其面向对象的实现是怎样的</li>
<li>如果是函数式编程语言，其面向函数式编程的实现是怎样的</li>
</ol>
<p>通过这几个点，其实只要阅读 Swift 文档的第一章，你就可以对这个语言有一个大概的印象。
比如对于数据结构，Swift 和其他的编程语言大体一样，有 Int, Float, Array, Dictionary 等，
运算符也基本与 C 语言一致等。
本文主要集中于对 Swift 函数式编程方面的特点进行一些盘点，因此在这里假设大家对 Swift 的基本语法已经有所了解。</p>
<p>对于一种编程范式，要掌握它也要抓住一些要点。对于支持函数式编程的语言，其一般的特点可能包含以下几种：</p>
<ol>
<li>支持递归</li>
<li>函数本身是语言 First Class 的组成要素，且支持高阶函数和闭包</li>
<li>函数调用尽可能没有副作用
(<a href="http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" target="_blank">Side Effect</a>) 的条件</li>
</ol>
<p>接下来我们来逐个盘点这些内容。</p>
<h1>递归</h1>
<p>Swift 是支持递归的，事实上现在不支持递归的编程语言已经很难找到了。在 
Swift 里写一个递归调用和其他编程语言并没有什么区别：</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="title">func</span> fib(n: Int) -&gt; Int {
  <span class="title">if</span> n &lt;= <span class="number">1</span> {
    <span class="title">return</span> <span class="number">1</span>
  }
  else {
    <span class="title">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)
  }
}
fib(<span class="number">6</span>) // output <span class="number">13</span>
</pre></td></tr></table></figure>

<p>关于 Swift 的递归没有什么好说的。作为一个常识，我们知道递归是需要消耗栈空间的。
在函数式编程语言中，递归是一个非常常用的方法，然而使用不慎很容易导致栈溢出的问题。
如果将代码改写为非递归实现，又可能会导致代码的可读性变差，因此有一个技巧是使用“尾递归”，
然后让编译器来优化代码。</p>
<p>一个 Common Lisp 的尾递归的例子是</p>
<figure class="highlight lang-lisp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="list">(<span class="title">defun</span><span class="body"> fib<span class="list">(<span class="title">n</span><span class="body">)</span></span>
    <span class="list">(<span class="title">fib-iter</span><span class="body"> <span class="number">1</span> <span class="number">0</span> n)</span></span>)</span></span>

<span class="list">(<span class="title">defun</span><span class="body"> fib-iter<span class="list">(<span class="title">a</span><span class="body"> b count)</span></span>
    <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> count <span class="number">0</span>)</span></span>
        b
        <span class="list">(<span class="title">fib-iter</span><span class="body"> <span class="list">(<span class="title">+</span><span class="body"> a b)</span></span> a <span class="list">(<span class="title">-</span><span class="body"> count <span class="number">1</span>)</span></span>)</span></span>)</span></span>)</span></span>
</pre></td></tr></table></figure>

<p>我们可以把我们上述的 Swift 代码也改写成相同形式</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="title">func</span> fibiter(a: Int, b: Int, count: Int) -&gt; Int {
  <span class="title">if</span> count==<span class="number">0</span> {
    <span class="title">return</span> b
  }
  else {
    <span class="title">return</span> fibiter(a + b, a, count-<span class="number">1</span>)
  }
}

func fib(n: Int) -&gt; Int {
  <span class="title">return</span> fibiter(<span class="number">1</span>, <span class="number">1</span>, n);
}
</pre></td></tr></table></figure>

<p>我们可以 Playground 里观察是否使用尾递归时的迭代结果变化。</p>
<p><img src="/img/posts/recurrence-fib.png" alt=""></p>
<p>值得注意的是，这里出现了一个 Swift 的问题。虽然 Swift 支持嵌套函数，但是当我们将<code>fibiter</code>
作为一个高阶函数包含在<code>fib</code>函数之内的时候却发生了 EXC_BAD_ACCESS 报错，
并不清楚这是语言限制还是 Bug。</p>
<h2>Swift 的高阶函数和闭包</h2>
<p>在 Objective-C 时代，使用 block 来实现高阶函数或者闭包已经是非常成熟的技术了。
Swift 相比 Objective-C 的提高在于为函数式编程添加了诸多语法上的方便。</p>
<p>首先是高阶函数的支持，可以在函数内定义函数，下面就是一个很简洁的例子。</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>func greetingGenerator(<span class="keyword">object</span>:String) -&gt; (greeting:String) -&gt; String {
  func sayGreeting(greeting:String) -&gt; String {
    <span class="keyword">return</span> greeting + <span class="string">", "</span> + <span class="keyword">object</span>
  }
  <span class="keyword">return</span> sayGreeting
}

<span class="keyword">let</span> sayToWorld = greetingGenerator(<span class="string">"world"</span>)
sayToWorld(greeting: <span class="string">"Hello"</span>) <span class="comment">// "Hello, World"</span>
sayToWorld(greeting: <span class="string">" 你好 "</span>) <span class="comment">// " 你好, World"</span>
</pre></td></tr></table></figure>

<p>如果使用 block 实现上述功能，可读性就不会有这么好。而且 block 的语法本身也比较怪异，
之前没少被人吐槽。Swift 从这个角度来看比较方便。事实上，在 Swift 里可以将函数当做对象赋值，
这和很多函数式编程语言是一样的。</p>
<p>作为一盘大杂烩，Swift 的函数系统也很有 JavaScript 的影子在里面。比如可以向下面这样定义函数：</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">let</span> add = {
  (a:Int, b:Int) -&gt; Int <span class="keyword">in</span>
  <span class="keyword">return</span> a+b
}

add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span>
</pre></td></tr></table></figure>

<p>等号之后被赋予变量<code>add</code>的是一个闭包表达式，因此更准确的说，
这是将一个闭包赋值给常量了。注意在闭包表达式中，<code>in</code>关键字之前是闭包的形式定义，之后是具体代码实现。
Swift 中的闭包跟匿名函数没有什么区别。
如果你将它赋值给对象，就跟 JavaScript 中相同的实践是一样的了。幸好 Swift 作为 C 系列的语言，
其分支语句 if 等本身是有作用域的，因此不会出现下列 JavaScript 的坑：</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">if</span> (someNum&gt;<span class="number">0</span>) {
  <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span>{</span> alert(<span class="string">"one"</span>) };
}
<span class="keyword">else</span> {
  <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span>{</span> alert(<span class="string">"two"</span>) };
}

a() <span class="comment">// will always alert "two" in most of browsers</span>
</pre></td></tr></table></figure>

<p>Swift 的闭包表达式和函数都可以作为函数的参数，从下面的代码我们可以看出闭包和函数的一致性：</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="title">func</span> function() {
  println(<span class="string">"this is a function"</span>)
}

<span class="title">let</span> closure = {
  () -&gt; () <span class="keyword">in</span>
  println(<span class="string">"this is a closure"</span>)
}

<span class="title">func</span> run(somethingCanRun:()-&gt; ()) {
  somethingCanRun()
}

<span class="title">run</span>(function)
<span class="title">run</span>(closure)
</pre></td></tr></table></figure>

<p>类似于 Ruby，Swift 作为函数参数的闭包做了一点语法糖。
在 Ruby 中使用 Block 的时候，我们可以这样写:</p>
<figure class="highlight lang-ruby"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>(<span class="number">1</span>...<span class="number">5</span>).map {|x| x*<span class="number">2</span>} /<span class="regexp">/ =&gt; [2, 4, 6, 8]
</pre></td></tr></table></figure>

<p>在 Swift 当中我们可以得到几乎一样的表达式。</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="title">var</span> a = Array(<span class="number">1</span>..<span class="number">5</span>).map {<span class="title">x</span> in x*<span class="number">2</span>}
// a = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]
</pre></td></tr></table></figure>

<p>也就是说， 如果一个函数的最后一个参数是闭包，那么它在语法上可以放在函数调用的外面。
闭包还可以用<code>$0</code>、<code>$1</code>等分别来表示第 0、第 1 个参数等。 基本的运算符也可以看做函数。
下面的几种方式都可以实现逆序倒排的功能。</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>let thingsToSort = Array(<span class="number">1.</span><span class="number">.5</span>)
var reversed1 = <span class="keyword">sort</span>(thingsToSort) { a, b <span class="keyword">in</span> a&lt;b}
var reversed2 = <span class="keyword">sort</span>(thingsToSort) { <span class="variable">$0</span> &lt; <span class="variable">$1</span>}
var reversed3 = <span class="keyword">sort</span>(thingsToSort, &lt;) <span class="comment">// operator as a function</span>
<span class="comment">// all the above are [5, 4, 3, 2, 1]</span>
</pre></td></tr></table></figure>

<p>总体来说，Swift 在添加方便函数操作、添加相关语法糖方面走的很远，基本上整合了目前各种语言中比较方便的特性。
实用性较好。</p>
<h2>Side Effects</h2>
<p>在计算机科学中，函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量
(函数外的变量) 或修改参数 (<a href="http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" target="_blank">wiki</a>)。
函数副作用会给程序带来一些不必要的麻烦。</p>
<p>为了减少函数副作用，很多函数式编程语言都力求达到所谓的“纯函数”。
纯函数是指函数与外界交换数据的唯一渠道是参数和返回值， 而不会受到函数的外部变量的干扰。
乍看起来这似乎跟闭包的概念相抵触，因为闭包本身的一个重要特点就是可以访问到函数定义时的上下文环境。</p>
<p>事实上，为了在这种情况下支持纯函数，一些编程语言如 Clojure 等提供的数据结构都是不可变 (或者说 Persist) 的。
因此其实也就没有我们传统意义上的所认为的“变量”的概念。比如说，在 Python 中，字符串<code>str</code>就是一类不可变的数据结构。
你不能在原来的字符串上进行修改，每次想要进行类似的操作，其实都是生成了一个新的<code>str</code>对象。
然而 Python 中的链表结构则是可变的。且看下面的代码，在 Python 中对<code>a</code>字符串进行修改并不会影响<code>b</code>，
但是同样的操作作用于链表就会产生不一样的结果：</p>
<figure class="highlight lang-python"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>a = <span class="string">"hello, "</span>
b = a
a += <span class="string">"world"</span>
<span class="keyword">print</span> a <span class="comment"># hello, world</span>
<span class="keyword">print</span> b <span class="comment"># hello,</span>
</pre></td></tr></table></figure>

<p>Swift 的数据结构的 Persist 性质跟 Python 有点类似。需要注意的是，Swift 有变量和常量两种概念，
变量使用<code>var</code>声明，常量使用<code>let</code>声明，使用<code>var</code>声明的时候，Swift 中的字符串的行为跟 Python 相似，
因此修改字符串可以被理解为生成了一个新的字符串并修改了指针。同样，
使用<code>var</code>声明的数组和字典也都是可变的。</p>
<p>在 Swift 中使用<code>let</code>声明的对象不能被赋值，基本数据结果也会变得不可变，但是情况更复杂一点。</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function_or_atom">let</span> <span class="function_or_atom">aDict</span> = [<span class="string">"k1"</span>:<span class="string">"v1"</span>]
<span class="function_or_atom">let</span> <span class="function_or_atom">anArray</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]

<span class="function_or_atom">aDict</span>[<span class="string">"k1"</span>] = <span class="string">"newVal"</span> // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span> <span class="function_or_atom">will</span> <span class="function_or_atom">fail</span> <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
<span class="function_or_atom">anArray</span>.<span class="function_or_atom">append</span>(<span class="number">5</span>) // <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span> <span class="function_or_atom">will</span> <span class="function_or_atom">fail</span> <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>
<span class="function_or_atom">anArray</span>[<span class="number">0</span>] = <span class="number">5</span> // <span class="function_or_atom">anArray</span> = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="function_or_atom">now</span> <span class="exclamation_mark">!</span>
</pre></td></tr></table></figure>

<p>从上面的代码中可以看出，使用<code>let</code>声明的字典是完全不可变的，但是数组虽然不可以改变长度，
却可以改变数组元素的值！Swift 的文档中指出这里其实是将 Array 理解为定长数组从而方便编译优化，
来获得更好的访问性能。</p>
<p>综上所述，对象是否可变的关系其实略有复杂的，可以总结为：</p>
<ol>
<li>使用<code>var</code>和<code>let</code>，<code>Int</code>和<code>String</code>类型都是不可变的，但是<code>var</code>时可以对变量重新赋值</li>
<li>使用<code>let</code>声明的常量不可以被重新赋值</li>
<li>使用<code>let</code>声明的<code>Dictionary</code>是完全不可变的</li>
<li>使用<code>let</code>声明的<code>Array</code>长度不可变，但是可以修改元素的值</li>
<li>使用<code>let</code>声明的类对象是可变的</li>
</ol>
<p>综上所述，即使是使用<code>let</code>声明的对象也有可能可变，因此在多线程情况下就无法达到“无副作用”的要求了。</p>
<p>此外 Swift 的函数虽然没有指针，但是仍通过参数来修改变量的。只要在函数的参数定义中加入<code>inout</code>关键字即可。
这个特性很有 C 的风格。</p>
<p>个人觉得在支持通过元组来实现多返回值的情况下，这个特性不但显得鸡肋，也是一个导致程序产生“副作用”的特性。
Swift 支持这样的特性，恐怕更多的是为了兼容 Objective-C 以及方便在两个语言之间搭建 Bridge。</p>
<figure class="highlight lang-none"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="title">func</span> inc(inout a:Int) {
  <span class="title">a</span> += <span class="number">1</span>
}
var num = <span class="number">1</span>
inc(&num) // num = <span class="number">2</span> now!
</pre></td></tr></table></figure>

<p>综上所述，使用 Swift 自带的数据结构并不能很好的实现“无副作用”的“纯函数式”编程，
它并没有比 Python、Ruby 这类语言走的更远。幸好作为一种关注度很高的语言，
已经有开发者为其实现了一套完全满足不可变要求的数据结构和库：<a href="https://github.com/maxpow4h/swiftz" target="_blank">Swiftz</a>。
坚持使用<code>let</code>和 Swiftz 提供的数据结构来操作，就可以实现“纯函数式”编程。</p>
<h2>总结</h2>
<p>在我看来，Swift 虽然实现了很多其他语言的亮点特性，但是总体实现来说并不是很整齐。
它在函数式编程方面添加了很多特性，但在控制副作用方面仅能达到平均水准。
有些特性看起来像是为了兼容原来的 Objective-C 才加入的。</p>
<p>Swift 写起来相对比 Objective-C 更方便一点，脱离 Xcode 这样的 IDE 来写也是应该是可以的。
目前 Swift 只支持集中少量的原生数据结构而没有标准库，更不具备跨平台特性，这是一个缺点。
在仔细阅读了文档之后发现 Swift 本身的语法细节还是很多的，就比如<code>switch</code>分置语句的用法就有很多内容。
入门学习的容易程度并没有原来想象的那么好。我个人并不觉得这门语言会对其他平台的开发者有很大吸引力。</p>
<p>Swift 是一门很强大的语言，在其稳定版本发布之后我认为我会从 Objective-C 专向 Swift 来进行编程，
它在未来很可能成为 iOS 和 Mac 开发的首选。</p>
]]></content>
    <summary type="html"><![CDATA[<p>Swift 相比原先的 Objective-C 最重要的优点之一，就是对函数式编程提供了更好的支持。
Swift 提供了更多的语法糖和一些新特性来增强函数式编程的能力，本文就在这方面进行一些讨论。</p>
]]></summary>
    
      <category term="Functional Programing" scheme="http://io-meter.com/tags/Functional%20Programing/"/>
    
      <category term="Swift" scheme="http://io-meter.com/tags/Swift/"/>
    
      <category term="Apple" scheme="http://io-meter.com/tags/Apple/"/>
    
      <category term="essay" scheme="http://io-meter.com/categories/essay/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开源、技术信仰及其他]]></title>
    <link href="http://io-meter.com/2014/05/24/opensource-tech-belief-and-something-others/"/>
    <id>http://io-meter.com/2014/05/24/opensource-tech-belief-and-something-others/</id>
    <published>2014-05-24T12:09:13.000Z</published>
    <updated>2014-05-24T16:52:27.000Z</updated>
    <content type="html"><![CDATA[<p>这是一篇吐槽为主的文章，主要针对的是最近的一个时期比较热点的话题，
包括<a href="http://blog.jobbole.com/67744/" target="_blank">开源产品成本更高论</a>、
<a href="http://zh.wikipedia.org/zh-cn/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E" target="_blank">HeartBleed</a>、
<a href="http://blog.jobbole.com/67818/" target="_blank">技术信仰是如何毁掉程序员的</a>、RMS 的中国之行、
学生开源组织的建设等等话题。总体来说内容比较有争议，请慎入。</p>
<a id="more"></a>

<h2>开源产品的成本更高？</h2>
<p><a href="http://blog.jobbole.com/67744/" target="_blank">开源产品成本高之论</a>不是什么新鲜货，它几乎每隔一段时间都会被翻出来炒。
这次是来自英国政府首席信息官的说法。其主要观点就是：开源产品虽然是免费的，但是使用它的隐性成本高。
我们有充分的理由相信英国政府是做过仔细的核算的，对于他们来说，迁移和员工培训的确是一笔可观的额外开销。</p>
<p>其实，在我看来，这份报道的并没有歪曲事实——他只是掩盖了部分事实 (这是新闻媒体多么喜欢干的事情啊)，
实际上世界上大多规模模比较大的 IT 企业，好几百万台服务器，不都在使用开源技术么？几乎所有的互联网创业企业，
开源技术不都是他们的首选么？对于那种大型的 IT
相关企业。使用竞争对手微软的产品可能会有受制于人的危险，转化为隐性成本就会非常高，
这同样是一种成本分析，结果却不一样。</p>
<p>开源技术的成本高并不是在所有场合都成立，这就是持有类似成本论的人想要掩盖的地方，目的无非是
使不明真相的读者将开源技术视为某种昂贵又不实用的东西。</p>
<p>那么对于个人来说，开源产品的成本怎么样呢？在这个问题上我不得不承认的是: 就目前的开源产品而言，
每个人的平均使用成本是要高于商业产品的，尤其是对于普通的电脑使用者来说更是如此。</p>
<p>也正因为这样，目前在桌面领域 Linux 占有率不高是一个很正常的现象，没有什么多余的借口可讲。
我能理解很多开源爱好者喜欢归咎于微软，认为微软存在垄断等等行为。
但是把自己不成功的原因推卸到别人身上，真的是一种逃避的心理。</p>
<p>同之前所说的一样，也不是每个人的开源产品使用的成本也不是一样的。
如果你是一个有追求的计算机技术人员，那么至少应该对此有所了解。否则可能要在其他地方承受很大的隐性成本。
比如大多知名技术企业都对 Linux 技能有所要求，如果相关知识缺乏，可能会减少自己求职范围的宽度。</p>
<h2>HeartBleed</h2>
<p>HeartBleed 可以算是这小半年来开源界最大的新闻了。其产生的动荡不但使普通人也能感受到开源技术产生的影响，
也在一定程度上打击了大家对开源技术的信心。</p>
<p>是的，尽管自由软件基金会在其后发表了文章试图减弱 HeartBleed 带来的信任危机，但是仍然不可能完全消除影响。
HeartBleed 事件告诉大家了一个事实，那就是开源技术“有更多的眼睛在看，因此导致代码更安全更稳定”这一优势，
并不一定总是可靠的。这对人们对开源技术的信心必然会产生影响。</p>
<p>这真是一件大好事！为什么这么说？我们来好好思考一下为什么 OpenSSL 的一个漏洞这么长时间都没有被发现，
为什么对于一个那么流行的开源软件，前面所讲的“开源的优势”并没有生效？
归根结底是因为人们对开源技术太信任了！对 OpenSSL 太信任了！</p>
<p>当一个系统管理员选择 OpenSSL 时，他会想：有这么多大企业在用，其中不乏 Google 这样的大企业，
那么一定是一个很安全的软件；同样，全世界一半的网络都在用，有 Bug 很快就能发现，因此应该是一个很稳定的软件。
可惜 Google 这样的大企业的管理员也许也是这么想的，大家都以为其他人会 Review 这些代码，
都以为有了 Bug 其他人肯定会修，结果到最后越来越少人真的会检查代码。
这一切难道不是因为技术人员对这些开源技术太过信任了么？</p>
<p>经过这次事件的洗礼，人们对开源技术没有那么信任了，也许使用开源软件的人会少一些，
但是剩下一些坚持使用的人或者企业，就不会对自己所用的东西那么信任，也就会多一些人来检查代码，
发现 Bug，修复 Bug，使得开源软件更安全。因此至少在一段时间内“开源的优势”又可以有效。</p>
<p>当然，除了这条“更多眼睛在看”的优势，对于有能力的人，我们还有“有 Bug 可以自己修”这条优势。
这对于大企业尤其是非常重要的。</p>
<h2>关于技术信仰</h2>
<p><a href="http://blog.jobbole.com/67818/" target="_blank">《技术信仰是如何毁掉程序员的》</a> 这篇文章之前产生了很大的影响，
此外还出现了很多评论这篇文章的相关文章。这篇文章里面已经谈得很好了，但是我还是想要在这里强调一下。
因为纵使有写的这么好的文章在，还是有些人不遗余力的引发关于技术信仰的争论。</p>
<p>现在这些争论表面上都显得很无辜，比如在某曾经质量很高的程序员社区几乎每天都可以看到类似<a href="http://v2ex.com/t/114033" target="_blank">这篇</a>
和<a href="http://www.v2ex.com/t/113887" target="_blank">这篇</a>的文章。发帖人自己显得特无辜，好像是来请教，但是其实就是来找喷的，
喷的人多了有成就感，尤其还有积分赚的时候。正是大量这样的文章导致了某社区变成了“曾经”质量很高，不得不让人扼腕。</p>
<p>此外，对于《技术信仰》这篇文章，我还想有一点补充的地方。我完全赞同文中认为执拗于某一门技术会导致一叶障目的论述，
赞同程序员应该广泛涉猎技术爱好。但是我不认为有“技术信仰”是有害的。
人都是有性格的，其实技术也有性格，程序员选择一门技术作为信仰，就像是在谈恋爱，有相同性格的人在一起会更融洽，
人和技术也是如此。一个没有性格的老好人是不招人喜欢的，在技术信仰这个概念上也是一样。人总是要有所坚持。</p>
<p>著名科幻小说《安德的游戏》中安德为了打败威胁人类的异星生物，尽可能掌握有关敌人更多信息，去理解敌人的优势和行为方式，
当他终于掌握了足够的信息足以消灭敌人之时，他却发现他已经爱上了这个种族——但这没有妨碍他为人类毁灭异己，
他<strong>含泪</strong>挽救了人类。
这正是大多数有技术信仰的人所缺乏的——他们光顾着跟自己喜欢的技术谈恋爱，而不想着如何去理解自己的敌人，以便消灭他们。</p>
<p>因此，我认为毁掉一个程序员的不是技术信仰，而是失去了接受新事物的能力，不愿意为了消灭敌人而去稍微接受一点自己不熟悉的东西。
他们失去了宽容的心胸，有的只是狭隘。</p>
<h2>RMS</h2>
<p>RMS，Richard Stallman，自由软件之父，最近在国内做多个地方做了演讲。我看到很多人认为，RMS 的有些想法过于激进。
我曾经就是其中之一，说“曾经”并不是说我现在已经能够完全接受他的所有看法了，只是我认为他的存在是必要的，
他的激进的言论和宣传也是必要的。</p>
<p>永远也不要低估人类的残忍和邪恶。你也许以为，你只要保持走中间路线就可以了，社会总是平衡的，RMS 以及《1984》
所描述的黑暗社会并不会出现。然而想想现今社会，有多少国家的人民，生活更恶劣的境地之中？
有多少政府在不断挑战着民主的底线？</p>
<p>那些想要将社会变成这种不自由的极端的人，是绝不会将这样的观点表露出来的，他们隐藏自己，他们小心翼翼将自己伪装成中间派，
对大众进行着“虽然自由很重要，但是为了 xxx 稍作妥协也是合理的”的宣传，因此大部分人只看到了 RMS 的抗争，觉得 RMS
是在跟不存在的敌人战斗，因此不能理解，觉得这是偏执和神经质。</p>
<p>事实上，如果没有像 RMS 这样的人存在，我们可能已经像温水青蛙一般煮掉了。RMS 作为一种刺激，
虽然略有极端，但是却能每隔一段时间都让我们警醒一下，不啻为一剂良药！</p>
<p>若有一天，我们的社会真的要倒向自由的反面，像 RMS 这样的人就是我们的最后屏障和救赎的希望。
因此你可以不接受他的思想，不接受他的行为方式，但是你应该尊重他努力。</p>
<h2>学生开源组织的建设</h2>
<p>我是一个很幸运的人，我在大学的时候加入了开源社区，结识了一群欢快的小伙伴们，
在现在的研究生阶段，也在努力从零做起，发起一个类似的开源组织。在这些过程中都是收获良多。</p>
<p>不得不说这一过程是很辛苦的，你会遇到各种的人，各种的事。而想要让一个开源社区发展壮大是非常困难的
——大多数学生都会对你敬而远之。</p>
<p>本来我们认为，在学校里适合开源技术的人等同于计算机技术相关专业的学生，
因为很多知名企业都在使用 Linux 技术，作为一个计算机方向的毕业生，
缺乏相关技能可以算是一笔巨大的隐性成本。与此相比，花费成本去学习 Linux 的也就是划算的了。</p>
<p>到后来我们终于明白，这只是保证了大学的计算机相关专业学生“应该”去了解 Linux 技术，
但是并不意味着他们就“适合”。什么样的学生才是适合 Linux 以及开源技术的呢？我认为有下面几条：</p>
<ol>
<li>有强烈好奇心的人。没有好奇心的人，别说学习 Linux，恐怕也不会对其他任何东西有探索的欲望</li>
<li>喜欢探索新事物，能够接受新事物的人。Linux 相对于大部分人来说可能算是一种新事物，年轻人接受新事物的能力一般都很强。
然而令人沮丧的是，现在大学生已经有人失去了这种能力。对于自己不知道不熟悉的事物持有抵触情绪，
连 Win7 可能都不愿意去尝试，因此更不用指望他去接受 Linux 了。</li>
<li>百折不挠，能够坚持的人。一开始使用 Linux 时，Linux 会时常让你有挫折感。驱动上的问题、
稳定性上的问题、耗电的问题等等。如果不是一个能够坚持的人，是熬不到成为一个熟练的使用者的。</li>
</ol>
<p>我认为以上三条，缺一不可，少了哪一条这个人都不会最后成为开源技术的认同者和追随者。因此，
在组建一个开源技术相关社区时，对于不具备这样特点的人就不要白费力气了。当然，想要构建一个成功的组织，
还需要各种因素，比如领导力、凝聚力等等，并不是发现了具备以上三者特点的同学就万事大吉了。</p>
<p>在大学中，符合以上条件的人实在是不能算多。但是组成一个小型的组织也不是什么大问题了。
但是还有一类人，如果有一两个在组织里都嫌多——因为他们是有害的。具体表现在于：</p>
<ol>
<li>也许有一些真才实学，但是喜欢吓唬人，比如甩一些高端的名词，呼啦呼啦说一大堆，美其名曰分享经验，
显得很高端，很多新手很容易就被唬住了，从而将其奉为“大牛”什么的。其实说的东西不一定行得通，
拍拍脑袋就出来了，自己不一定试过</li>
<li>自己觉得自己很牛，然后还很不谦虚，动不动说自己要去美国哪个企业啦，或者说自己曾经干过什么惊天伟业。
说的事情没人能验证，如果你要跟他较真，他就跟你急</li>
<li>看不起初学者走过的一些弯路，比较突出的是坚决反对初学者第一次使用虚拟机装 Linux。
非要人第一次就要独立装系统，还能说出一堆大道理来。我觉得适合 Linux 的人，最终还是会一步步提高技术，
有没有用虚拟机装过 Linux 根本属于细枝末节的问题，他们之所以纠结于此，不过是为了显示自己的优越感</li>
<li>爱跟人吵架，比如没事儿喷喷微软什么的，其实对对手的了解就那么一点，喷起来没什么花样，但是还是喜欢喷。
好像整个组织里就他最拥护开源技术，你只要提出一点异议，就属于背叛组织</li>
<li>喜欢“显得自己有价值”的人。在一些团队里，你会发现有些人好像什么都在干，可是其实什么事儿也没干。
这种人给人的第一印象是特有价值，但是你如果仔细想想，这件事也不是他干的，那件事也不是他干的，
他不过在旁边附和，或者实在不行了干点不重要的事儿。这种人还特别喜欢显得自己有价值，比如时常跟人说，
没有我就怎么怎么样了，或者这件事当初是“我跟谁谁谁”去干的。着实可恨！</li>
</ol>
<p>遇到这种类型的人，一定要小心，对组织真是贻害无穷，你问我为何能总结的那么清楚？那是因为我遇到过不止一个呢，
比如说<strong>我自己</strong>，膝盖上就可以中好多箭了。现在想想真是羞愧不已，幸好我造成危害还不算大，同志们比较包容，
组织现在也发展的越来越好了。否则真是罪莫大焉！</p>
<h2>总结跟自槽</h2>
<p>这篇文章，我就算是又多给自己中了一枪，虽说好好地喷了喷想喷之事，
但像这种吐槽类的文章，确实没多大意义。</p>
<p>我观察了一下，
发现在在各种社交网络上往往是这种文章特别火爆。我想，大概是这类文章写起来和读起来都比较容易，没有什么技术门槛，
无论你是真大神还是门外汉，都能扯上几句，当然容易有人气。反过来，有技术含量的文章写起来不易，
读者看起来也会比较吃力。</p>
<p>写出来这篇文章，真的很抱歉耽误了大家的很多时间。但是我想，如果读了这篇文章的人中若有能认同我的，
能以后不再在这种没有营养的文章上浪费时间，能不再盲目崇拜写这类文章的所谓“大神”们，
这篇文章也就不算是没有意义。</p>
]]></content>
    <summary type="html"><![CDATA[<p>这是一篇吐槽为主的文章，主要针对的是最近的一个时期比较热点的话题，
包括<a href="http://blog.jobbole.com/67744/" target="_blank">开源产品成本更高论</a>、
<a href="http://zh.wikipedia.org/zh-cn/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E" target="_blank">HeartBleed</a>、
<a href="http://blog.jobbole.com/67818/" target="_blank">技术信仰是如何毁掉程序员的</a>、RMS 的中国之行、
学生开源组织的建设等等话题。总体来说内容比较有争议，请慎入。</p>
]]></summary>
    
      <category term="opensource" scheme="http://io-meter.com/tags/opensource/"/>
    
      <category term="linux" scheme="http://io-meter.com/tags/linux/"/>
    
      <category term="吐槽" scheme="http://io-meter.com/tags/%E5%90%90%E6%A7%BD/"/>
    
      <category term="essay" scheme="http://io-meter.com/categories/essay/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[More on Bezier Path]]></title>
    <link href="http://io-meter.com/2014/05/14/more-detail-on-bezier-path/"/>
    <id>http://io-meter.com/2014/05/14/more-detail-on-bezier-path/</id>
    <published>2014-05-14T11:04:51.000Z</published>
    <updated>2014-05-15T04:25:05.000Z</updated>
    <content type="html"><![CDATA[<p>在之前讲解 Icon Font Viewer 和 SVG 的文章中，曾经简单介绍过 Bezier Path。
这次再稍微介绍一点数学原理，另外针对 Bezier Path 使用上的一些问题进行更多的探讨。</p>
<a id="more"></a>

<p>贝塞尔曲线最初应用于汽车主体设计，由法国工程师 Pierre Bézier 最早提出。
现在在计算机图形学中具有的应用非常广泛，可以说，
你在计算机上所看到的大多数矢量曲线，都是由 Bezier Path 绘制出来的。</p>
<p>目前常用的 Bezier 曲线有二阶和三阶两种。广泛使用的 TrueType 以二阶 Bezier 曲线为基础的，
Postscript 则是使用三阶 Bezier 曲线的代表。三阶 Bezier 曲线已经可以满足大多数需求了，
对于更高阶的曲线，可以使用这两种 Bezier 曲线来进行分段拟合。</p>
<p>下面先介绍 Bezier 曲线的数学表达式。</p>
<h2>Bezier 曲线的数学表达式</h2>
<p>最简单的 Bezier 曲线是一阶的——其实就是线段。它的参数形式是：</p>
<p>$$\mathbf{B}^{(1)}(t)=\mathbf{P}_0 + (\mathbf{P}_1-\mathbf{P}_0)t=(1-t)\mathbf{P}_0 + t\mathbf{P}_1 \mbox{ , } t \in [0,1]$$</p>
<p>观察上面的公式，在 $t$ 取 0 到 1 之间的值时，$\mathbf{B}(t)$ 的值就是在 $\mathbf{P}_0$ 和 $\mathbf{P}_1$ 之间线段上某一点的坐标。
我们把 $\mathbf{P}_0$ 和 $\mathbf{P}_1$ 称为曲线的控制点，那么一阶 Bezier 曲线需要的控制点数量就是 2。
实际上，$n$ 阶 Bezier 曲线需要 $n+1$ 个控制点。</p>
<p>一阶 Bezier 曲线还称不上“曲线”，使用最多的两种 Bezier 曲线是二阶和三阶的。
二阶 Bezier 曲线的参数方程为：</p>
<p>$$\mathbf{B}^{(2)}(t) = (1 - t)^{2}\mathbf{P}_0 + 2t(1 - t)\mathbf{P}_1 + t^{2}\mathbf{P}_2 \mbox{ , } t \in [0,1]$$</p>
<p>三阶 Bezier 曲线的参数方程为：</p>
<p>$$\mathbf{B}^{(3)}(t)=\mathbf{P}_0(1-t)^3+3\mathbf{P}_1t(1-t)^2+3\mathbf{P}_2t^2(1-t)+\mathbf{P}_3t^3 \mbox{ , } t \in [0,1]$$</p>
<p>对于 $n$ 阶的 Bezier 曲线，有一个一般化的参数方程，这里就不再赘述。
在目前的使用的计算机图形绘制系统中，最广泛使用的就是三阶 Beizer 的曲线，
因为它的复杂度比较适中，尤其是用来拟合圆弧的时候非常方便，
OSX 和 iOS 的绘图系统 CoreGraphic 就是使用的三阶 Bezier 曲线，
SVG 标准上来说同时支持二阶和三阶 Bezier 曲线，但是不同浏览器在绘制的时候可能会有所不同。</p>
<p>下面有两个重要的性质在后面的讨论中可能会用到：</p>
<ol>
<li>$n$ 阶 Bezier 曲线经过它第一个控制点和最后一个控制点。
只需要 $t$ 分别设为 $0$ 和 $1$ 就可以看出来。</li>
<li>对于二阶以上的 Bezier 曲线，
$\mathbf{P}_0\mathbf{P}_1$ 和 $\mathbf{P}_{n-2}\mathbf{P}_{n-1}$ 这两条线段同曲线相切。</li>
<li>$\mathbf{B}(t) = (1-t)\mathbf{B}(t) + t\mathbf{B}(t)$</li>
</ol>
<h2>使用高阶 Bezier 曲线拟合低阶 Bezier 曲线。</h2>
<p>之前曾经提到过，一些图形系统只支持某一个阶次的 Bezier 曲线，
比如 PostScript 和 Cocoa 就只支持三阶 Bezier 曲线。但是有些图形系统，
比如 TrueType 和 SVG，都是支持 二阶 Bezier 曲线的。
因此我们需要能够在只支持高阶 Bezier 曲线的图形系统中绘制低阶 Bezier 曲线。</p>
<p>实际上利用上面的第三个属性，这件事是可以精确做到的 (每个点都可以相吻合)。
这里只给出二阶升三阶的过程：</p>
<p>对于二阶 Bezier 曲线 $\mathbf{B}^{(2)}(t)$，将其表达式带入第三条性质，有</p>
<p>$$\begin{eqnarray*}
\mathbf{B}^{(2)}(t) &amp; = &amp; (1-t)\mathbf{B}^{(2)}(t)+t\mathbf{B}^{(2)}(t)\\
 &amp; = &amp; (1-t)^{3}\mathbf{P}_{0}+(1-t)^{2}t\mathbf{P}_{0}+2(1-t)^{2}t\mathbf{P}_{1}+\\
 &amp;  &amp; 2(1-t)t^{2}\mathbf{P}_{1}+(1-t)t^{2}\mathbf{P}_{2}+t^{3}\mathbf{P}_{2}\\
 &amp; = &amp; (1-t)^{3}\mathbf{P}_{0}+3(1-t)^{2}t\frac{\mathbf{P}_{0}+2\mathbf{P}_{1}}{3}+\\
 &amp;  &amp; 3(1-t)t^{2}\frac{2\mathbf{P}_{1}+\mathbf{P}_{2}}{3}+t^{3}\mathbf{P}_{2}
\end{eqnarray*}$$</p>
<p>取下列变换代入原式</p>
<p>$$\begin{eqnarray*}
\mathbf{P}&#39;_{0} &amp; = &amp; \mathbf{P}_{0}\\
\mathbf{P}&#39;_{1} &amp; = &amp; \frac{\mathbf{P}_{0}+2\mathbf{P}_{1}}{3}\\
\mathbf{P}&#39;_{2} &amp; = &amp; \frac{2\mathbf{P}_{1}+\mathbf{P_{2}}}{3}\\
\mathbf{P}&#39;_{3} &amp; = &amp; \mathbf{P}_{2}
\end{eqnarray*}$$</p>
<p>恰好可以得到三阶 Bezier 曲线 $\mathbf{B}^{(3)}(t)$ 的表达形式。这样我们就可以使用三阶 Bezier 曲线来精确绘制出二阶
Bezier 曲线。也正因为如此，在目前绝大部分的计算机图形系统中，都是只提供三阶 Bezier 曲线的绘制函数。</p>
<p>下面是一个使用 SVG 绘制的例子 (需浏览器支持才能查看)，你可以通过查看页面源码看到具体的实现。
从左往右，依次是二阶 Bezier 曲线、三阶 Bezier 曲线和将二者重叠起来的效果。可以看到两条曲线是完全吻合的。</p>
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
width="100%" height="auto" viewBox="0 0 400 150" enable-background="new 0 0 400 200" xml:space="preserve">
<path fill="transparent" stroke="#F00" stroke-width="2" d="M30,30 Q30,90 90,90"/>
<path fill="transparent" stroke="#000" stroke-width="2" d="M130,30 C130,70 150,90 190,90"/>
<path fill="transparent" stroke="#F00" stroke-width="4" d="M230,30 Q230,90 290,90"/>
<path fill="transparent" stroke="#000" stroke-width="1" d="M230,30 C230,70 250,90 290,90"/>
<text x="30" y="110">Quadratic</text>
<text x="130" y="110">Cubic</text>
<text x="230" y="110">Overlap</text>
<circle cx="30" cy="30" r="2" fill="#F0F" />
<circle cx="30" cy="90" r="2" fill="#F0F" />
<circle cx="90" cy="90" r="2" fill="#F0F" />
<circle cx="130" cy="30" r="2" fill="#F0F" />
<circle cx="130" cy="70" r="2" fill="#F0F" />
<circle cx="150" cy="90" r="2" fill="#F0F" />
<circle cx="190" cy="90" r="2" fill="#F0F" />
<polyline fill="transparent" stroke="#999" points="30,30 30,90 90,90"></polyline>
<polyline fill="transparent" stroke="#999" points="130,30 130,70 150,90 190,90"></polyline>
</svg>

<h2>用低阶曲线表示高阶曲线？</h2>
<p>接下来自然有一个问题，如果我有一个高阶的曲线需要绘制，而系统只支持低阶曲线，那么应该如何实现呢？
很不幸的是，使用有限条低阶的曲线是没有办法精确的绘制出需要的高阶曲线的，一般使用的方法是逼近法。
一个比较常用的技巧是将高阶曲线分割为两个部分，对这两个部分分别使用低一阶的曲线进行逼近，从而获得一个比较好的效果。</p>
<p>关于这个主题，<a href="http://www.caffeineowl.com/graphics/2d/vectorial/cubic2quad01.html" target="_blank">这篇文章</a>
中有详细的介绍，涵盖了：</p>
<ol>
<li>使用一条低阶曲线逼近高一阶曲线的方法</li>
<li>使用两条曲线逼近高一阶曲线前后两部分的方法</li>
<li>可变数量的曲线动态逼近高一阶曲线的算法</li>
</ol>
<p>使用低阶曲线逼近高阶曲线是一个比较复杂的问题，而且没有一个很简洁且效果很好的通用公式。
这里就不赘述了。</p>
<p>一个更实用的方法是直接用折线去逼近高阶曲线。实际上，即使是二阶和三阶 Bezier 曲线，
具体实现中也是使用同样的方法。既然知道了高阶曲线的参数方程，直接使用方程来分段成折线绘制自然最好不过了。
需要注意的是，为了获得较好的效果和性能，一般来说不会使用均匀的折线分段。
一个比较简单的算法就是在曲线曲率较大的地方多安排分段，反之少安排分段。</p>
<h2>使用三阶 Bezier 曲线逼近圆弧</h2>
<p>圆弧是另一个我们经常使用的平面曲线，下面是圆的参数方程：</p>
<p>$$
\begin{eqnarray*}
x=r\cos\theta\\
y=r\sin\theta
\end{eqnarray*}.
$$</p>
<p>可以看出，如果要精确绘制圆弧，我们不得不计算 $\sin\theta$ 和 $\cos\theta$ 的值，
这对于计算机来说，是一个成本很高、得不偿失的工作。使用具有多项式表达式的三阶 Bezier 
曲线来逼近圆弧就成为了一个很好的选择。</p>
<p>我们是无法使用一条完整的 Bezier 曲线来绘制整个圆的，常用的方法是用一条 Bezier 曲线去逼近一个四分之一圆弧，
使用四条曲线组成一个圆。</p>
<p>简便起见，取圆心在原点的单位圆在第一象限的四分之一圆弧进行讨论。由上面所提到的
Bezier 曲线的第一条性质，可以得到用来用来逼近这个圆弧的 Bezier 曲线一定满足：</p>
<p>$$
\begin{eqnarray*}
\mathbf{P}_{0} &amp; = &amp; (0,1)\\
\mathbf{P}_{3} &amp; = &amp; (1,0)
\end{eqnarray*}
$$</p>
<p>这是因为我们指定的圆弧必定经过 $(0,1)$ 和 $(1,0)$ 这两个点，因此用来逼近的 Bezier 曲线也应该经过这个点。</p>
<p>同理，因为圆弧在这两点的切线分别平行于 $x$ 轴和 $y$ 轴，由第二条性质，$\mathbf{P}_1$ 的 $x$ 坐标必定为 $1$，
$\mathbf{P}_2$ 的 $y$ 坐标必定为 $1$。同时因为圆弧是对称的，$\mathbf{P}_1$ 的 $y$ 坐标和
$\mathbf{P}_2$ 的 $x$ 坐标一定是相同的，将其设为 $\lambda$，此时 Bezier 曲线的表达式可以化简为：</p>
<p>$$
\begin{eqnarray*}
C_{x}(t) &amp; = &amp; 3(1-t^{2})t\lambda+3(1-t)t^{2}+t^{3}\\
C_{y}(t) &amp; = &amp; (1-t)+3(1-t^{2})t+3(1-t)t^{2}\lambda
\end{eqnarray*}
$$</p>
<p>其中 $C_{x}(t)$ 和 $C_{y}(t)$ 分别代表三阶 Bezier 曲线的 $x$ 和 $y$ 坐标关于参数 $t$ 的函数。</p>
<p>此外，我们的圆弧肯定经过 $(\frac{\sqrt{2}}{2}, \frac{\sqrt{2}}{2})$ 这个点，
使 Bezier 曲线经过这个点，且由对称性此时需有 $t=0.5$。 代入上面的式子，我们可以解出。</p>
<p>$$
\lambda = \frac{4}{3}(\sqrt{2}-1)\approx 0.5522847498
$$</p>
<p>至此我们就可以绘制出来一个比较完美的四分之一圆弧了，为了绘制一整个圆，
可以使用四个这样的 Bezier 曲线来实现。不同半径的圆只要按比例缩放上面这个参数就可以达到目的。
实际上使用三阶 Bezier 曲线，我们还可以方便的绘制出非 $\frac{\pi}{2}$ 弧度的圆弧。
具体的公式可以在这个<a href="http://itc.ktu.lt/itc354/Riskus354.pdf" target="_blank">参考文献</a>中找到。</p>
<p>下面是一个使用 SVG 的绘制演示，最左边是使用三阶圆弧绘制的效果，中间是使用 SVG 内置的 Arc 命令绘制的效果，
最右边的是将两个结果重叠在一起的效果，可以看出来是完全吻合的。这是因为在绝大部分 SVG 的绘制系统中，
其实就是使用三阶 Bezier 曲线来绘制圆弧的。</p>
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
width="100%" height="auto" viewBox="0 0 400 150" enable-background="new 0 0 400 200" xml:space="preserve">
<path fill="transparent" stroke="#F00" stroke-width="2" d="M10,10 C54.1824,10 90,45.8176 90,90"/>
<path fill="transparent" stroke="#000" stroke-width="2" d="M100,10 A80,80 0 0 1 180,90"/>
<path fill="transparent" stroke="#F00" stroke-width="4" d="M200,10 C244.1827,10 280,45.8176 280,90"/>
<path fill="transparent" stroke="#000" stroke-width="2" d="M200,10 A80,80 0 0 1 280,90"/>
<text x="10" y="110">Bezier Path</text>
<text x="130" y="110">Arc</text>
<text x="210" y="110">Overlap</text>
<circle cx="10" cy="10" r="2" fill="#F0F" />
<circle cx="54.1824" cy="10" r="2" fill="#F0F" />
<circle cx="90" cy="45.8176" r="2" fill="#F0F" />
<circle cx="90" cy="90" r="2" fill="#F0F" />
<polyline fill="transparent" stroke="#999" points="10,10 54.1824,10 90,45.8176 90,90"></polyline>
<polyline fill="transparent" stroke="#99f" points="10,10 10,90, 90,90"></polyline>
<polyline fill="transparent" stroke="#99f" points="100,10 100,90, 180,90"></polyline>
<polyline fill="transparent" stroke="#99f" points="200,10 200,90, 280,90"></polyline>
</svg>

<h2>总结和扩展</h2>
<p>在这篇文章讨论了二维平面上的 Bezier 曲线的一些特性，只要改变控制点的维度，
就可以很容易地将其推广到三维甚至更高维空间上去。</p>
<p>现在，在 Bezier 曲线的基础上还发展出了 B 样条，并能够进一步推广为 NURBS (非均匀有理 B 样条)。
NURBS 在 3D 建模和工业设计上使用非常广泛，常用的 3D 制作软件，如 Maya、Rhino、Blender 等都支持 NURBS。
下图是在 Blender 中显示一个简单 NURBS 表面的效果。</p>
<p><img src="/img/posts/NURBS-blender.png" alt="NURBS on blener"></p>
<p>关于 Bezier 曲线还有很多值得讨论的东西，希望这篇文章对相关学习提供一定的帮助。</p>
<h3>参考文献</h3>
<ol>
<li><a href="http://en.wikipedia.org/wiki/B-spline" target="_blank"><a href="http://en.wikipedia.org/wiki/B-spline">http://en.wikipedia.org/wiki/B-spline</a></a> </li>
<li><a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank"><a href="http://en.wikipedia.org/wiki/B%C3%A9zier\_curve">http://en.wikipedia.org/wiki/B%C3%A9zier\_curve</a></a></li>
<li><a href="http://itc.ktu.lt/itc354/Riskus354.pdf" target="_blank"><a href="http://itc.ktu.lt/itc354/Riskus354.pdf">http://itc.ktu.lt/itc354/Riskus354.pdf</a></a></li>
<li><a href="http://www.caffeineowl.com/graphics/2d/vectorial/cubic2quad01.html" target="_blank"><a href="http://www.caffeineowl.com/graphics/2d/vectorial/cubic2quad01.html">http://www.caffeineowl.com/graphics/2d/vectorial/cubic2quad01.html</a></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths" target="_blank"><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths">https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths</a></a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>在之前讲解 Icon Font Viewer 和 SVG 的文章中，曾经简单介绍过 Bezier Path。
这次再稍微介绍一点数学原理，另外针对 Bezier Path 使用上的一些问题进行更多的探讨。</p>
]]></summary>
    
      <category term="math" scheme="http://io-meter.com/tags/math/"/>
    
      <category term="bezier path" scheme="http://io-meter.com/tags/bezier%20path/"/>
    
      <category term="Math" scheme="http://io-meter.com/categories/Math/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mastering Paper by 53 : 基础介绍及工具使用指导]]></title>
    <link href="http://io-meter.com/2014/05/07/mastering-paper-by-53/"/>
    <id>http://io-meter.com/2014/05/07/mastering-paper-by-53/</id>
    <published>2014-05-07T06:24:29.000Z</published>
    <updated>2014-05-08T09:35:30.000Z</updated>
    <content type="html"><![CDATA[<p>这是一篇翻译自 <a href="http://mademistakes.com/" target="_blank">Made Mistakes</a> 的 Paper 绘画教程。
作者 Michael Rose 发布了一系列使用 Paper 绘图的文章，此为系列的第一章。
主要是一些基础知识和画笔的详细说明。</p>
<a id="more"></a>

<p>顺便指出，原文作者正在进行 Paper Faces Project，
只要支付少量费用以及提供一张相片，就可以得到一张作者使用 Paper
绘制的肖像画，详情可以访问<a href="http://mademistakes.com/paperfaces/" target="_blank">这里</a>了解。</p>
<p>下面是正文部分。</p>
<hr/>

<p>Paper by 53 从一开始就是我 (原文作者) 的最佳拍档。我的<a href="http://mademistakes.com/articles/" target="_blank">日志</a>
各处大概分布了六百多张用它完成的作品，花费时间的从半小时到四个小时不等。
保守估计，我至少花费了五百个小时在这个 iOS 应用上——我自己都觉得有些惊讶！
我不确定这是否意味着我可以作为一个好老师来教授 Paper 的使用，
但是我会尝试将我之前曾经提到过的建议和技巧，在这一系列的文章中展开介绍一下。</p>
<p>第一部分你将会了解到绘图笔的好处以及 Paper by 53 所有画笔的工作方式，
此外还有一些基本的操作手势。其后的部分将会更深入介绍绘制出理想效果的技巧、
页面管理、高级特性以及如何录制 iPad 的屏幕记录下你绘图的过程。</p>
<h2>买根绘图笔？</h2>
<p>使用手指可以绘制出优秀的作品，
但是对于用惯铅笔和钢笔的人来说这感觉非常不自然。如果要选择一款电容笔，
首先必须要了解一个事实：一般的电容笔都是带有又粗又软的笔尖的，
因此无法达到传统笔绘图的精度。</p>
<p><img src="/img/paper/adonit-jot-classic-tip.jpg" alt="Adonit 提供的画笔很适合需要高精度的场合 "></p>
<blockquote>
<p>ProTip: 
如果你对绘图精度要求很高，我建议你试用一下来自 <a href="http://adonit.net/" target="_blank">Adonit Jot</a>
的绘图笔。这种绘图笔的笔尖是透明塑料帽，可以旋转和倾斜以贴合 iPad 的屏幕。
方便你清晰的看到笔尖在屏幕上的所指的位置。</p>
</blockquote>
<p>更高级一点的绘图笔是带有压力感应的那种。使用这种笔，
你可以根据你绘制时对笔尖的压力来控制笔触的特性。
Paper by 53 原生支持 Ten One Design 的 <a href="http://www.tenonedesign.com/connect" target="_blank">Pogo Connect Smart Pen</a>，
因此很快就成了我在 iPad 上绘图的首选。
关于这杆笔的详细情况，可以看我之前的<a href="http://mademistakes.com/articles/pogo-connect-smart-pen/" target="_blank">图文评测</a>。</p>
<p><img src="/img/paper/paper-53-the-tools.jpg" alt="Tools"></p>
<h2>绘图工具以及他们的行为方式</h2>
<p>Paper by 53 提供的绘图工具从左到右依次是：橡皮、钢笔、铅笔、马克笔、水笔、水彩刷（毛笔）以及调色板。
钢笔和橡皮是免费版本开放的工具，其余则需要使用应用内购买解锁。
在介绍这些工具的时候，我将使用下面的特征进行描述：</p>
<ul>
<li><strong>速度</strong>：绘制的速度如何影响笔触的粗细</li>
<li><strong>混色</strong>：笔触是否透明。如果是透明的，反复绘制多少层才能达到纯色</li>
<li><strong>感压</strong>：如果你使用 Pogo Connect 感压笔，笔尖压力对笔触效果的影响</li>
</ul>
<h3>橡皮</h3>
<p>橡皮的功用正如其名——它用来擦除绘制出的图形。使用粗笔尖时，他是最不精确的工具，
因此我常用撤销操作代替。</p>
<p>在进行清理工作时，橡皮工具在确定明显边缘和将他们捋直的时候很有效。
仅仅在图案的一边划过即可清除掉这一边由铅笔或水彩刷留下的不平滑的边缘。</p>
<p><img src="/img/paper/paper-53-erased-edge.jpg" alt=" 清除边缘 "></p>
<ul>
<li><strong>速度</strong>：速度慢时笔触细，速度快时笔触粗</li>
<li><strong>混色</strong>：完全不透明，一条笔划会清除掉其下所有的内容（变成背景的蛋壳白色）</li>
<li><strong>感压</strong>：轻压笔触细，重压笔触粗</li>
</ul>
<p><img src="/img/paper/paper-53-eraser-thick-thin.jpg" alt=" 笔划速度越快，擦除范围越大 "></p>
<h3>钢笔工具 (适合绘图)</h3>
<p>钢笔工具和橡皮工具一样是免费版中包含的绘图工具。这个工具是我一年前试用 Paper 时使用的最多的工具。
当你用手指在 iPad 的屏幕上滑动时，很难不爱上钢笔工具产生的平滑的曲线。</p>
<p><img src="/img/paper/paper-53-fountain-pen-layers.jpg" alt=" 钢笔工具的笔触有一点半透明 "></p>
<p>我的绘画风格这些年从比较干脆直接的形式演化到现在，边缘和色调变得柔软和调和了。
因此钢笔工具变得跟橡皮工具一样使用不多了。因为笔触很紧致，
所以它很适合给大块空间着色。</p>
<p><img src="/img/paper/paper-53-background-fill.jpg" alt=""></p>
<blockquote>
<p>ProTip: 橡皮会擦除所有的颜色——甚至包括背景的填充色。
用钢笔工具配合跟背景一样的颜色可以代替橡皮工具来修正错误。</p>
</blockquote>
<ul>
<li><strong>速度</strong>：速度慢笔触细，速度快笔触粗</li>
<li><strong>混色</strong>：几乎不透明的，根据颜色不同大约只需两到三层就可以得到纯色。</li>
<li><strong>感压</strong>：轻压笔触细，重压笔触粗</li>
</ul>
<h3>铅笔工具 (适合素描)</h3>
<p>铅笔工具的适用面很广，在大多数情况下都很完美——如果你在初学的时候只想要解锁一个收费工具，
那么非铅笔工具莫属。铅笔工具的笔触与传统的 2B 铅笔类似，可以留下为明暗效果留下完美的纹理。
它也是在涂色之前打创作草稿的完美工具。</p>
<p><img src="/img/paper/paper-53-pencil-sketch.jpg" alt=" 灰阶的铅笔工具是绘制草图的完美工具 "></p>
<p>如果你使用的是支持感压的绘图笔，其绘制明暗的能力几乎可以无限倍增。
如果你已经掌握使用真的铅笔在纸上绘图的技法，那么你其实已经掌握了这一数字铅笔的使用。
这使得他成为 Paper 的工具箱中最精确和最高容错的工具之一。</p>
<ul>
<li><strong>速度</strong>：速度慢颜色深，速度快颜色浅</li>
<li><strong>混色</strong>：半透明——需要反复叠加多层才能得到完全不透明的颜色</li>
<li><strong>感压</strong>：轻压笔触细，重压笔触粗</li>
</ul>
<h3>马克笔 (适合绘制轮廓)</h3>
<p>不同于钢笔工具，马克笔产生可以看透的透明效果。
想象一下你使用的用来在书本上做高亮标记的黄色马克笔，
当你在黑色的字上划出标记后，黑色的字是不会被掩盖住的。Paper 里的马克笔工具具有相同的效果。</p>
<p><img src="/img/paper/paper-53-marker-yellow-layers.jpg" alt=" 当马克笔被应用于更深的颜色上层时，它是完全透明的 "></p>
<p>不过这一规则有一个例外，那就是当你设定颜色为纯白时，马克笔有些类似橡皮的作用。
区别在于，橡皮产生的背景色并非纯白，而马克笔产生的是纯白。</p>
<p><img src="/img/paper/paper-53-eraser-vs-marker.jpg" alt=" 近距离观察可以发现橡皮和马克笔的颜色略有不同 "></p>
<p>如果你的作品需要锋利的色块和渐变，马克笔就是一个 A+++ 的选择。
我的绘画风格更偏向于照片级的真实效果，但如果你想要卡通和漫画书那样的效果，
马克笔就比较合适。</p>
<p><img src="/img/paper/paper-53-eraser-sharp-edge.jpg" alt=""></p>
<ul>
<li><strong>速度</strong>：速度慢笔触粗，速度快笔触细</li>
<li><strong>混色</strong>：透明的，但是对于黑白两色是特例</li>
<li><strong>感压</strong>：轻压笔触细，重压笔触粗</li>
</ul>
<h3>水笔 (适合书写)</h3>
<p>跟名字所指一样，水笔和常见的那种圆珠笔表现类似。仔细观察可以发现，
它绘制出的曲线在开始和结束的地方都有较重的点，即使在绘制的过程中整体的笔划速度都很快。</p>
<p><img src="/img/paper/paper-53-ink-pen-lines.jpg" alt=""></p>
<p>如果你觉得钢笔的粗细不是你想要的或者很难控制，水笔可能是一个更好的选择。
水笔在线条粗细上的变化更小，从而很适合用于书写和进行细节绘制。</p>
<p>在我开始只使用 Pogo Connect 绘图笔之前，我一直用钢笔工具进行书写工作，
在使用了感压笔之后，我发现在使用钢笔书写字母时的压力很不好控制，
所以专向了使用水笔工具。</p>
<ul>
<li><strong>速度</strong>：差别很小，速度慢的话笔触略微粗一点</li>
<li><strong>混色</strong>：完全不透明</li>
<li><strong>感压</strong>：差别很小，重压笔触略微粗一点</li>
</ul>
<h3>水彩刷 (适合着色)</h3>
<p>同铅笔一样，水彩刷是另一种你应该认真花时间实验和学习它全部细节的工具。
这个工具通过复现在真实画布上推拉笔刷的感觉，使 Paper 从各类绘图软件中脱颖而出。
离开了它，我简直不能做任何明暗效果、不能绘制天空以及绘制真实的须发效果。</p>
<blockquote>
<p>ProTip：尽管在 Paper 中没有明显的方式来改变笔刷的大小。
但是在使用感压笔的时候你可以通过加大压力来获得更粗的线条。
通过加大压力你大约可以相比原来加粗笔触大约四分之一。</p>
</blockquote>
<p>把你的画笔假想为一个笔尖处沾满了水彩颜料的笔刷可以帮助你理解画笔的效果。
因为颜料被稀释了，因此水彩刷工具不会产生钢笔那么强烈和饱和的颜色。
因此你需要通过反复涂色才能达到类似的深度。</p>
<p><img src="/img/paper/paper-53-watercolor-even-fill.jpg" alt=" 为了得到平滑的颜色，要缓慢的移动画笔以避免斑点 "></p>
<p>颜色的溵出效果也会影响你覆盖颜色时的连贯度。移动笔刷过快将会使颜色无法完全覆盖某一个位置，
因此会出现颜色不均匀的现象。相反，缓慢的移动画笔允许颜料在画布上留下连贯的变化。
掌握这种速度的变化你才能画出平滑的色块和渐变。</p>
<p>产生一些围绕某一主颜色、灰色和黑色周围的色彩范围有时很有用。
下图展示了 53 升级了 Paper 以支持调色器之后，我做的一些水彩的效果测试。</p>
<p><img src="/img/paper/paper-53-watercolor-layers.jpg" alt=""></p>
<blockquote>
<p>ProTip：当你给水彩刷配置了白色后，可以用它来减淡你已经绘制的部分的颜色。
必须记住的一点是，白色颜料在水彩刷这里的表现与其他颜色不同，有可能会很难掌握。
如果绘制的过慢，你可能会产生过多的白色以至于产生了过白的区域。
关于这个技巧的详细说明将会留在本系列的第二部分。</p>
</blockquote>
<h3>混色器</h3>
<p>在混色器出现之前，你可能要费一番脑筋才能获得 Paper 自带的九种颜色之外的颜色。
通过直接在画布上混合这些颜色，你可以获得其他的颜色。有些颜色使用这种方式可以获得很好的效果，
然而对于其他颜色可能会显得很脏——因为叠加了太多的颜色。</p>
<p><img src="/img/paper/paper-53-watercolor-primary-secondary.jpg" alt=""></p>
<p>颜色理论是个不好掌握的狡猾家伙，还好 53 提供了方便的混色器。
混合任意的两个颜色几乎总是能产生一个看上去不错的新颜色。</p>
<p>对于需要更多控制和想要一个传统的取色器的人，可以通过将色盘中的取样点拖动到混色轮的上面
然后轻击它。这里你可以调整颜色的色调 (Hue)、饱和度 (Sataration) 和亮度 (Luminosity)。</p>
<p><img src="/img/paper/paper-53-color-picker-slider.jpg" alt=""></p>
<p>我通常通过在原来的颜色的基础上提高饱和度和降低亮度的方法，来获得一个不错的阴影颜色。</p>
<blockquote>
<p>ProTip：如果你在某个方向上调整过度，将会接近于纯白色。
而纯白将会导致水彩刷和马克笔的笔触变得不透明。每种颜色都有不同的阈值点。
这个阈值可以通过不断地尝试来发现。</p>
<p>ProTip：有时超过这一个阈值点是一个好事——特别是你需要减淡一些颜色的时候。
使用想要的减淡的颜色作为基础来提高亮度的方法而不是直接使用纯白，
可以获得比使用橡皮擦更加生动的效果。</p>
</blockquote>
<h2>善用手势操作</h2>
<p>撤销和缩放是两个必学的手势操作。</p>
<h3>撤销操作</h3>
<p>可以告诉你个小秘密，在我使用 Paper 的最初几个月里，我非常讨厌这个撤销操作手势，
因为我经常不能连贯地使用它。这让我感到非常挫败因此改用橡皮来代替它。
那时，如果有一个支持多重撤销的按钮，我绝对会为之倾倒！</p>
<p><img src="/img/paper/paper-53-rewind-stormtrooper.jpg" alt=""></p>
<p>最终我还是强迫自己再多尝试它一下，并终于在几周后完全掌握了轻松退回绘图历史的方法。
尽管 53 很可能在幕后想尽方法来使撤销手势更好用，但是我更倾向于认为是我的坚持不懈取得的回报。</p>
<p>如果你遇到了问题，坚持别放弃，我发誓最后你将会感觉到非常自然。
如果仍然不行的话，你也总是可以买一个 Pogo Connect 绘图笔然后将其辅助键映射到撤销操作上。
修正一步简单的误绘撤销键能够很好地工作，
对于多重撤销我建议还是使用撤销手势来避免太多次按下绘图笔的辅助键。</p>
<h3>缩放操作</h3>
<p>加入缩放功能是 Paper 粉和 Paper 黑共同的呼声。
在没有缩放功能的情况下我绘制了一百多幅肖像，但是我仍然很高兴 53 最终还是加入了这个功能。
此外，其实还有一个小技巧：使用 iOS 自带的 Accessibility 功能，通过三指轻拍手势来实现缩放。
不是一个软件原生的缩放，但是很适合在需要放大一个区域的时候使用
——绘图工具并没有被缩放因此并不是那么有用。</p>
<p><img src="/img/paper/paper-53-zoom-tool-eye.jpg" alt=""></p>
<p>关于缩放没有什么其他可说的了，我仅仅是提到这个工具以吸引对它的注意力。
不同于其他支持缩放的绘图软件，Paper 的整个画布并不缩放，
相反，你通过开启一个圆形的放大镜来控制你需要放大的区域，
你可以移动这个放大镜或者在其范围外轻击来取消它的显示。</p>
<blockquote>
<p>ProTip：你通过在黑色的边缘拖动它来移动这个放大镜，
这个操作有时候会显得很麻烦，但是相比撤销手势来说还算是不怎么让人恼火的。</p>
</blockquote>
<h2>结语</h2>
<p>OK，现在你基本上熟悉了 Paper 的各种工具。我希望这能成为 Paper by 53
的一个不错的介绍，希望它能够帮助你了解如何使用绘图工具、触摸手势并且了解这个应用的可以实现的功能。</p>
<p>[原文链接]<a href="http://mademistakes.com/mastering-paper/introduction-tool-guide/" target="_blank"><a href="http://mademistakes.com/mastering-paper/introduction-tool-guide/">http://mademistakes.com/mastering-paper/introduction-tool-guide/</a></a></p>
]]></content>
    <summary type="html"><![CDATA[<p>这是一篇翻译自 <a href="http://mademistakes.com/" target="_blank">Made Mistakes</a> 的 Paper 绘画教程。
作者 Michael Rose 发布了一系列使用 Paper 绘图的文章，此为系列的第一章。
主要是一些基础知识和画笔的详细说明。</p>
]]></summary>
    
      <category term="paper" scheme="http://io-meter.com/tags/paper/"/>
    
      <category term="drawing" scheme="http://io-meter.com/tags/drawing/"/>
    
      <category term="iPad" scheme="http://io-meter.com/tags/iPad/"/>
    
      <category term="Mastering Paper" scheme="http://io-meter.com/categories/Mastering%20Paper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写个 Icon Font Viewer: 终]]></title>
    <link href="http://io-meter.com/2014/05/04/iconfontr-export-images/"/>
    <id>http://io-meter.com/2014/05/04/iconfontr-export-images/</id>
    <published>2014-05-04T07:49:49.000Z</published>
    <updated>2014-05-07T07:54:39.000Z</updated>
    <content type="html"><![CDATA[<p>终于到了 Icon Fontr 最重要的一部分了。这一次要把已经读入为<code>NSBezierPath</code>
的 Icon 导出成 SVG 和图片，以便于在桌面和移动应用或者 UI 设计软件当中使用。</p>
<a id="more"></a>

<h1>NSBezierPath To SVG Path</h1>
<p>首先是将<code>NSBezierPath</code>转换为 SVG 中的 Path 的方法。这一部分实际上是相当容易的。</p>
<p>我们先来了解一下 SVG Path 的基础知识，根据 MDN 上的<a href="https://developer.mozilla.org/en/docs/Web/SVG/Tutorial/Paths" target="_blank">介绍</a>
对于一个<code>&lt;path&gt;&lt;/path&gt;</code>标签，由名为<code>d</code>的属性来指定了遗传
一串简写的图形绘制命令。其可用参数可以总结如下:</p>
<ul>
<li><code>M</code>: Move To，移动光标到某一位置，接受一组 x y 参数</li>
<li><code>L</code>: Line To，从光标位置起始绘制一条直线到目标点，接受一组 x y 参数</li>
<li><code>H</code>, <code>V</code>: <code>L</code> 的变形，在水平和竖直方向绘制，只接受一个参数，分别是 x, y </li>
<li><code>Z</code>: Close Path，闭合曲线。只有将曲线闭合之后才能对 Path 进行颜色填充</li>
<li><code>C</code>: Cubic Curve To，绘制三阶 Bezier 曲线，接受三组 x y 参数，分别是两个控制点和一个结束点的位置</li>
<li><code>Q</code>: Quadratic Curve To，绘制二阶 Bezier 曲线，接受两组 x y 参数，分别是一个控制点和一个结束点的位置</li>
<li><code>A</code>: Arc To, 绘制圆弧，这个命令的参数比较复杂，这里就不赘述了。在一些绘制 SVG 的实现中使用 A 可以
绘制出比较完美的圆弧。但是大多绘制 API （包括 Cocoa Drawing）都是使用 Bezier 曲线来拟合圆弧的</li>
</ul>
<p>除了以上的绘制命令，SVG 还提供两个用来续接 SVG 曲线的命令，<code>S</code>和<code>T</code>，分别对应的是<code>C</code>和<code>Q</code>。
接受比<code>C</code>和<code>Q</code>少一组 x y 的参数。这两个命令用于在原来的 SVG 上续接 G2 平滑的曲线
(在衔接点一阶导数连续)。</p>
<p>对于所有这些大写字母组成的命令，其参数都是相对于画布的绝对值。此外还分别有一套与之对应的小写字母组成的命令。
接受相同数量的参数，区别在于所有参数的意义都是增量值。此外需要注意的是，
这些命令都省略了第一个控制点。比如说，对于一条三阶 Bezier 曲线，是需要 4 个控制点才能定义出来的，
而命令<code>C</code>只有三组参数，省略的第一个控制点就是画布光标的当前位置 (也就是<code>M</code>命令指定的点)。</p>
<p>一个 SVG 绘制曲线的例子如下：</p>
<figure class="highlight lang-xml"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" standalone="no"?&gt;</span>
<span class="tag">&lt;<span class="title">svg</span> <span class="attribute">width</span>=<span class="value">"190px"</span> <span class="attribute">height</span>=<span class="value">"160px"</span> <span class="attribute">version</span>=<span class="value">"1.1"</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/2000/svg"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">path</span> <span class="attribute">d</span>=<span class="value">"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80"</span> <span class="attribute">stroke</span>=<span class="value">"black"</span> <span class="attribute">fill</span>=<span class="value">"transparent"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">svg</span>&gt;</span>
</pre></td></tr></table></figure>

<p>直接使用内联 SVG 显示出来就是下面的效果 (需支持 SVG 的浏览器支持才能显示)。</p>
<svg style="border:#eee 1px solid;margin:1em 0;" width="100%" height="160px" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80" stroke="black" fill="transparent"/>
</svg>

<p>接下来回到<code>NSBezierPath</code>这边，阅读
<code>NSBezierPath</code>的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSBezierPathElement" target="_blank">文档</a>
可以发现，其绘制的命令与 SVG 基本上是对应的。
比如说它包含如下一组函数:</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>– (<span class="keyword">void</span>)moveToPoint:(NSPoint)point;
– (<span class="keyword">void</span>)lineToPoint:(NSPoint)point
– (<span class="keyword">void</span>)curveToPoint:(NSPoint)point controlPoint1:(NSPoint)point1 controlPoint2:(NSPoint)point2
– (<span class="keyword">void</span>)closePath
</pre></td></tr></table></figure>

<p>基本上就对应了 SVG 中的<code>M</code>、<code>L</code>、<code>C</code>和<code>Z</code>了。因此，只要能够将<code>NSBezierPath</code>当中储存的信息，
按照这种命令方式取出一个序列，我们就可以将其转化为 SVG 的绘制命令了。</p>
<p>这当然是一件可以实现的事情咯，我们需要做的就是使用下面两个<code>NSBezierPath</code>的对象方法:</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>- (<span class="built_in">NSInteger</span>)elementCount;
- (NSBezierPathElement)elementAtIndex:(<span class="built_in">NSInteger</span>)index associatedPoints:(NSPointArray)points
</pre></td></tr></table></figure>

<p>其中第一个方法可以得到<code>NSBezierPath</code>对象包含的元素个数，而第二个方法提供了取出元素及其相关的控制点的方法。
<code>NSBezierPathElement</code>的定义是：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">typedef</span> <span class="keyword">enum</span> {
   NSMoveToBezierPathElement,
   NSLineToBezierPathElement,
   NSCurveToBezierPathElement,
   NSClosePathBezierPathElement
} NSBezierPathElement;
</pre></td></tr></table></figure>

<p>看到这里就应该明白了，<code>NSBezierPath</code>包含的元素就是控制的命令，而且这些控制命令是 SVG 的控制命令的子集。
因此我们能很方便的将元素分别映射到<code>M</code>、<code>L</code>、<code>C</code>和<code>Z</code>上。</p>
<p>这里需要注意两个地方:</p>
<p>其一，<code>NSPointArray</code>其实是一个指向<code>NSPoint</code>的指针，在<code>NSBezierPath</code>里，一个元素的控制点最多有三个。
因此可以<code>malloc</code>三倍<code>NSPoint</code>的长度的空间，并将指针传入<code>associatedPoints:</code>中，
最后的控制点数据将会借由指针传出。</p>
<p>其二，SVG 的坐标系统和<code>NSBezierPath</code>的坐标系统是不一样的，对于 SVG 来说，原点在左上角，Y 轴朝下。因此需要进行坐标变换。
关于坐标系统的问题<a href="http://io-meter.com/2014/04/24/iconfontr-make-your-nscontrol/">上一篇文章</a>曾经讨论过。</p>
<p>OK，有了这些基础知识，将<code>NSBezierPath</code>曲线转换为 SVG 也就不在话下了。
我的实现代码在<a href="https://github.com/shanzi/iconfontr/blob/master/iconfontr/NSBezierPath%2BSVGPathString.m#L21" target="_blank">这里</a>。
其实有了这些知识，将 SVG 转换为<code>NSBezierPath</code>也基本足够了。要点就在于要把<code>NSBezierPath</code>不支持的一些控制命令，
如<code>Q</code>、<code>H</code>等转换为原来的<code>C</code>和<code>L</code>等。这部分就等以后有机会再详细说明吧。</p>
<h1>NSBezierPath To PNG</h1>
<p>将<code>NSBezierPath</code>转为 PNG 位图输出也很容易，之前在<a href="http://io-meter.com/2014/04/12/iconfontr-1/">这里</a>
里给出了在 View 中绘制图标的代码。得益于<code>Cocoa Drawing</code>框架的良好设计，我们可以直接复用这些代码来绘制到图片甚至 PDF。
绘制到图片的方法有很多。主要包括：</p>
<ul>
<li>先绘制到 View，再从 View 中获得绘制出的位图图像</li>
<li>绘制到一个 Off Screen 的 GraphicContext 再从 GraphicContext 中抽出图像，好处是不需要在屏幕中显示出来</li>
<li>使用<code>NSBitmapImageRep</code>创建一个<code>NSGraphicContext</code>，再在这个 Context 上进行绘制。
和上一种方法的区别是绘制完成后不需要再手动抽取图像。因为图像已经被直接写入对应<code>NSBitmapImageRep</code>了</li>
</ul>
<p>我们使用最后一种方法来绘制，创建一个<code>NSImageRep</code>的函数参数比较复杂，如下所示：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>NSBitmapImageRep *rep = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:<span class="literal">NULL</span>
                                                                  pixelsWide:width
                                                                  pixelsHigh:height
                                                               bitsPerSample:<span class="number">8</span>
                                                             samplesPerPixel:<span class="number">4</span>
                                                                    hasAlpha:<span class="literal">YES</span>
                                                                    isPlanar:<span class="literal">NO</span>
                                                              colorSpaceName:NSCalibratedRGBColorSpace
                                                                 bytesPerRow:<span class="number">0</span>
                                                                bitsPerPixel:<span class="number">32</span>];
</pre></td></tr></table></figure>

<p>接下来详细介绍下这些参数：</p>
<ul>
<li><code>bitmapDataPlanes</code>：指定图片的色彩通道，这个参数可以理解为事先指定一部分空间用来存储产生的像素数据。
如果指定为<code>NULL</code>，函数会通过其他参数来估计空间以分配内存。</li>
<li><code>pixelsWide</code>, <code>pixelsHigh</code>: 这两个参数指定位图的像素宽和高</li>
<li><code>bitsPerSample</code>: 每个<code>Sample</code>的位宽，这里的<code>Sample</code>可以翻译为位图色彩的采样或者分量，对于我们通常用的<code>RGB</code>
色彩空间，红色分量<code>R</code>就是一个<code>Sample</code>。常用的 RGB 颜色值，每个分量的大小最高是<code>255</code>，
这就代表这样一个<code>Sample</code>是一个 8 bits 的数，因此这里我们把位宽设为 8。 <code>NSBitmapImageRep</code>最高支持 16 bits 的位宽</li>
<li><code>hasAlpha</code>: 是否支持透明度</li>
<li><code>isPlanar</code>: Plane 这个概念和 PhotoShop 中的通道类似。如果这个参数为<code>YES</code>，那么色彩值将会分通道储存。
如果参数为<code>NO</code>，那么同一个像素的颜色分量将会紧挨着存储在一起。</li>
<li><code>colorSpaceName</code>: 颜色空间的名称，这里使用的是 RGB 色彩空间，可选的还有 CMYK 色彩空间、灰度色彩空间等。</li>
<li><code>bytesPerRow</code>: 一行像素需要的空间，这个值可以依据<code>bitsPerSample</code>和<code>pixelsWide</code>来计算出来，
但是如果在实际使用中分配的空间不够，那么超出的部分将会被截断。这里我取了零，让程序自己确定。</li>
<li><code>bitsPerPixel</code>: 这个参数其实也可以不指定，它指的是一个像素的位宽，我们前面指定了每个颜色分量的位宽是 8，
每个像素有 4 个分量，那么这个值就应该是 32</li>
</ul>
<p>总体来说，初始化一个<code>NSBitmapImageRep</code>虽然参数很多，但是其中大多是为了保证安全和某些特殊情况而要求指定的。
大概了解这些参数的含义，在必要的时候指定正确的值即可。</p>
<p>创建了<code>NSBitmapImageRep</code>对象之后，可以再从这个对象创建一个<code>NSGraphicContext</code>，并把后者指定为<code>currentContext</code>。
此后就可以像在 View 里一样绘制图形了。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>[NSGraphicsContext saveGraphicsState];
NSGraphicsContext *g = [NSGraphicsContext graphicsContextWithBitmapImageRep:rep];
[NSGraphicsContext setCurrentContext:g];
<span class="comment">// ...</span>
<span class="comment">// drawing code here</span>
<span class="comment">// ...</span>
[NSGraphicsContext restoreGraphicsState];
</pre></td></tr></table></figure>

<p>如何将绘制完成的<code>NSBitmapImageRep</code>转换为 PNG 文件的格式呢？只需要调用<code>Rep</code>对象的入下方法即可。
这个函数返回的是一个可以直接写入文件的<code>NSData</code>类型的对象。
Cocoa 支持的文件格式，除了 PNG 以外，还有 TIFF、JPG 等等。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[rep representationUsingType:NSPNGFileType properties:<span class="literal">nil</span>]
</pre></td></tr></table></figure>

<p>至此，图像的输出功能的核心就完成了。</p>
<h1>自食狗粮，为 Icon Fontr 设计一个图标</h1>
<p>所谓自食狗粮，就是要自己用自己开发的东西来帮助自己开发。具体到这里，
就是要用 IconFontr 导出来的图标为它自己设计一个图标。我从 <a href="http://ionicons.com" target="_blank">ionicons</a>
中选取了四个图标，稍加处理，最后得到了下面的样子</p>
<p><img src="/img/iconfontr/iconfontr256.png" alt="Icon"></p>
<h1>结语</h1>
<p>至此，一个完整功能的 Icon Viewer 就完成啦。其实 IconFontr 还有很多可以改进的地方，
比如说可以有一个批量输出 Icon 的功能，下图是我实现出来的样子:</p>
<p><img src="/img/iconfontr/resolutions.png" alt="Multiple Resolutions"></p>
<p>我还提供了几种预设的分辨率，比如 iOS 的 Tabbar 图标的尺寸等等。
这样就比较方便在 Desktop 和 iOS 应用里使用，也可以用来画原型图等等。</p>
<p>有一些文章 (<a href="http://css-tricks.com/icon-fonts-vs-svg/" target="_blank">1</a>,<a href="http://ianfeather.co.uk/ten-reasons-we-switched-from-an-icon-font-to-svg/" target="_blank">2</a>
认为，我们应该尽量使用内联 SVG 而不是 Icon Font 在网页中显示图标。Icon Fontr 也为这种需求提供了方便。
我为其添加了一个复制 SVG 的功能:</p>
<p><img src="/img/iconfontr/copysvg.png" alt="Copy SVG"></p>
<p>这个系列的文章今天就告一段落了，不过在接下来的时间里，我还会继续维护 Icon Fontr，为其添加各种好用的功能，
各位看官如果有什么需求，欢迎在 Comment 里告诉我。
也欢迎点击<a href="http://cl.ly/2N3i0U0G402k" target="_blank">这里</a>下载一份目前的测试版本试用，并反馈 Bug。
IconFontr 的代码托管在 Github 上，别忘了来<a href="https://github.com/shanzi/iconfontr/" target="_blank">这里</a> Star 一下。</p>
]]></content>
    <summary type="html"><![CDATA[<p>终于到了 Icon Fontr 最重要的一部分了。这一次要把已经读入为<code>NSBezierPath</code>
的 Icon 导出成 SVG 和图片，以便于在桌面和移动应用或者 UI 设计软件当中使用。</p>
]]></summary>
    
      <category term="Bezier Path" scheme="http://io-meter.com/tags/Bezier%20Path/"/>
    
      <category term="SVG" scheme="http://io-meter.com/tags/SVG/"/>
    
      <category term="image" scheme="http://io-meter.com/tags/image/"/>
    
      <category term="export" scheme="http://io-meter.com/tags/export/"/>
    
      <category term="icon fontr" scheme="http://io-meter.com/tags/icon%20fontr/"/>
    
      <category term="osx" scheme="http://io-meter.com/tags/osx/"/>
    
      <category term="xcode" scheme="http://io-meter.com/tags/xcode/"/>
    
      <category term="iconfontr" scheme="http://io-meter.com/categories/iconfontr/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写个 Icon Font Viewer : 叁]]></title>
    <link href="http://io-meter.com/2014/04/24/iconfontr-make-your-nscontrol/"/>
    <id>http://io-meter.com/2014/04/24/iconfontr-make-your-nscontrol/</id>
    <published>2014-04-24T10:48:48.000Z</published>
    <updated>2014-05-28T05:10:14.000Z</updated>
    <content type="html"><![CDATA[<p>紧接着<a href="http://io-meter.com/2014/04/18/seperate-codes-and-zoom-icon/">上一篇文章</a>，
这次来实战一下自定义 NSControl 实现一个选择颜色组合的功能。
此外还会更详细的讲解一下 NSView 的绘制方法。</p>
<a id="more"></a>

<p>首先新建一个 NSControl 子类吧，这里起名叫<code>IFColorPicker</code>，在<code>IFColorPicker.h</code>
里，我们先作如下定义：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>@<span class="class"><span class="keyword">interface</span> <span class="id">IFColorPicker</span> : <span class="id">NSControl</span></span>

@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) NSColor *foregroundColor;
@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) NSColor *backgroundColor;
@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> pickedIndex;

@<span class="keyword">end</span>
</pre></td></tr></table></figure>

<p>注意我们定义了两个只读的属性，<code>foregroundColor</code>和<code>backgroundColor</code>，
当用户在选色器上点击一种颜色组合的时候，在视图里就通过访问这两个属性来获取当前的前景和背景色。
<code>pickedIndex</code>则是一个可读可写的属性，允许从外部写入选择的颜色 Index。</p>
<p>所谓颜色的 Index，是指我们事先指定了一部分颜色组合，按顺序给分配一个 Index，选色是只能从这些组合里选，
Index 其实也是到色彩组合在 Control 中出现顺序。</p>
<h2>选取颜色组合</h2>
<p>怎么样能方便的构造这些颜色组合呢？
对于 NSColor，我们有一些方便的类函数可以快速的构造出想要的颜色。比如<code>[NSColor blackColor]</code>
或<code>[NSColor controlColor]</code>等。<code>NSColor</code>大概定义了数十个这样的函数，但是在此之外的函数就要通过下面的方法来生成了。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>+ (NSColor *)colorWithDeviceRed:(<span class="built_in">CGFloat</span>)red green:(<span class="built_in">CGFloat</span>)green blue:(<span class="built_in">CGFloat</span>)blue alpha:(<span class="built_in">CGFloat</span>)alpha;
</pre></td></tr></table></figure>

<p>的确有一些选色软件 (比如我所用的 <a href="http://colormaker.cescobaz.com/" target="_blank">Color Maker</a>) 是支持直接生成这个代码，
但是仍然过于冗长了，而且调出好看的颜色也不容易，还好我们有一些<code>NSColor</code>的第三方扩展可以解决这个问题:</p>
<ul>
<li><a href="https://github.com/magtory/FPBrandColors" target="_blank">FPBrandColors</a> 提供了返回各种品牌的主颜色的函数，
比如导入头文件之后可以用<code>[NSColor amazon]</code>调用返回亚马逊的 Logo 的色调。</li>
<li><a href="https://github.com/CaptainRedmuff/NSColor-Crayola" target="_blank">NSColor-Crayola</a>
和 <a href="https://github.com/CaptainRedmuff/NSColor-Pantone" target="_blank">NSColor-Pantone</a>
是两套色彩集合，使用和上面基本一致，都是为<code>NSColor</code>添加了诸多类函数用来方便构造颜色。</li>
</ul>
<p>这里我们从 <a href="https://github.com/CaptainRedmuff/NSColor-Crayola" target="_blank">NSColor-Crayola</a> 来选择几种好看的颜色作为背景色。
在<code>IFColorPicker.m</code>里添加下面的函数。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>- (NSColor *)backgroundColorAtIndex:(<span class="built_in">NSInteger</span>)index
{
  <span class="keyword">switch</span> (index) {
    <span class="keyword">case</span> <span class="number">1</span>:
      <span class="keyword">return</span> [NSColor crayolaCeruleanColor];
    <span class="keyword">case</span> <span class="number">2</span>:
      <span class="keyword">return</span> [NSColor crayolaAquamarineColor];
    <span class="keyword">case</span> <span class="number">3</span>:
      <span class="keyword">return</span> [NSColor crayolaBananaColor];
    <span class="keyword">case</span> <span class="number">4</span>:
      <span class="keyword">return</span> [NSColor crayolaBittersweetColor];
    <span class="keyword">case</span> <span class="number">5</span>:
      <span class="keyword">return</span> [NSColor crayolaBurntOrangeColor];
    <span class="keyword">case</span> <span class="number">6</span>:
      <span class="keyword">return</span> [NSColor crayolaFernColor];
    <span class="keyword">case</span> <span class="number">7</span>:
      <span class="keyword">return</span> [NSColor crayolaInchwormColor];
    <span class="keyword">case</span> <span class="number">8</span>:
      <span class="keyword">return</span> [NSColor crayolaRedColor];
    <span class="keyword">default</span>:
      <span class="keyword">return</span> [NSColor whiteColor];
  }
}
</pre></td></tr></table></figure>

<p>对于前景色，只选择黑白两种，因此函数如下所示：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>- (NSColor *)foregroundColorAtIndex:(<span class="built_in">NSInteger</span>)index
{
  <span class="keyword">switch</span> (index) {
    <span class="keyword">case</span> <span class="number">0</span>:
      <span class="keyword">return</span> [NSColor blackColor];
    <span class="keyword">default</span>:
      <span class="keyword">return</span> [NSColor whiteColor];
  }
}
</pre></td></tr></table></figure>

<h2>绘制控件</h2>
<p>这里更详细的介绍一下在 Cocoa 中的图形绘制技术。首先我们知道<code>NSControl</code>其实是<code>NSView</code>
的子类，所以绘制<code>NSControl</code>本质上就是绘制<code>NSView</code>。要自定义<code>NSControl</code>的绘制操作，需要重载<code>drawRect:(NSRect)dirtyRect</code>
方法，这里的<code>dirtyRect</code>不一定是 View 的 Frame，而是系统认为需要重绘的区域。
应该避免完全在这个区域外的绘制工作以提高性能。</p>
<p>绘制所用的 API 其实有两套，一套是 Objective-C 风格的 Cocoa API，一套是 C 风格的 CoreGraphic API。
通常来说，后者的性能更高一点，更底层点。在<code>drawRect:</code>中两种 API 都可以使用。
此外<code>NSView</code>还有另外一种基于<code>CALayer</code>的绘制模式，这种绘制模式是基于<code>Core Animation</code>的。
使用 Layer 进行绘制可以充分利用 <code>Core Animation</code> 和 <code>Quatz</code> 
封装好的<code>OpenGL</code>的性能，特别适合包含动画或模糊等特殊效果或需要频繁重绘的 View。</p>
<p>想要使一个 View 使用<code>CALayer</code>绘制需要先执行<code>[view setWantsLayer:YES]</code>，之后重载下面的函数。
可以看出，这个函数传入了一个<code>CGContextRef</code>指针，绘制就需要针对这个<code>CGContextRef</code>执行，
这同时也意味着绘制<code>CALayer</code>只能使用 C 风格的 CoreGraphic API。重载这个函数后，<code>drawRect:</code>就不会再被调用了。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
</pre></td></tr></table></figure>

<p>因为我们设计的控件并不需要频繁的重绘，也不包含动画，因此采取较为简单的 Cocoa API 来完成。
<code>CoreGraphic</code>风格的 API 以后有机会再谈。</p>
<h3>Drawing Context</h3>
<p>在使用 Cocoa API 进行绘图时，我们要明确一个概念：绘图实际上一定是针对于一个 Context 进行的，
在 Cocoa API 中是<code>NSGraphicContext</code>，CoreGraphic API 中是<code>CGContextRef</code>。
本质上来说，Cocoa API 是对 CoreGraphic 的封装 (这也是它稍慢的原因)，但是在使用 Cocoa API 
的时候，我们一般不需要获取到这个 Context 对象的指针，原因是 Cocoa 会为我们设定好当前的上下文信息。</p>
<p>具体来讲，在每次绘制时会有一个全局的变量指代当前的图形 Context，可以使用<code>[NSGraphicContext currentContext]</code>
函数获取到这个对象。这个对象由 Cocoa 自动指定，开发者不需要了解它具体是什么对象 (它有可能来自屏幕上可显示的 View，
也有可能是一份 PDF 文档或者位图图像等等)。于此同时，Cocoa API 的各个部分也会使用这个 Context 进行各种操作。
比如对于<code>NSColor</code>来说，下面的代码就把当前 Context 的填充颜色设定为黑色：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>NSColor *black = [NSColor black];
[black setFill];
</pre></td></tr></table></figure>

<p><code>NSBezierPath</code>的绘制操作，也是自动应用于当前的 Context 的。譬如，在上面的代码执行后，
执行下面的代码就会填充出一个黑色的矩形：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>NSBezierPath *box = [NSBezierPath bezierPathWithRect:NSMakeRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>)];
[box fill];
</pre></td></tr></table></figure>

<p>这种实现方式看起来比较优雅，但是同时也存在一个问题，那就是绘制必须运行在程序的主线程 (主 RunLoop) 上，
因为在多线程的状态下这个全局的 Context 可能在执行过程中被改变，从而导致绘制混乱。
在辅助线程中进行绘制是可能的，但是必须非常小心，而且不适合使用 Cocoa API。</p>
<h3>Axis and Transform</h3>
<p>接下来需要注意的绘制图形的坐标系统。如果有 Windows 或者 Qt 等图形库的使用经验，
可能知道对于他们来说，窗口和视图的坐标系统是以左上角为原点，Y 轴的指向朝下。
Cocoa 与之不同，他的坐标系是和一般的几何坐标系一致的：原点在左下角，Y 轴正向朝上 (其实 Cocoa
的坐标系统也存在 API 不统一的问题，比如在 iOS 开发中 UIKit 的坐标就是是原点左上
还好 OSX 在最新的 API 下已经统一为左下了)。</p>
<p>我们之前提到过，在绘制的时候存在一个全局的 currentContext。同样，使用<code>NSAffineTransform</code>
进行坐标变换的时候也是针对这个 currentContext 进行的。需要注意的是，<code>NSAffineTransform</code> 
的坐标变换操作需要通过调用<code>concat</code>方法才会作用于 Context，而且这种作用是累加的。
且看下面的代码：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>NSAffineTransform *transform = [NSAffineTransform transform];
[transform translateXBy: <span class="number">10.0</span> YBy: <span class="number">0.0</span>];

[transform concat] <span class="comment">// the first time</span>
[transform concat] <span class="comment">// the second time</span>
</pre></td></tr></table></figure>

<p>上文中，Context 的坐标系被向右移动了两次，每次 10.0 个单位，所以最后坐标系被移动了 20.0 个单位。
另外需要注意的是，在移动坐标系的时候原来已经被绘制在 Context 上的图形并不会被影响。，</p>
<p>如果在绘制中需要使用坐标系变换，为了保险起见应该在变换之前保存 Context 的变换矩阵状态，
在绘制完之后再恢复。如下面的示例代码所示：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>[NSGraphicsContext saveGraphicsState];
<span class="comment">// transforming and drawing code</span>
<span class="comment">// ...</span>
[NSGraphicsContext restoreGraphicsState];
</pre></td></tr></table></figure>

<p>了解完以上的知识，绘制 UIControl 就不成问题了。在我的实现中，只生成了一个 BezierPath 对象，
然后通过不断的 Transform 和改变 Context 的当前填充颜色来绘制出多个选色点出来。具体的代码见
<a href="https://github.com/shanzi/iconfontr/blob/master/iconfontr/IFColorPicker.m#L44" target="_blank">这里</a>。</p>
<h2>鼠标点击的处理</h2>
<p>接下来要处理鼠标点击，这里的需求是鼠标左键应用前景和背景色、右键点击互换前景色和背景色。</p>
<p>之前的文章已经提到过，处理鼠标点击可以重载<code>mouseUp:</code>和<code>rightMouseUp:</code>函数。
接下来还有一项重要的任务就是确定用户点击的到底是哪个颜色组合。</p>
<p>简单来说，就是要通过用户点击的位置来计算用户选择的 Index。计算 Index 并不复杂，
因为在绘制的时候我们实际上是计算过一次选色点所在的位置，按照相同的原理计算一下偏移位置就可以了。
这里要强调的是鼠标点击位置的获取。</p>
<p><code>mouseUp:</code>和<code>rightMouseUp:</code>方法都有一个<code>NSEvent</code>类型的参数，对于鼠标事件来讲，
我们可以通过下面的函数获得鼠标相对于所在 View 的坐标。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>NSPoint locationInWindow = theEvent<span class="variable">.locationInWindow</span>;
NSPoint locationInView = [theView convertPoint:locationInWindow fromView:<span class="literal">nil</span>];
</pre></td></tr></table></figure>

<p><code>locationInWindow</code>属性顾名思义，就是鼠标点击在窗口中的位置，
可以用用<code>NSView</code>的<code>convertPoint: fromView:</code>方法把它坐标变换自己的坐标空间中，
<code>NSView</code>其实有一系列类似的方法，不但可以变换点的坐标，还可以变换矩形。
同时也存在<code>fromView:</code>和<code>toView:</code>两套方法。这两套方法中，如果 From 或 To
的 View 是 nil 的话，计算的是相对 Window 的变换。</p>
<p>坐标变换之后就可以计算出用户点击的是哪种颜色组合了。</p>
<h2>发送 Action</h2>
<p>一个好的 NSControl 还要能够发送事件，最好还能够用 Interface Builder 来绑定事件。
发送一个事件的调用是：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// IFColorPicker.m</span>
[<span class="keyword">self</span> sendAction:<span class="keyword">self</span><span class="variable">.action</span> to:<span class="keyword">self</span><span class="variable">.target</span>];
</pre></td></tr></table></figure>

<p><code>self.action</code>和<code>self.target</code>都是<code>NSControl</code>定义的属性，IB 在绑定 Action 的时候也会设定这些值。
而我们可以用<code>IBAction</code>定义一个可以在 IB 里连接的回调接口，在<code>IFDocumentWindowController.h</code>
中加入下面的定义
(函数实现见<a href="https://github.com/shanzi/iconfontr/blob/master/iconfontr/IFDocumentWindowController.m#L53" target="_blank">这里</a>)：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>- (<span class="keyword">IBAction</span>)changeColor:(<span class="keyword">id</span>)sender;
</pre></td></tr></table></figure>

<p>这时在 Interface Builder 中绑定好后运行，却会发现并没有起到效果。
其实是因为<code>NSControl</code>默认认为自己内部有一个<code>NSActionCell</code>的，它的<code>action</code>以及<code>target</code>
属性也是映射到自己的<code>NSActionCell</code>上的。这里我们并没有添加<code>NSActionCell</code>
因此这两个属性将总是<code>nil</code>。</p>
<p>我们的控件没有必要定义自己的 ActionCell，为了能让代码正常工作，只好复写这两个属性，
自己定义两个变量来保存他们。</p>
<h2>总结</h2>
<p>OK，我们的 ColorPicker 控件就这么写好了，修改下图标绘制的代码我们就可以改变图标的预览颜色了。
鼠标左键和右键效果就如下所示，还是蛮不错的吧。</p>
<p><img src="/img/iconfontr/leftmouse-lightgreen.png" alt="Left Mouse, Light Green"></p>
<p><img src="/img/iconfontr/rightmouse-darkgreen.png" alt="Right Mouse, Dark Green"></p>
<p>下一篇文章，就来到我们整个项目的最重点了，我们要实现 Icon 导出图片和 SVG 的功能，
最后还要“自食狗粮”，用自己导出的素材为 IconFontr 制作一个图标，可不要错过哦。</p>
]]></content>
    <summary type="html"><![CDATA[<p>紧接着<a href="http://io-meter.com/2014/04/18/seperate-codes-and-zoom-icon/">上一篇文章</a>，
这次来实战一下自定义 NSControl 实现一个选择颜色组合的功能。
此外还会更详细的讲解一下 NSView 的绘制方法。</p>
]]></summary>
    
      <category term="iconfontr" scheme="http://io-meter.com/tags/iconfontr/"/>
    
      <category term="NSControl" scheme="http://io-meter.com/tags/NSControl/"/>
    
      <category term="cocoa" scheme="http://io-meter.com/tags/cocoa/"/>
    
      <category term="drawing" scheme="http://io-meter.com/tags/drawing/"/>
    
      <category term="osx" scheme="http://io-meter.com/tags/osx/"/>
    
      <category term="iconfontr" scheme="http://io-meter.com/categories/iconfontr/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pencil review and tips]]></title>
    <link href="http://io-meter.com/2014/04/22/review-of-pencil/"/>
    <id>http://io-meter.com/2014/04/22/review-of-pencil/</id>
    <published>2014-04-22T11:15:39.000Z</published>
    <updated>2014-04-22T13:16:30.000Z</updated>
    <content type="html"><![CDATA[<p>Pencil by 53 也不是新鲜事物了，自去年年底发布至今好几个月过去，
这几日我才刚刚入手一只。这支笔在网上可以说是褒贬不一。这里也谈一下我的看法，另附使用几天的一点建议。</p>
<a id="more"></a>

<p><img src="/img/posts/pencil.jpg" alt="Pencil by 53"></p>
<h2>Review</h2>
<p>如果你还不知道 Pencil 是什么，可以在<a href="http://www.fiftythree.com/pencil" target="_blank">这里</a>了解下。
它是配合 FiftyThree 自家先前推出的 iPad 绘图软件 <a href="http://www.fiftythree.com/paper" target="_blank">Paper</a> 使用的一杆电容式绘图笔。</p>
<p>闲话少说，下面列出 Pencil 的优缺点以供各位看官权衡:</p>
<p>优点</p>
<ul>
<li>设计较为精致，手感不错</li>
<li>笔尖灵敏度让人满意，不需要加力才能识别</li>
<li>性价比较高，是带蓝牙功能的绘图笔中最便宜的</li>
<li>相匹配的软件 Paper 是 iPad 下表现较为出色的绘图软件</li>
<li>带有防止手掌误触和反向橡皮擦功能</li>
</ul>
<p>缺点</p>
<ul>
<li>橡皮擦的识别率可能有问题</li>
<li>笔尖在绘图时也有误识别的现象，不过出现频率较低</li>
<li>不带感压功能</li>
<li>笔头较大，且是软头，不太适合精确作图和写字</li>
</ul>
<p>总体来看，Paper 和针对其开发的 Pencil 绘图笔都是面向草图和原型图绘制的，
并非专业绘图工具，也正因为如此，Pencil 达不到专业绘图所需的精度和感压功能。
然而比较要命的是，它的橡皮擦和笔尖识别也偶有问题。在我这里比较严重的是橡皮擦的识别，
很多时候怎么调整角度和力量都识别不出，实在是令人恼火的一件事情。</p>
<p>还好 Pencil 附送了第二套笔头和橡皮擦，经测试第二套橡皮擦换上之后橡皮的识别就相当灵敏了。
在绘图的过程中反过来当做橡皮擦使用的功能在使用几次之后就会变得非常自然。
另外一个被反映比较多的问题是笔头被识别成手指，以及手掌误触被识别为晕染的问题。
在我这里这两种情况出现的概率还是比较低的，然而可以看出总体上来看 Pencil 的识别性能并不是很好。
下文的 Tips 章节我会稍微介绍一下解决这两种问题的方法。</p>
<p>将 Pencil 用于其他 iPad 上的绘图软件也是可以的，但是不支持手掌识别和橡皮擦的功能，
这支笔也失去了它的意义，毕竟相同灵敏度不带蓝牙功能的 Stylus 也不乏专业好用的产品。
另外还需要注意的一点是：iPad 的多点手势功能其实会跟 Paper 产生冲突，在手掌和绘图笔都在绘制的情况下，
有时会被识别成五个手指抓合退出应用的手势。</p>
<p>此外要再次提醒大家，Paper 并不适合作为专业绘图之用，他提供的画笔种类较少，也不支持图层功能，
在有些时候会显得比较纠结。</p>
<h2>Tips and Tweak</h2>
<p>我的第一个建议是关闭手指晕染功能，这样可以大大减少笔头识别出现问题的情况，也防止因为手掌接触把图画变模糊了的问题。
在 Paper 主页面的右上角点击 53 的 logo 可以进入偏好设置页面，在这里可以找到 Pencil 的设置选项。</p>
<p><img src="/img/posts/paper-settings.png" alt="Paper Settings"></p>
<p>在 Pencil 的设置选项中对 Pencil 进行配对之后就可以关闭手指的晕染功能了。如下图所示，将 Finger 选项设为 Nothing。</p>
<p><img src="/img/posts/pencil-settings.png" alt="Pencil Settings"></p>
<p>此外，针对笔尖和橡皮识别的问题，除了更换笔头和橡皮外，还可以在上面的 Trouble Shooting 选项下对笔尖和橡皮进行测试。
我的经验是，笔尖的识别一般没有问题，对于橡皮，往往加大力度是没有效果的，应该通过变换角度的方法来解决问题。
使用 Trouble Shooting
测试笔尖和橡皮的界面如下图所示。使用笔头和橡皮时，识别出来时对应的选项右边的圆点将会变成实心的。可以在这里不断测试
橡皮合适的使用角度。</p>
<p><img src="/img/posts/troubleshooting.png" alt="Trouble Shooting"></p>
<p>另外对于橡皮来说，通过清水冲洗之后用纸巾擦干的方法增加潮湿度，可以一定程度地提高灵敏度。</p>
<h2>总结</h2>
<p>综上所述，Pencil 是一个相对不是很完美的电容绘图笔，然而其性价比还是相当好的。适合于配合 Paper
做原型绘制和草图设计。经过一段时间的熟悉和设置调整之后使用会变得流畅和自然，出现等问题也能够很大程度缓解。
最后附上一张本人的速写拙作，同时推荐一个来自 MadeMistakes.com 的
Paper <a href="http://mademistakes.com/mastering-paper/" target="_blank">绘图教程</a>。</p>
<p><img src="/img/posts/mouse-sketch.jpg" alt="mouse"></p>
]]></content>
    <summary type="html"><![CDATA[<p>Pencil by 53 也不是新鲜事物了，自去年年底发布至今好几个月过去，
这几日我才刚刚入手一只。这支笔在网上可以说是褒贬不一。这里也谈一下我的看法，另附使用几天的一点建议。</p>
]]></summary>
    
      <category term="iPad" scheme="http://io-meter.com/tags/iPad/"/>
    
      <category term="pencil" scheme="http://io-meter.com/tags/pencil/"/>
    
      <category term="paper" scheme="http://io-meter.com/tags/paper/"/>
    
      <category term="stylus" scheme="http://io-meter.com/tags/stylus/"/>
    
      <category term="drawing" scheme="http://io-meter.com/tags/drawing/"/>
    
      <category term="tips" scheme="http://io-meter.com/tags/tips/"/>
    
      <category term="review" scheme="http://io-meter.com/tags/review/"/>
    
      <category term="review" scheme="http://io-meter.com/categories/review/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写个 Icon Font Viewer : 贰]]></title>
    <link href="http://io-meter.com/2014/04/18/seperate-codes-and-zoom-icon/"/>
    <id>http://io-meter.com/2014/04/18/seperate-codes-and-zoom-icon/</id>
    <published>2014-04-18T15:21:46.000Z</published>
    <updated>2014-04-19T04:25:03.000Z</updated>
    <content type="html"><![CDATA[<p>这次我们先来做一些代码拆分，将窗口管理的代码从<code>IFDocument</code>当中剥离出来。随后将会实现
Icon 的缩放功能。
完整代码可以在<a href="https://github.com/shanzi/iconfontr/tree/R02_scale_and_color" target="_blank">这里</a>找到。</p>
<a id="more"></a>

<p>这次的技术要点有：</p>
<ul>
<li>在<code>NSDocument</code>中切换为使用<code>WindowController</code>来管理窗体</li>
<li><code>NSScrollView</code> 的 ZOOM 功能的使用，以及<code>JNWCollectionView</code>缩放问题的处理</li>
<li>键盘事件的侦听</li>
</ul>
<h2>切换到 WindowController</h2>
<p>对于初学者来说，理解 Xcode 当中的 UI 设计器与程序代码的交互可能需要一点时间。Xcode 4
之前，现在的窗口设计器部分其实是独立于 Xcode 的一个应用，名叫
Interface Builder(<a href="wikipedia.org/wiki/Interface_Builder">Wiki</a>，简称 IB)。
现在说起来可能有点不可思议，不过 IB 最初是的确是开发出来写 Lisp 的。</p>
<p><a href="io-meter.com/2014/04/12/iconfontr-1/">上一篇文章</a>介绍了使用<code>NSDocument</code>来实现简单的
Icon Font 预览，当时窗口管理的代码是写在<code>IFDocument.m</code>当中的。 这样做有一个坏处，
如果窗口控制代码比较复杂，在<code>IFDocument.m</code>类当中的代码就会变得不好维护。
所以我们需要一个独立的<code>WindowController</code>来控制窗口。</p>
<p>在<code>File&gt;new&gt;Files..</code>菜单中选择新建一个 Objective-C Class，设置如下图所示</p>
<p><img src="/img/iconfontr/IFDocumentWindowController.png" alt="IFDocumentWindowController"></p>
<p>这里如果勾选 Also create XIB file for user interface 的话，Xcode 会自动帮你新建并设置好 XIB 文件。
我们想要复用原来的<code>IFDocument.xib</code>，因此取消勾选这个选项。</p>
<p>接下来重新调整 XIB 文件和代码关系，<code>IFDocument.m</code>中存在这么一个函数:</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (<span class="built_in">NSString</span> *)windowNibName
{
  <span class="keyword">return</span> @<span class="string">"IFDocument"</span>;
}
</pre></td></tr></table></figure>

<p>这个函数指定了当前的<code>IFDocument</code>类对应的 UI 设计文件 (也就是<code>IFDocument.xib</code>)。
我们把这个函数删除掉以切断<code>IFDocument.m</code>与<code>IFDocument.xib</code>的关系。</p>
<p>将<code>IFDocument.xib</code>重命名为<code>IFDocumentWindow.xib</code>。点击进入设计器之后，我们先把这个 XIB
文件分配给刚刚新建立的<code>IFDocumentWindowController</code>。如下图所示，在左边一栏点选<code>File&#39;s Owner</code>
后右边的参数面板中作如下调整:</p>
<p><img src="/img/iconfontr/set-files-owner.png" alt="Set File&#39;s Owner"></p>
<p>我们知道，在右边参数面板中的<code>Custom Class</code>选项，就是指定 IB 中的对象与代码中定义的类的对应关系的。
我们在这里改变了<code>File&#39;s Owner</code>对应的类，就相当于在这个 XIB 文件和之前建立的
<code>IFDocumentWindowController</code>类之间建立了一个关系。</p>
<p>右键单击<code>File&#39;s Owner</code>弹出的浮动窗口里有一栏叫做 outlets。这些 outlets 就是在代码中定义的用以和 XIB 中对象对接的接口。
在此需确保<code>Window</code>这一栏已经和设计器中的窗口连接在一起了
(如果没有，从右边的圆点处，拖动到窗口上释放以绑定连接)。如下图所示。</p>
<p><img src="/img/iconfontr/outlets.png" alt="Outlets"></p>
<p>建立了连接之后，我们在<code>IFDocumentWindowController.m</code>当中就可以用<code>self.window</code>来获得 XIB 当中的窗口了，
这个接口是在<code>IFDocumentWindowController</code>的父类<code>NSWindowController</code>当中定义的。
我们在<code>IFDocumentWindowController.h</code>中用下面代码来添加一个新的接口。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>@<span class="class"><span class="keyword">interface</span> <span class="id">IFDocumentWindowController</span> : <span class="id">NSWindowController</span></span>

@<span class="keyword">property</span>(<span class="keyword">assign</span>) <span class="keyword">IBOutlet</span> JNWCollectionView *collectionView;

@<span class="keyword">end</span>
</pre></td></tr></table></figure>

<p>注意，在对象的类型前有一个<code>IBOutlet</code>关键字，这个关键字就是声明这个指针可以绑定到 IB 中的一个对象
(IBOutlet 中的 IB 当然代表 Interface Builder 咯)。在代码中声明了 Outlet 之后，我们可以在 IB 中把 <code>collectionView</code> 
这个接口和 XIB 中的 collectionView 对象连接起来了。</p>
<p>最后我们还要让 WindowController 知道自己对应的 XIB 文件是谁，以便于在
初始化的时候加载进来。在<code>IFDocumentWindowController.m</code> 中添加如下一个函数:</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (<span class="built_in">NSString</span> *)windowNibName
{
  <span class="keyword">return</span> @<span class="string">"IFDocumentWindow"</span>;
}
</pre></td></tr></table></figure>

<p>接下来清理一下原来的<code>IFDocument.m</code>并把窗口控制相关的代码迁移到<code>IFDocumentWindowController</code>当中。</p>
<p>怎么样把原来的<code>IFDocument</code>和新的 <code>IFDocumentWindowController</code> 联系起来呢？在<code>makeWindowControllers</code>
函数中创建<code>IFDocumentWindowController</code>的一个实例并调用<code>addWindowController:</code>函数就可以了。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>) makeWindowControllers
{
  IFDocumentWindowController *windowController = [[IFDocumentWindowController alloc] init];
  [(IFDocumentWindowController *)windowController setGlyphPathes:_glyphPathes];
  [<span class="keyword">self</span> addWindowController:windowController];
}
</pre></td></tr></table></figure>

<p>通过上面的步骤，可以看出了 XIB 和代码配合的的几个要点：</p>
<ul>
<li>File&#39;s Owner 的类将 XIB 和一个 Controller 联系起来</li>
<li>在代码中可以用 IBOutlet 来定义一个接口，在运行时这个接口将会指向 XIB 中的一个对象</li>
<li>在 Files&#39;s Owner 对应的 Controller 可以通过一个函数来指定对应 XIB 文件的名字</li>
<li>之后的文章还会介绍使用 IBAction 关键字来接收一个事件回调</li>
</ul>
<h2>实现缩放功能</h2>
<p>老实说，缩放功能的实现比预计的要麻烦很多。本来以为作为<code>NSScroller</code>子类的<code>JNWCollectionView</code>
能够很方便的开启缩放功能，结果却因在缩放过程中其会对子视图进行排版而导致各种 Bug，
经过多次尝试，终于还是找到了一个解决方案。</p>
<p>在<code>JNWCollectionView</code>上实现缩放的要点主要有：</p>
<ul>
<li>在缩放进行时，必须要禁止<code>JNWCollectionViewLayout</code>更新 layout 布局，否则将会出现卡顿</li>
<li>缩放结束后要调整<code>JNWCollectionViewLayout</code>的<code>documentView</code>大小，否则将无法横向滚动</li>
<li>如果要显示横向滚动条，需要修改<code>JNWCollectionViewLayout</code>的<code>ScrollDirection</code></li>
</ul>
<p>首先创建几个子类：</p>
<p><img src="/img/iconfontr/new-subclasses.png" alt="New Subclasses"></p>
<p>其中<code>IFMagnifyCollectionView</code>是<code>JNWCollectionView</code>的子类，<code>IFCollectionGridLayout</code>
是<code>JNWCollectionGridLayout</code>的子类。为了在缩放过程中禁止<code>IFCollectionGridLayout</code>刷新排版，
给他添加一个新的属性并重载 <code>shouldInvalidateLayoutForBoundsChange</code>方法，
此外还要复写<code>ScrollDirection</code>方法来显示横向滚动条：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="comment">// JNWCollectionGridLayout.h</span>

<span class="preprocessor">#import <span class="title">"JNWCollectionViewGridLayout.h"</span></span>

@<span class="class"><span class="keyword">interface</span> <span class="id">IFCollectionGridLayout</span> : <span class="id">JNWCollectionViewGridLayout</span></span>
@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> allowsLiveLayout;
@<span class="keyword">end</span>


<span class="comment">// JNWCollectionGridLayout.m</span>

@<span class="class"><span class="keyword">implementation</span> <span class="id">IFCollectionGridLayout</span></span>

- (<span class="built_in">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class="built_in">CGRect</span>)newBounds
{
  <span class="comment">// Forbid layout update when zooming</span>
  <span class="comment">// _allowsLiveLayout will be set to NO when zooming</span>
  <span class="keyword">return</span> _allowsLiveLayout;
}

- (JNWCollectionViewScrollDirection)scrollDirection
{
  <span class="comment">// scroll in both vertical and horizontal direction</span>
  <span class="keyword">return</span> JNWCollectionViewScrollDirectionBoth;
}

@<span class="keyword">end</span>
</pre></td></tr></table></figure>

<p><code>IFMagnifyCollectionView</code>的父类<code>NSScrollView</code>其实已经提供了缩放的支持，
所以并不需要自己捕捉多点触摸的事件。开启缩放功能使用下面的函数就可以了。最关键的一句就是
<code>self.allowsMagnification=YES;</code>，代表着允许使用缩放。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)invokeMagnification
{
  <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.allowsMagnification</span>) {
    <span class="keyword">self</span><span class="variable">.allowsMagnification</span> = <span class="literal">YES</span>;  <span class="comment">// turn on magnification</span>
    <span class="keyword">self</span><span class="variable">.magnification</span> = <span class="number">1.0</span>;
    <span class="keyword">self</span><span class="variable">.maxMagnification</span> = <span class="number">3</span>;
    <span class="keyword">self</span><span class="variable">.minMagnification</span> = <span class="number">1.0</span>;
    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span>
                                             <span class="keyword">selector</span>:@<span class="keyword">selector</span>(liveMagnifyWillStart:)
                                                 name:NSScrollViewWillStartLiveMagnifyNotification
                                               object:<span class="keyword">self</span>];
    
    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span>
                                             <span class="keyword">selector</span>:@<span class="keyword">selector</span>(liveMagnifyDidEnd:)
                                                 name:NSScrollViewDidEndLiveMagnifyNotification
                                               object:<span class="keyword">self</span>];
  }
}
</pre></td></tr></table></figure>

<p>在函数的最后用<code>NSNotificationCenter</code>添加了两个消息侦听，这两个消息分别在缩放开始和结束时发出。
侦听这两个消息的目的就是为了在缩放开始和结束的时候设定<code>IFCollectionGridLayout</code>的<code>allowsLiveLayout</code>
属性，以实现在缩放时禁止重新布局的需求。</p>
<p><code>liveMagnifyWillStart:</code>和<code>liveMagnifyDidEnd:</code>这两个回调函数的内容这里就略去不表了，
具体实现看
<a href="https://github.com/shanzi/iconfontr/blob/R02_scale_and_color/iconfontr/IFMagnifyCollectionView.m" target="_blank">IFMagnifyCollectionView</a>。</p>
<p>接下来我们解决缩放后的滚动问题，不同于 iOS 上的<code>UIScrollView</code>，<code>NSScrollView</code>没有<code>contentSize</code>属性。
实际上，<code>NSScrollView</code>包含一个子视图<code>documentView</code>，所有<code>NSScrollView</code>显示的 Subviews
都放置在<code>documentView</code>中。而<code>documentView</code>的<code>frame</code>属性指定了想要显示的内容的<em>完整</em>大小，
<code>NSScrollView</code>的<code>documentVisbleRect</code>属性指定了想要内容<em>实际显示</em>的范围。</p>
<p>想要实现正确的滚动效果，就要正确的设置<code>documentView.frame</code>和<code>documentViewVisibleRect</code>两个属性。
在 Zoom 的过程中，<code>documentView</code>的大小其实是不变的，之所以我们可以看到内容被放大了，是因为对
<code>documentView</code>发送了<code>scaleUnitSquareToSize:</code>消息，而<code>documentViewVisibleRect</code>也同时被缩小了。</p>
<p>现在的问题是，缩放结束之后<code>JNWCollectionView</code>会根据可视范围的大小重新调整<code>documentView</code>的大小，
<code>documetView</code>的宽度将总是和<code>documventVisibleRect</code>一样，这样横向滚动就失效了。
一个最简单的解决方案是重载<code>documentVisibleRect</code>函数，不让它的宽度随着放大而相对变小。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>- (NSRect)documentVisibleRect
{
  NSRect visibleRect = [<span class="keyword">super</span> documentVisibleRect];
  visibleRect<span class="variable">.origin</span><span class="variable">.x</span> = <span class="number">0</span>;
  visibleRect<span class="variable">.size</span><span class="variable">.width</span> *= <span class="keyword">self</span><span class="variable">.magnification</span>;
  <span class="keyword">return</span> visibleRect;
}
</pre></td></tr></table></figure>

<p>这样做牺牲了一定的性能，因为<code>JNWCollectionView</code>是根据<code>documentVisibleRect</code>来决定一个子视图是否可见，
据此移除看不见的 Subviews 并节约资源。最终还是是要修改<code>JNWCollectionView</code>的源码才能达到最好的效果，
这里也不详细介绍了。</p>
<p>为了方便使用，还可以添加键盘的事件侦听，只要设定<code>IFCollectionView</code>的<code>magnification</code>属性的大小就行了:</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="preprocessor">#define kEqualsKeyCode 24</span>
<span class="preprocessor">#define kMinusKeyCode 27</span>

- (<span class="keyword">void</span>)keyDown:(NSEvent *)theEvent
{
  <span class="comment">// cancel the sound played after keydown</span>
}

- (<span class="keyword">void</span>)keyUp:(NSEvent *)theEvent
{
  <span class="keyword">if</span> ([theEvent keyCode]==kEqualsKeyCode) {
    <span class="keyword">self</span><span class="variable">.magnification</span> += <span class="number">0.2</span>;
  }
  <span class="keyword">else</span> <span class="keyword">if</span>([theEvent keyCode]==kMinusKeyCode) {
    <span class="keyword">self</span><span class="variable">.magnification</span> -= <span class="number">0.2</span>;
  }
}
</pre></td></tr></table></figure>

<p>想要捕捉键盘事件，只要重载<code>keyUp</code>、<code>keyDown</code>这样的函数就行了。包括鼠标、键盘和触摸事件在内的回调函数最初都定义在
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html" target="_blank">NSResponder</a>
中，在所有的<code>NSResponder</code>的子类中都可以使用。</p>
<p>对于键盘事件，<code>[theEvent keyCode]</code>返回的是一个设备无关的虚拟键值，符号<code>-</code>的值是<code>27</code>，符号<code>=</code>(也就是<code>+</code>所在的键)
的值是<code>24</code>。这里需要复写一下<code>keyDown</code>函数，避免按键时出现提示音。</p>
<p>现在就可以在触摸板上用 Spin 手势和键盘上的加减符号实现放大缩小了，效果如下图所示：</p>
<p><img src="/img/iconfontr/zoom-result.png" alt="Zoom Result"></p>
<h2>一点总结和预告</h2>
<p>这次的文章主要记录了拆分代码和实现缩放的功能，其中详细介绍了 XIB 和代码之间的关系以及配合的问题，
感觉讲解的还不是很清楚，如果各位看官有什么问题，欢迎直接询问我。</p>
<p>在上面的结果图上可以看到其实已经实现了选择预览颜色的功能，不过限于篇幅原因还是决定留到下一篇文章再讲。
下次将会详细介绍一下如何编写一个自定义的 NSControl，附带图形绘制更详细的介绍以及用<code>IBAction</code>
来实现事件的回调的方法。</p>
]]></content>
    <summary type="html"><![CDATA[<p>这次我们先来做一些代码拆分，将窗口管理的代码从<code>IFDocument</code>当中剥离出来。随后将会实现
Icon 的缩放功能。
完整代码可以在<a href="https://github.com/shanzi/iconfontr/tree/R02_scale_and_color" target="_blank">这里</a>找到。</p>
]]></summary>
    
      <category term="OSX" scheme="http://io-meter.com/tags/OSX/"/>
    
      <category term="Objective-C" scheme="http://io-meter.com/tags/Objective-C/"/>
    
      <category term="icon font" scheme="http://io-meter.com/tags/icon%20font/"/>
    
      <category term="iconfontr" scheme="http://io-meter.com/tags/iconfontr/"/>
    
      <category term="NSControl" scheme="http://io-meter.com/tags/NSControl/"/>
    
      <category term="Cocoa" scheme="http://io-meter.com/tags/Cocoa/"/>
    
      <category term="Interface Builder" scheme="http://io-meter.com/tags/Interface%20Builder/"/>
    
      <category term="Xcode" scheme="http://io-meter.com/tags/Xcode/"/>
    
      <category term="iconfontr" scheme="http://io-meter.com/categories/iconfontr/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写个 Icon Font Viewer : 初]]></title>
    <link href="http://io-meter.com/2014/04/12/iconfontr-1/"/>
    <id>http://io-meter.com/2014/04/12/iconfontr-1/</id>
    <published>2014-04-12T13:03:28.000Z</published>
    <updated>2014-04-18T16:42:59.000Z</updated>
    <content type="html"><![CDATA[<p>得益于现代浏览器的普及，使用以 Web Font 作为基础的 Icon Font 来显示图标越来越流行了。
Icon Font 本身作为一种矢量素材，具有很多优点，比如可以在不同缩放和 Retina 显示屏上获得很好的显示效果，
可以用 CSS 指定颜色等。</p>
<a id="more"></a>

<p>现在比较流行的 Icon Fonts 包括 <a href="http://fontawesome.io" target="_blank">Fontawesome</a>、
<a href="http://zurb.com/playground/foundation-icon-fonts-3" target="_blank">Foundation Icon</a>、
社交类的 <a href="http://zocial.smcllns.com/" target="_blank">Zocial</a>等。
当然还有我最喜欢的无论数量还是质量都是上上乘的 <a href="http://ionicons.com/" target="_blank">ionicons</a>。</p>
<p>在线制作 Icon Font 的网站，比如 <a href="http://fontastic.me" target="_blank">Fontastic</a>、<a href="http://icomoon.io/" target="_blank">IconMoon</a>
可算是层出不穷。将 Icon Font 用于 iOS 开发的框架 <a href="https://github.com/PrideChung/FontAwesomeKit" target="_blank">FontAwesomeKit</a>
也值得关注。</p>
<p>总结了这么多资源，接下来进入正题。为了方便将已有 Icon Font 当做参考来设计风格统一的自定义图标，
自然需要一个方便的将 Icon Font 中的 Glyphs 导出成图片或者 SVG 的工具。
这个系列的文章就来记录一下如何编写一个 OSX 下的 Icon Font 浏览器和导出器。</p>
<p>第一篇的内容是：浏览功能的实现。项目代码托管在<a href="https://github.com/shanzi/iconfontr/" target="_blank">这里</a>。</p>
<h2>建立项目</h2>
<p>OK，在 Xcode 里建立一个 cocoa 应用先。在新建项目的时候选中 Document-Based Application 的选项，
以方便实现打开文件的功能。然后把 Document Extension 设为 ttf。如下图所示，我给这个 App 起名叫 Iconfontr。</p>
<p><img src="/img/iconfontr/document-base.png" alt="create project"></p>
<p>在开始编写代码之前先对项目做一个设置：在项目 Target 的 Info 标签页下的 Document Type
设置为 Viewer (因为我们只需要浏览而不需要编辑 Icon Font)。</p>
<h2>读入 Font</h2>
<p>接下来是把 TTF 文件读入的工作，因为 <code>NSFont</code> 类并没有提供读取任意路径字体的方法 (只能读取已安装字体)，我们需要先将字体
读入为 <code>CGFontRef</code> 类型，再经过<code>CTFontRef</code>转换回<code>NSFont</code>。</p>
<p>在 IFDocument.h 中为 IFDocument 类添加一个属性。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// IFDocument.h</span>
@<span class="keyword">property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) NSFont *font;
</pre></td></tr></table></figure>

<p>重载 IFDocument 读入文件的函数：</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>- (<span class="built_in">BOOL</span>)readFromURL:(<span class="built_in">NSURL</span> *)url ofType:(<span class="built_in">NSString</span> *)typeName error:(<span class="built_in">NSError</span> *__autoreleasing *)outError
{
  <span class="comment">// read font from url</span>
  CFURLRef theCFURL = (__bridge CFURLRef)url;
  CGDataProviderRef dataProvider = CGDataProviderCreateWithURL(theCFURL);
  CGFontRef theCGFont = CGFontCreateWithDataProvider(dataProvider);

  <span class="keyword">if</span> (theCGFont == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NO</span>;

  <span class="comment">// cast CGFont back to NSFont</span>
  CTFontRef theCTFont = CTFontCreateWithGraphicsFont(theCGFont, <span class="number">16</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);
  _font = (__bridge NSFont *) theCTFont;
  
  <span class="keyword">return</span> <span class="literal">YES</span>;
}
</pre></td></tr></table></figure>

<p>怎么样获取某个字体文件包含的所有 Glyphs 呢？<code>NSFont</code>没有提供简单直接的函数，因此要自己想办法解决这个问题。
首先可以通过 <code>[font numberOfGlyphs]</code> 获得到字体包含的 Glyphs 总数，而<code>NSGlyph</code>本身是整数类型，因此我们尝试使 
<code>glyph</code>的值从<code>1</code>开始向后遍历，直到取出所有的 Glyphs 为止。</p>
<p>同时我们还可以用函数<code>[font boundingRectForGlyph:glyph]</code>获得到 Glyph 的 <code>boundingRect</code>，因此可以通过检测一个
Glyph 的<code>boundingRect</code>是不是空来检查这个 Glyphs 是否存在。在上面的函数中<code>return YES</code>之前的地方加入如下代码。
其中<code>_glyphPathArray</code>是一个<code>NSMutableArray</code>。 </p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>
  <span class="comment">// get available glyphs</span>
  NSUInteger glyphCount = [_font numberOfGlyphs];
  _glyphPathArray = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:glyphCount];
 
  <span class="keyword">for</span> (NSUInteger i=<span class="number">1</span>; i&lt;=glyphCount; i++) {
    NSRect boundingRect = [_font boundingRectForGlyph:(NSGlyph)i];
    
    <span class="keyword">if</span> (!NSIsEmptyRect(boundingRect)) {

      <span class="comment">// convert glyph into bezier path</span>
      NSBezierPath *path = [[NSBezierPath alloc] init];
      [path moveToPoint:NSMakePoint(-NSMidX(boundingRect), -NSMidY(boundingRect))];
      [path appendBezierPathWithGlyph:(NSGlyph)i inFont:_font];
      [_glyphPathArray addObject:path];
    }
  }
</pre></td></tr></table></figure>

<p>为什么这里不从<code>0</code>开始遍历呢？因为<code>NSGlyph</code>有两个保留的值，分别是<code>NSControlGlyph = 0x00FFFFFF</code>
和<code>NSNullGlyph = 0x0</code>。因此值为<code>0</code>的 glyph 是不存在的，强制读取反而会产生乱码。</p>
<p>在上面的代码中值得注意的还有<code>NSBezierPath</code>的<code>appendBezierPathWithGlyph: inFont:</code>方法，
就是这个方法使得我们有可能将某个字符的外形抽取出来，这也是整个 Viewer 的核心所在。</p>
<h2>显示 Glyphs</h2>
<p>一般来说，是要用<code>NSCollectionView</code>来显示 Glyphs 的，不过习惯了 iOS 开发的开发者可能会觉得
<code>NSCollectionView</code>的使用方法没有<code>UICollectionView</code>那么直观。<code>NSCollectionView</code>主要依赖 Bindings
来显示内容，在某些时候可以节省很多代码，但是在需要细致定制的时候却有些麻烦。</p>
<p>这里采用一个模仿<code>UICollectionView</code>的第三方库 <a href="https://github.com/jwilling/JNWCollectionView" target="_blank">JNWCollectionView</a>，
用 CocoaPods 安装这个依赖。运行<code>pod install</code> 之后打开 <code>iconfontr.xcworkspace</code> 进行下一步的操作。</p>
<p>在<code>IFDocument.xib</code> 里加入并设置好<code>JNWCollectionView</code>，这里不再赘述。记得要将<code>JNWCollectionView</code>的
<code>dataSource</code> 指定为 <code>File&#39;s Owner</code>。</p>
<p>显示 Glyph 的要点在于<code>IFGlyphView</code>(这个类是<code>JNWCollectionViewCell</code>的子类)。
这个 View 重载了以下方法来将 Bezier 曲线绘制出来。</p>
<figure class="highlight lang-objectivec"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>
- (<span class="keyword">void</span>)drawRect:(NSRect)dirtyRect
{
  [<span class="keyword">super</span> drawRect:dirtyRect];
  [NSGraphicsContext saveGraphicsState];
  
  
  <span class="comment">// selection</span>
  <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.selected</span>) {
    NSBezierPath *border = [NSBezierPath bezierPathWithRect:<span class="keyword">self</span><span class="variable">.bounds</span>];
    [[NSColor colorWithCalibratedRed:<span class="number">0.3</span> green:<span class="number">0.5</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>] setStroke];
    [border setLineWidth:<span class="number">4.0</span>];
    [border stroke];
  }

  <span class="comment">// transform coordinates</span>
  NSAffineTransform *transform = [NSAffineTransform transform];
  [transform translateXBy:NSMidX(<span class="keyword">self</span><span class="variable">.bounds</span>) yBy:NSMidY(<span class="keyword">self</span><span class="variable">.bounds</span>)];
  [transform concat];
  
  <span class="comment">// draw path</span>
  [[NSColor blackColor] setFill];
  [_bezierPath fill];
  
  
  [NSGraphicsContext restoreGraphicsState];
}
</pre></td></tr></table></figure>

<h2>初之结语</h2>
<p>在上文介绍的方法之后再加上一点交互，iconfontr 就初具雏形了。下图为用 iconfontr 浏览
<a href="http://ionicons.com/" target="_blank">ionicons</a> 图标的效果。</p>
<p><img src="/img/iconfontr/result1.png" alt="Basic Viewer"></p>
<p>可以发现，截止目前这个小 App 其实不限于显示 Icon Font，而是可以打开任何
TTF 类型的字体。实际上，如果使用现在的 iconfontr 打开一个比较大的字体文件（比如包含上万字的中文字形）
很可能会出现性能问题，好在一般的 Icon Font 只有不到 1000 个字形，因此就不做进一步的优化了。</p>
<p>当然，如果只是一个字体浏览器，就没有必要叫做 iconfontr 了。接下来还要针对 Icon Font
的特点做一些特殊的优化，以下的功能会留到之后的文章中介绍：</p>
<ul>
<li>使用<code>WindowController</code>管理 Window 以实现更细致的控制</li>
<li>设置选中的 Glyph 的前景和背景颜色以便预览效果</li>
<li>缩放 Glyph</li>
<li>导出图片和 SVG</li>
</ul>
<p>截止于这一步的代码在项目仓库的 <a href="https://github.com/shanzi/iconfontr/tree/R01_BASIC_VIEWER" target="_blank">R01_BASIC_VIEWER</a>
TAG 上。</p>
]]></content>
    <summary type="html"><![CDATA[<p>得益于现代浏览器的普及，使用以 Web Font 作为基础的 Icon Font 来显示图标越来越流行了。
Icon Font 本身作为一种矢量素材，具有很多优点，比如可以在不同缩放和 Retina 显示屏上获得很好的显示效果，
可以用 CSS 指定颜色等。</p>
]]></summary>
    
      <category term="OSX" scheme="http://io-meter.com/tags/OSX/"/>
    
      <category term="Objective-C" scheme="http://io-meter.com/tags/Objective-C/"/>
    
      <category term="icon font" scheme="http://io-meter.com/tags/icon%20font/"/>
    
      <category term="icon" scheme="http://io-meter.com/tags/icon/"/>
    
      <category term="font" scheme="http://io-meter.com/tags/font/"/>
    
      <category term="iconfontr" scheme="http://io-meter.com/tags/iconfontr/"/>
    
      <category term="fontawesome" scheme="http://io-meter.com/tags/fontawesome/"/>
    
      <category term="zocial" scheme="http://io-meter.com/tags/zocial/"/>
    
      <category term="ionicons" scheme="http://io-meter.com/tags/ionicons/"/>
    
      <category term="bezier path" scheme="http://io-meter.com/tags/bezier%20path/"/>
    
      <category term="iconfontr" scheme="http://io-meter.com/categories/iconfontr/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Let Rocket Fly]]></title>
    <link href="http://io-meter.com/2014/04/05/let-rocket-fly/"/>
    <id>http://io-meter.com/2014/04/05/let-rocket-fly/</id>
    <published>2014-04-05T06:53:12.000Z</published>
    <updated>2014-04-05T09:14:46.000Z</updated>
    <content type="html"><![CDATA[<p>最近完成了我第一个相对完整的 WebGL 页面 <a href="http://sjtug.github.io" target="_blank">(点这里)</a>，
主要内容是一只可以旋转交互的小火箭。这篇文章就主要记录一下这个小项目的制作
过程。</p>
<a id="more"></a>

<h2>Logo 设计</h2>
<p>这个项目是作为我们新近成立的一个同好会类型的组织 SJTUG 的第一个页面。在
开始制作时，对于作为页面主题的组织 Logo 其实还没有什么想法。偶然的情况下
发现小火箭这种形象很适合作为 Logo，适当调整一下，做一个交互的东西也比较方便，
因此就果断的朝这个方向构思了。</p>
<p>首先是在矢量绘图软件中大概的完成 Logo 的平面形象，主要是从 Google Image 上搜索
出来一些已有的图案作为参考。用 CorelDRAW 绘制的 Logo 成图如下。</p>
<p><img src="/img/posts/Rocket480.png" alt="rocket" title="Rocket Logo"></p>
<p>在这里，记得要将 Logo 输出成不同的分辨率，以便于适配 Retina 的屏幕分辨率，
对于移动设备和不支持 WebGL 的浏览器，应该要能 fallback 到静态的图片。
支持 Retina 显示图片的话，可以用 <a href="http://retinajs.com" target="_blank">retina.js</a>，也可以像
我这里一样使用 CSS 。一个可以支持大多数设备的 CSS Media 选择代码如下所示：</p>
<figure class="highlight lang-css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span>	only screen and (-webkit-min-device-pixel-ratio: <span class="number">1.3</span>),
only screen and (-o-min-device-pixel-ratio: <span class="number">13</span>/<span class="number">10</span>),
only screen and (min-resolution: <span class="number">120</span>dpi)
</span>{
    <span class="comment">/* Things for retina display */</span>
    <span class="id">#logo</span> <span class="rules">{
        <span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">url(/img/Rocket960.png)</span>;</span></span>
    <span class="rule">}</span></span>
}
</pre></td></tr></table></figure>

<h2>Blender 建模与导出</h2>
<p>得益于 Three.js 提供了一个方便的 Blender 导出脚本， 制作基于 Web 的 3D 交互也方便很多。
在这里使用的 <a href="http://blender.org" target="_blank">Blender</a> 虽然不及总所周知的 MAYA 或者 3Ds MAX 那么出名，
但是作为一个开源的软件，其功能、易用性都是可圈可点的，自 2.50 版本其 UI 变得非常成熟了。</p>
<p>这个小火箭的形体是非常简单的，建模并不需要花费很多时间，在建模的时候简单的绘制一个参考
图作为参考会方便很多。最后得到的模型截图如下：</p>
<p><img src="/img/posts/blender-rocket.png" alt="blender model" title="blender model"></p>
<p>在图中显示的橘色条纹并不是贴图的效果。实际上，在这个例子中，既没有必要，也应该尽量避免
使用贴图。因为贴图的文件大小本身除了会拖慢页面的加载速度，在制作过程中为了得到比较好的
效果，还要模型进行 UV 展开等操作。此外使用贴图的话，条纹的边缘很有可能变的略显模糊。</p>
<p>那么该如何制作这个条纹呢？其实很简单，就是在飞船主体的表面用 knife 工具切出条纹所在的
表面，然后选择起来作为一个组赋予一个颜色。着这个过程中难免会出现非四边形的表面，
之前的 Blender 是不支持超过四个边的多边形的，那时必须要非常小心的增加不少边才能达到目的，
而且线框显示出来也不好看，还好较新的版本已经基本解决这个问题了。</p>
<p>虽然如此，超过四条边的多边形还是不建议出现的，不过由于我们的材质是纯色的，
而且并不需要移动节点位置，因此显示出来不会有很大的问题。条纹的基本情况就是下图所示了。</p>
<p><img src="/img/posts/blender-rocket-faces-knife.png" alt="stripe on rocket" title="stripe on rocket"></p>
<p>接下来是导出的工作，虽然 Three.js 提供的导出工具是支持导出颜色和材质的，但是在使用中
发现，也许是因为色彩系统的不一致，输出的模型在显示出来颜色并不正确，因此需要再手动
编辑一下输出的文件来调整颜色。</p>
<p>主要需要修改的是 <code>materials</code> 字段下每个材质的 <code>color</code> 属性
这个属性实质上相当于整形值，比如白色的十六进制表示 <code>0xffffff</code> 转化过来应该是 
<code>255^3 + 255^2 +255 = 16777215</code>。此外，在 <code>embeds</code> 字段当中内嵌的 <code>material</code> 
字段也是需要修改 <code>colorDiffuse</code> 属性的， 只不过此时颜色是由 RGB 三个颜色值组成的列表，值
最大是 <code>1.0</code>，因此要把整形的颜色分量值除以 <code>255</code>。</p>
<p>因为这里使用的是纯色的材质，不需要 Lambert 光照模型，因此我们在输出的 json 中把所有的
<code>lambert</code> 和 <code>MeshLambertMaterial</code> 都分别改成 <code>basic</code> 和 <code>MeshBasicMaterial</code>。</p>
<h2>使用 Three.js 导入模型</h2>
<p>Three.js 提供了将模型导入的类和函数，将其导入的代码很简单:</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.SceneLoader();
loader.load(<span class="string">"/js/rocket.json"</span>, <span class="keyword">function</span>(s){
  scene = s.scene;
  <span class="comment">// do something to the scene</span>
})
</pre></td></tr></table></figure>

<p>回调函数中的 <code>s.scene</code> 参数就是读出来的场景对象。为了能对火焰和飞船主体分别制作动画，我将他们
分成两个对象放置在场景中，然后在这里要分别取出来。在上面代码 do something 注释的地方
将两个物体分别赋给两个全局变量以便于之后调用。顺便还要旋转调整物体，让它和静态 Logo
 的位置角度都接近一致。最后把事先建立好的摄影机放到场景中。因为是使用<code>BasicMaterial</code>
所以灯光不是必须的。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>  rocket = s.objects[<span class="string">'Rocket'</span>];
  fire = s.objects[<span class="string">'Fire'</span>];

  <span class="comment">// rotate objects here</span>
  rocket.rotateOnAxis(rot_axis, <span class="number">1.508</span>);
  rocket.translateOnAxis(trans_axis, -<span class="number">2</span>)
  rocket.rotateOnAxis(rot_lean, -<span class="number">0.63</span>);

  fire.rotateOnAxis(rot_axis, <span class="number">1.508</span>);
  fire.translateOnAxis(trans_axis, -<span class="number">2</span>)
  fire.rotateOnAxis(rot_lean, -<span class="number">0.63</span>);

  scene.add(camera);
</pre></td></tr></table></figure>

<p>至于将 webGL 的 <code>canvas</code> 对象放置到页面中的过程这里就不赘述了。为了和静态 logo 一致，放置
一个橘色的带有 <code>border-radis: 50%</code> 属性的 <code>div</code> 到 <code>canvas</code> 对象后面，正好是一个圆形背景。</p>
<h2>创建交互</h2>
<p>在上面的代码已经提到过创建动态交互的基础函数了。在较新版本的 Three.js 里，可以用<code>rotateOnAxis</code> 
来实现物体绕轴旋转的变换，而不仅仅只能绕直角坐标系的 XYZ 轴旋转了。我们使用这个函数使小火箭可以
绕自己指向的轴进行旋转。</p>
<p>此外还可以对摄像机进行变换。摄像机最有用一个属性是 <code>position</code>，用来设定摄像机的位置。此外还有一个
非常神奇的函数，那就是 <code>lookAt</code>。<code>lookAt</code> 函数指定摄像机指向的点，Three.js 会调整摄像机的朝向使得
摄像机恰好“看向”这个点。</p>
<p>在最后的交互中，不但火箭会绕着自己的轴旋转，在鼠标扫过指定链接时还需要有一种加速感觉，
也就是让小火箭产生些微的震动。这其实就是通过让摄像机 <code>lookAt</code> 的点不断随机震动实现的。</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>axis_s.set(-Math.random(), -Math.random(), <span class="number">0</span>);
axis_s.multiplyScalar(<span class="number">0.4</span>);
camera.lookAt(axis_s);
</pre></td></tr></table></figure>

<p>让火箭的火焰不断震动则是通过设定 <code>scale</code> 属性:</p>
<figure class="highlight lang-javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span>(firescale&gt;=<span class="number">1</span>) firescale = firel - firer*Math.random();
<span class="keyword">else</span> firescale = firel + firer*Math.random();
fire.scale.z = firescale;
</pre></td></tr></table></figure>

<p>最后就是动画的效果了，如何让小火箭旋转的动画看起来更平滑？经过各种尝试，最后是通过限制
火箭旋转的速度来实现的。抽象来说，把页面上每个点映射到火箭的一个旋转和角度。当鼠标
移动时，并不是实时的就把火箭调整到这个位置，而是假设鼠标是一个目标，代表火箭实际状态的
点去不断追击鼠标。同时我们还考虑两点之间的距离作为追击速度的的参数，距离越近，速度越慢。
最后就形成了这种有加速的动画的感觉。</p>
<h2>总结</h2>
<p>这个小火箭算是我第一个 webGL 的小尝试，得益于 Three.js 的强大功能，最后实际手写的 JavaScript
只有 136 行，时间大约花费在两天。在这个过程中，主要的精力都放在调整模型和交互上面了，具体来说
就是需要对于模型和动画的感觉进行细致的调整，不断地尝试最后才能得到一个比较好的效果。实际上，
往往实现在脑海里觉得不错的效果，真正制作出来真正看在眼里就会觉得非常奇怪。</p>
<p>这个小项目的代码是静态托管在 Github pages 上的，源代码可以在 <a href="https://github.com/sjtug/sjtug.github.io" target="_blank">这里</a>
找到。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近完成了我第一个相对完整的 WebGL 页面 <a href="http://sjtug.github.io" target="_blank">(点这里)</a>，
主要内容是一只可以旋转交互的小火箭。这篇文章就主要记录一下这个小项目的制作
过程。</p>
]]></summary>
    
      <category term="webGL" scheme="http://io-meter.com/tags/webGL/"/>
    
      <category term="blender" scheme="http://io-meter.com/tags/blender/"/>
    
      <category term="Three.js" scheme="http://io-meter.com/tags/Three.js/"/>
    
      <category term="web" scheme="http://io-meter.com/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Let There Be Light]]></title>
    <link href="http://io-meter.com/2014/02/10/let-there-be-light/"/>
    <id>http://io-meter.com/2014/02/10/let-there-be-light/</id>
    <published>2014-02-09T16:05:15.000Z</published>
    <updated>2014-04-05T09:14:46.000Z</updated>
    <content type="html"><![CDATA[<p>新开一个博客，第一篇总要先写些关于博客及作者的事情才好。</p>
<a id="more"></a>

<p>本人之前曾经供稿于某个早已不在的科技博客，也参与过一些相关的运作，
但若说完全独立的去运营一个博客，还真是头一回。然而，弄一个独立的地方写一些有意义的东西上来，这种想法一直没有消失。
如今，虽多次拖延，终于还是在 hexo 的基础上，从其默认主题中修改出来这么一个写文章的地方。</p>
<p>io-meter 这个域名恐怕挺让人迷惑的，我说不出它和这里发表的文章内容有什么必然的联系，不过 Programic Creativity 这个
副标题可不是随意取的。概而言之，我想放在这里的文章首先都是与技术和编程相关的，其次还要与创造、设计等主题扯上点关系。</p>
<p>现在，计算机与艺术的结合已经不是什么稀罕事，用计算机处理视音频早已普及到生活的方方面面，包括 <a href="http://processingjs.org/" target="_blank">Processing.js</a> 、
<a href="http://supercollider.github.io/" target="_blank">SuperColider</a> 在内的一些编程生成图形、音频的工具也很流行。现在有一个艺术门类叫做 
<a href="http://en.wikipedia.org/wiki/Generative_art" target="_blank">Generative Art</a>，主要是使计算机随机（或自主）地生成一些
漂亮的平面或 3D 作品，这也是我比较感兴趣的方向。</p>
<p>视觉相关的东西是这里主要关注的方向，也是我主要的兴趣所在。<a href="http://blender.org" target="_blank">Blender</a>、Data Visulization、CorelDRAW、Web Design
这些东西我都有所爱好，因此这里的文章主题也会比较杂乱地涵盖这些方面。总之这里不会成为某一个方向的专业博客，可以看做我在视觉图形
方面一些小爱好的汇总，如果有什么小的项目，即便是与图形技术关系不大，我也会发上来作为一种记录。</p>
<p>本人作为一个地地道道的理工科生，在艺术方面是能力有限的。不过借助比较擅长的编程及计算机技能，倒是也能折腾出来
一些视觉上还能看得过去的东西。归根结底，其实是使用的工具比较强大的结果。强大的而新生的工具使得原来不可能做到的事情
变成可能，原来困难的事情也变得更加容易。拜其所赐，我这个死理性派也能制作出来有意思的东西了。当然，如果仅因
使用了新奇的工具而获得超过应有的关注，倒也显得有点本末倒置。</p>
<p>闲话说了这么多，最后希望有人与我有相似的爱好，欢迎与我交流。有什么问题请联系我吧。</p>
]]></content>
    <summary type="html"><![CDATA[<p>新开一个博客，第一篇总要先写些关于博客及作者的事情才好。</p>
]]></summary>
    
      <category term="io-meter" scheme="http://io-meter.com/tags/io-meter/"/>
    
      <category term="programing" scheme="http://io-meter.com/tags/programing/"/>
    
      <category term="essay" scheme="http://io-meter.com/categories/essay/"/>
    
  </entry>
  
</feed>
